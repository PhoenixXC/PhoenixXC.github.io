{"pages":[{"title":"关于","date":"2019-07-21T15:22:31.751Z","updated":"2019-07-21T15:22:31.751Z","comments":false,"path":"about/index.html","permalink":"https://phoenixxc.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2019-07-21T15:22:31.751Z","updated":"2019-07-21T15:22:31.751Z","comments":false,"path":"categories/index.html","permalink":"https://phoenixxc.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-07-21T15:22:31.758Z","updated":"2019-07-21T15:22:31.758Z","comments":false,"path":"repository/index.html","permalink":"https://phoenixxc.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-21T15:22:31.758Z","updated":"2019-07-21T15:22:31.758Z","comments":false,"path":"tags/index.html","permalink":"https://phoenixxc.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习笔记－疯狂Java讲义[4]","slug":"学习笔记－疯狂Java讲义[4]","date":"2019-07-21T15:32:17.774Z","updated":"2019-03-17T08:17:06.000Z","comments":true,"path":"posts/603dd0d7/","link":"","permalink":"https://phoenixxc.github.io/posts/603dd0d7/","excerpt":"","text":"第四章 流程控制与数组1.流程控制switch&emsp;&emsp;switch 语句后面控制表达式的数据类型只能是byte、short、char、int、枚举类型和java.lang.String类型。switch中其他类型会隐式向上转换为int，long比int范围大，转换可能会损失精度，Java通过string的hash()值把string也转换为int。 控制循环结构&emsp;&emsp;Java没有提供goto语句，与C类似，也有continue、break语句。不同的是，break和continue后可以紧跟标签来使得可以结束或直接跳到外层循环。 &emsp;&emsp;标签是一个紧跟英文冒号的标识符，Java中的标签只有放在循环语句前才有用。 代码清单 12345678910111213public class HelloWorld&#123; public static void main(String []args)&#123; outer: for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; System.out.println(\"Hello ~\"); if (j == 1) &#123; break outer; &#125; &#125; &#125; &#125;&#125; 2.数组&emsp;&emsp;数组也是一种数据类型，属于引用类型。数组用来存储一组具有相同数据类型的元素。Java中类与类可以继承，会造成一个数组中有多个类型的假象，但归根到底元素都属于同一种类型。数组一旦初始化完成后，其长度将固定不变。 &emsp;&emsp;数组是一种引用类型，定义一个数组后相当于只定义了一个指针，这个指针还没指向任何有效内存。所以定义数组的时候不能指定数组的长度。 数组的定义 12type[] arrayName; type arrayName[]; &emsp;&emsp;为了更好的可读性，推荐使用第一种定义方式。 数组的初始化 &emsp;&emsp;初始化，即为数组的数组元素分配内存空间，并给每个数组元素赋值，数组的定义和初始化可以同时完成。 初始化的两种方式： 静态初始化 初始化时显式指定数组元素的初值，长度由系统决定（指定长度会报错）。 语法格式： 123arrayName = new type[] &#123;element1, element2, ..., elementn&#125;;// 数组的定义和静态初始化同时完成可以省略 new type[]// type[] arrayName = &#123;element1, element2, ...&#125;; 初始化时type类型以及元素的类型要与定义数组时指定的类型一致（相同或为定义时指定类型的子类），元素以逗号分隔开。 动态初始化 初始化时只指定数组的长度，系统为数组元素分配初值。 语法格式： 1arrayName = new type[length]; type类型要求同上。length可以是已初始化的变量。 系统默认分配的初值为： 整数类型：0 浮点类型：0.0 字符类型：’\\u0000’ 布尔类型：false 引用类型：null 数组的使用 数组可以通过索引的方式去除数组元素或对其进行赋值 如果索引超出数组大小范围在运行时会抛出异常：java.lang.ArrayIndexOutOfBoundsException: N，N的值即为非法的数组索引。 数组的长度可以通过其length属性获得 Java5之后，Java提供了更简单的循环：foreach循环，可以自动遍历数组和集合的每个元素。 123for(type variableName : array | collection) &#123; // variableName 自动访问每个元素&#125; foreach循环中的循环变量variableName是一个临时变量，改变他并不能改变数或集合中元素的值 数组的实质 &emsp;&emsp;数组引用变量只是一个引用，数组元素和数组变量在内存里分开存储。而引用变量是访问真实对象的根本方式，只能通过数组的引用变量才能访问数组对象本身。 &emsp;&emsp;实际的数组对象存储在堆中，如果引用数组对象的数组引用变量是局部变量，它被存储在栈中，如果堆中的对象不在有任何变量指向它，会被JVM的垃圾回收机制回收。 &emsp;&emsp;通过对数组的重新赋值，产生数组长度可变的错觉，但实际堆中实际的数组对象并不可变。 程序清单 123456789101112131415public class ArrayInRam &#123; public static void main(String[] args) &#123; int[] a = &#123;5, 7, 20&#125;; int[] b = new int[4]; System.out.println(\"b 数组的长度\" + b.length); for (int temp : a) &#123; System.out.println(temp); &#125; for (int temp : b) &#123; System.out.println(temp); &#125; b = a; System.out.println(\"b 数组的长度\" + b.length); &#125;&#125; 多维数组 &emsp;&emsp;Java支持多维数组，但从本质上来说并没有多维数组。多维数组实质上其元素也是引用变量。 代码清单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TwoDimensionTest &#123; public static void main(String[] args) &#123; // 定义一个二维数组 int[][] a; // 初始化数组，数组a有四个元素，每一个元素都是int[]类型 a = new int[4][]; // Error! // a = new int[][4]; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; System.out.println(\"-----------\"); a[0] = new int[2]; a[0][1] = 6; for (int i = 0; i &lt; a[0].length; i++) &#123; System.out.println(a[0][i]); &#125; System.out.println(\"===========\"); // 初始化的多种方式 // One // int[][] b = new int[][] &#123; // new int[]&#123;1&#125;, // new int[]&#123;1, 2&#125;, // new int[]&#123;1, 2, 3&#125; // &#125;; // Two int[][] b = &#123; &#123;1&#125;, new int[2], new int[]&#123;1, 2, 3&#125; &#125;; // foreach() for (int[] tempArray : b) &#123; for (int tempValue : tempArray) &#123; System.out.println(tempValue); &#125; &#125; System.out.println(\"===========\"); // Error! // int[][] c = new int[2][] &#123; // 1, 2, 3, 4, 5, 6 // &#125;; int[][] c = new int[2][4]; &#125;&#125; 使用Arrays类 &emsp;&emsp;Java中Arrays类中的一些static方法可以直接操作数组，使用这些方法需要导入java.util.Arrays类(import java.util.Arrays)，static方法可以直接通过类名调用。 int binarySearch(type[] a, type key) 使用二分法在数组a中查询值为key的元素，返回其索引，查找失败返回负数。要求数组为升序排列。 int binarySearch(type[] a, int fromIndex, int toIndex, type key) 与上一个类似，只是限定查找索引范围为fromIndex到toIndex。 type[] copyOf(type[] original, int length) 将original复制为一个新的数组，新数组长为length，如果length大于原数组的长度，后面元素补充为0、false或null。 type[] copyOfRange(type[] original, int from, int to) 只复制数组的from索引到to索引的元素 boolean equals(type[] a, type[] a2) 判断两个数组是否相等（长度+数组对应元素） void fill(type[] a, type val) 将数组的所有元素设为val void fill(type[] a, int fromIndex, int toIndex, type val) 与上一个相同，只是限制了赋值的索引范围 void sort(type[] a) 对数组元素排序（自定义排序方法涉及到重载） void sort(type[] a, int fromIndex, int toIndex) 作用同上，只限制了排序的范围 String toString(type[] a) 将一个数组转换为字符串 代码清单 12345678910111213141516171819import java.util.Arrays;public class TwoDimensionTest &#123; public static void main(String[] args) &#123; String names[] = new String[]&#123; \"人生苦短\", \"来杯Java\" &#125;; String namesCopy[] = Arrays.copyOf(names, names.length); System.out.println(Arrays.toString(namesCopy)); names[0] = \"HelloWorld\"; System.out.println(Arrays.toString(names)); System.out.println(Arrays.toString(namesCopy)); &#125;&#125;// output------------------------------------------------------// [人生苦短, 来杯Java]// [HelloWorld, 来杯Java]// [人生苦短, 来杯Java]","categories":[{"name":"学习笔记 - 疯狂Java讲义","slug":"学习笔记-疯狂Java讲义","permalink":"https://phoenixxc.github.io/categories/学习笔记-疯狂Java讲义/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://phoenixxc.github.io/tags/Note/"},{"name":"Java","slug":"Java","permalink":"https://phoenixxc.github.io/tags/Java/"}]},{"title":"Chapter7-使用JSTL","slug":"Chapter7-使用JSTL","date":"2019-07-21T15:32:17.771Z","updated":"2019-03-17T08:17:06.000Z","comments":true,"path":"posts/2f1b8bf3/","link":"","permalink":"https://phoenixxc.github.io/posts/2f1b8bf3/","excerpt":"","text":"JSTL 简介JSTL 提供了与页面呈现相关的逻辑判断标签，也提供了对应 JSP 标注标签的扩展标签和更多的功能标签，可以分为五类： 核心标签库：提供条件判断、属性访问、URL 处理及错误处理等 I18N 兼容格式标签库：提供数字、日期等的格式化和区域、编码处理等功能 SQL 标签库 XML 标签库：提供 XML 解析、流程控制、转换等功能 函数标签库：提供常用字串处理的已定义 EL 标签库 idea 使用 JSTL 标签库： 在 JSTL 中下载最新的 zip 文件，解压。 idea 中打开设置，搜索 Schemas and DTDs，点右边的 +，URL中输入 http://java.sun.com/jsp/jstl/core，浏览文件选择刚才解压后文件夹中的 tld 目录下的 c.tld 文件。 将 zip 文件夹中的 lib 里的文件复制到项目中的 WEB-INF 的 lib 目录下，或者在 Project Setting -&gt; Libraries 中点＋，选择 lib 文件夹里面的文件。 核心标签库流程处理标签1234&lt;c:if test=\"$&#123;param.name == 'momor'&amp;&amp; param.password == '1234'&#125;\"&gt; &lt;h1&gt;$&#123;param.name&#125; 登录成功 &lt;/h1&gt;&lt;/c:if&gt;&lt;%-- JSTL中可以使用EL表达式--%&gt; 如果 test 属性为 true，才会输出 &lt;c:if&gt; 标签中的语句。 123456789101112&lt;c:choose&gt; &lt;c:when test=\"$&#123;user.valid&#125;\"&gt; &lt;jsp:getProperty name=\"user\" property=\"name\"/&gt; 登录成功 &lt;%-- * 属性的名称就是get/set方法去除get/set后 ,再把首字母小写 * boolean的方法可以是is开头 --%&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h1&gt; 登录失败 &lt;/h1&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 当 &lt;c:when&gt; test 为 true 时，只会输出这个标签中的 Body 内容。否则继续判断下一个 &lt;c:when&gt; 标签中的 test，如果所有的 &lt;c:when&gt; 都不满足，就输出 &lt;c:otherwise&gt; 的内容（如果有这个标签）。 123456&lt;c:forEach var=\"message\" items=\"$&#123;messageService.messages&#125;\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;message.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.text&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 类似 Java 中的 forEach 循环，items 属性可以是数组、Collection、Iterator、Enumeration、Map 与字符串。每次会从 items 中取出元素，指定给 var 属性设置的变量。 items 属性是 Map : &emsp;&emsp;设置给 var 的对象是 Map.Entry ，有 getKey() getValue() 方法取得键与值。 items 属性是字符串： &emsp;&emsp;以逗号来切割字符串，如果要自定义切割依据可以使用&lt;c:forTokens&gt; 123&lt;c:forTokens var=\"token\" delims=\";\" items=\"a;b;c;d;e\"&gt; &lt;%-- ... --%&gt;&lt;/c:forTokens&gt; 错误处理标签错误发生时，在当前网页捕捉异常并显示相关信息。使用 &lt;c:catch&gt; 标签。 1234567&lt;c:catch var=\"error\"&gt; $&#123;param.a&#125; + $&#123;param.b&#125; = $&#123;param.a + param.b&#125;&lt;/c:catch&gt;&lt;c:if test=\"$&#123;error != null&#125;\"&gt; &lt;br&gt;&lt;span style=\"color: red;\"&gt;$&#123;error.message&#125;&lt;/span&gt; &lt;br&gt;$&#123;error&#125;&lt;/c:if&gt; 用 &lt;c:catch&gt; 标签将可能产生异常的部分包起来，如果有异常会给 var 设值。所有的异常都是 Throwable 的子类，都有 getMessage() 方法。 网页导入、重定向、URL处理标签包含其他 JSP 网页到当前网页的几种方式： &lt;%@include file=&quot;/....&quot; %&gt; 使用 &lt;jsp:include&gt; 标签，动态包含，还可传递参数 JSTL 中有一个 &lt;c:import&gt; 标签，也可以在运行时动态导入到另一个网页。 1234567&lt;c:import url=\"add.jsp\"&gt; &lt;c:param name=\"a\" value=\"1\" /&gt; &lt;%-- 用 &lt;c:param&gt; 标签传递参数--%&gt;&lt;/c:import&gt;&lt;c:import url=\"https://....\" charEncoding=\"BIG5\" /&gt;&lt;%--导入外部网页，如果编码不同需指定具体编码--%&gt;&lt;%--没有使用参数--%&gt; &lt;c:redirect&gt; 标签，可以重定向网页，类似 Servlet 中的 HttpServletResponse.sendRedirect() 方法，可以使用 &lt;c:param&gt; 标签在重定向时指定参数。 之前利用 response.encodeURL() 方法来作 URL 重写，以在关闭 Cookie 后正常维持 Session 进行会话管理，现在可以用 &lt;c:url&gt; 标签达到同样的目的。 属性处理与输出标签可以用 JSTL 设置属性： 12345&lt;c:set var=\"p1q1\" value=\"$&#123;param.p1q1&#125;\" scope=\"session\" /&gt;&lt;%--属性值太长可以用 Body 形式--%&gt;&lt;c:set var=\"p1q2\" scope=\"session\"&gt; some....&lt;/c:set&gt; var 用来设置属性名，value 设置属性值（可以用 EL 表达式），如果不设置 scope ，会从 page 、request 、session、application 的范围中查找属性名称，如果找到就在该范围设置，找不到就在page 范围新建。 移除属性：&lt;c:remove var=&quot;login&quot; scope=&quot;session&quot;/&gt; &lt;c:set&gt; 可以设置 JavaBean 的属性或 Map 对象的键/值，需要使用 target 属性进行设置。 &lt;c:set target=&quot;${pageContext.request}&quot; property=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; 如果 target 属性是 JavaBean，就用 JavaBean 的 setXXX 方法为 property 设值。 如果是 Map 对象，则会以 property 为键，以 value 为值。 &lt;c：out&gt; 标签可以输出内容，并用合适的字符替换 &lt;、&gt;、”等字符。eg.&lt;c:out value=&quot;some&quot;&gt; 如果不想取代字符，可以设置属性 escapeXml 为 false （默认为 true），如果输出内容的 EL 表达式结果为 null 时，不会显示任何内容，也可以加上 default 属性设置为null时的默认值。","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://phoenixxc.github.io/categories/Servlet/"}],"tags":[{"name":"JSP&Servlet学习笔记","slug":"JSP-Servlet学习笔记","permalink":"https://phoenixxc.github.io/tags/JSP-Servlet学习笔记/"},{"name":"Note","slug":"Note","permalink":"https://phoenixxc.github.io/tags/Note/"}]},{"title":"Chapter6-使用jsp","slug":"Chapter6-使用jsp","date":"2019-07-21T15:32:17.771Z","updated":"2019-02-26T09:42:30.000Z","comments":true,"path":"posts/2bd95d05/","link":"","permalink":"https://phoenixxc.github.io/posts/2bd95d05/","excerpt":"","text":"指示元素JSP指示元素主要是为了表示容器将 JSP 转译为 Servlet 源代码时所必须遵守的信息。 语法为：&lt;%@ 指示类型 [属性=&quot;值&quot;]* %&gt;，指示元素可以有多对的属性/值 JSP 常用的三种指示类型为：page 、include、taglib page： 告知容器如何转译当前的JSP网页 include： 告知容器将别的JSP页面包括进来进行转译 taglib： 告知容器如何转译这个页面的标签库 12&lt;%@page import=\"java.util.Date\" %&gt;&lt;%@page contentType=\"text/html; UTF-8\" pageEncoding=\"UTF-8\"%&gt; 1：告知容器转译时要包括import属性中的值的包，即 Servlet 要有import java.uutil.Date;，如果有多个包要包含，可以用逗号分割开：... import=&quot;java.util.Date, java.util.io*, ...&quot; 2：contenType属性对应转译后的response.setContentType(&quot;...&quot;)，pageEncoding告诉容器这个网页的编码 include类型的范例： 12345&lt;!-- includeDemo.jsp --&gt;&lt;%@page contentType=\"text/html; UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@include file=\"/WEB-INF/jspf/header.jspf\"%&gt; &lt;h1&gt;这是本尊&lt;/h1&gt;&lt;%@include file=\"/WEB-INF/jspf/foot.jspf\"%&gt; 12345678910&lt;!--header.jspf--&gt;&lt;%@page contentType=\"text/html; UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!doctype html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;示范开头&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是开头&lt;/h1&gt; 12345&lt;!--foot,jspf--&gt;&lt;%@page pageEncoding=\"UTF-8\" %&gt; &lt;h1&gt;这是结尾&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; includeDemo.jsp 第一次执行时会将上面两个文件的内容包括起来，然后进行转译，所以最终会生成一个Servlet，这是一种静态的包括方式。&lt;jsp:include&gt;标签是运行时动态包括别的网页执行流程进行响应的方式，会各自生成独立的 Servlet。 同时也可以看到，包含的两个文件的后缀名是 .jspf，.jspf 文件通常是通过include伪指令包含在.jsp文件中的文件。’f’代表’fragment’，因为这些文件本身可能并不是完整的JSP，而是JSP的片段。类似这样的后缀名还有一个 .jspx。 同样，关于一些JSP的设置也可以在 web.xml 中更改，例如网页编码、内容类型等等 1234567891011&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;page-encoding&gt;UTF-8&lt;/page-encoding&gt; &lt;default-content-type&gt;text/html&lt;/default-content-type&gt; ... &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; 也可以声明指定的JSP文件的开头和结尾所要包括的网页 123456789... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;include-perlude&gt;some...&lt;/include-perlude&gt; &lt;include-coda&gt;some...&lt;/include-coda&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;... 在编写JSP网页时，换行字符不会忽略，所以最后产生的换行字符也会输出，如果要忽略，可以在 web.xml 中的&lt;jsp-property-group&gt;标签中加上 &lt;trim-directive-whitespaces&gt;true&lt;/...&gt; 声明、Scriptlet 与表达式元素JSP 中可以使用 声明、Scriptlet 元素和表达式来指定转译后 Servlet 类中包括的类成员、方法声明和语句。 声明元素的语法：&lt;@! 类成员声明或方法声明 %&gt; Scriptlet 的语法：&lt;% Java 语句 %&gt; 在 JSP 中的编写的 HTML，都会变成 out 语句所输出的内容，而 Scriptlet 出现的顺序在转译为 Servlet 后，会按顺序出现在 _jsoService() 中。 表达式元素的语法：&lt;%= Java表达式 %&gt; 表达式的运算结果将直接输出为网页的一部分，但表达式语句不能加上分号，因为在转译后，表达式语句的表达式会转译为 out 对象输出时的指定内容。 由于&lt;%和%&gt;在 JSP 中用来作为一些元素的开头和结尾，所以如果要在 JSP 网页中输出这两个符号要换成其他字符：&lt;% –&gt; &amp;lt;%，%&gt; –&gt; %&amp;gt;或%\\&gt; （HTML输出&amp;用&amp;amp）。 一个网页通过适当的规划、切割业务逻辑与呈现逻辑，JSP 网页可以通过标准标签、EL 或 JSTL 自定义标签等消除网页上的 Scriptlet。 注释元素使用 &lt;%-- JSP注释 --%&gt;，写出网页注释会输出到网页上。 隐式对象JSP 隐式对象 隐式对象 说明 out 转译后对应 JspWriter 对象，其内部关联一个 PrintWriter 对象 request 转译后对应 HttpServletRequest 对象 response 转译后对应 HttpServletResponse 对象 config 转译后对应 ServletConfig 对象 applicaton 转译后对应 ServletContext 对象 session 转译后对应 HttpSession 对象 pageContext 转译后对应 pageContext 对象，提供了 JSP 页面资源的封装，可设置页面范围属性 exception 转译后对应 Throwable 对象 ，代表其他 JSP 页面抛出的异常对象，只会出现于 JSP 错误页面 page 转译后对应 this 隐式对象只能在&lt;%和%&gt;或&lt;%=和%&gt;之间使用。隐式对象转译后是_jspService()中的局部变量。 JspWriter 主要模拟了 BufferedWriter 与 PrintWriter 的功能，内部也是用 PrntWriter 来输出，但 JspWriter 具有缓冲区功能，使用 print() 和 println() 响应输出时，如果 JSP 页面没有缓冲或清楚缓冲时，才会直接创建 printWriter() 对象进行输出。 page 指示元素的 buffer 属性来设置缓冲区的大小，默认是8kb，autoFlush 属性决定缓冲区已满后的行为，默认值是 true ，表示慢了就清除，如果设置为 false，要自行调用 JspWriter 的 flush() 方法来清除，否则调用 println() 会抛出 IOException 异常。 所有的隐式对象都可以通过 pageContext 的 getXXX() 方法来取得，pageContext 也可以设置页面范围属性，类似 Servlet 中的几个对象，可以使用 setAttribute()、getAttribute()、removeAttribute() 来设置。页面范围属性的作用范围仅仅局限于同一页面中。 pageContext 提供了单一的 API 来设置四种范围属性： 123getAttribute(String name, int scope);setAttribute(String name, Object value, int scope);removeAttribute(String name, int scope); scope 的取值所代表的范围： pageContext.PAGE_SCOPE: 页面 pageContext.REQUEST_SCOPE : 请求 pageContext.SESSION_SCOPE: 会话 pageContext.APPLICATION_SCOPE : 应用程序范围 如果不知道属性范围的名称，可以用 pageContext 的 findAttribute() 方法依序从页面、请求、会话、应用程序范围中寻找，先找到就返回。 错误处理JSP 发生错误按时段分为三种： JSP 转换为 Servlet 源代码 Servlet 源代码编译时 Servlet 载入容器进行服务但发生运行时错误时 可以自定义运行时异常发生时的处理页面，需要用 page 指示元素，设置 errorPage 属性来指定错误处理的页面。 12&lt;%--add.jsp--%&gt;&lt;%@page contentType=\"text/html; UTF-8\" pageEncoding=\"UTF-8\" errorPage=\"error.jsp\" %&gt; 12&lt;%--error.jsp--%&gt;&lt;%@page contentType=\"text/html; UTF-8\" pageEncoding=\"UTF-8\" isErrorPage=\"true\" %&gt; exception 对象是 JSP 的隐式对象，只有 isErrorPage 设置为 true 的页面才可以使用这个对象。如果没有处理，会由容器默认处理，直接显示异常信息和堆栈跟踪信息。 123456789101112&lt;web-app ...&gt; &lt;!--容器收到某个类型的异常对象时进行转发--&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.NullPointerException&lt;/exception-type&gt; &lt;location&gt;/report.view&lt;/location&gt; &lt;/error-page&gt; &lt;!--基于HTTP错误状态码转发至处理页面--&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt; 标准标签JSP 规范中提供了一些标准标签，所有容器都支持，可协助编写 JSP 是减少 Scriptlet 的使用，所有的标签都以 jsp: 为前缀。 &lt;jsp:include>、&lt;jsp:forward>标签&lt;jsp:include&gt; 和 &lt;jsp:forward&gt;标签在转译后，底层是取得 RequestDispatcher 对象，并执行对应的 forward() 方法和 include() 方法。 123&lt;jsp:include page=\"add.jsp\"&gt; &lt;jsp:param name=\"a\" value=\"1\"/&gt;&lt;/jsp:include&gt; &lt;jsp:param&gt; 指定了动态包括 add.jsp 时需要给页面的请求参数。 &lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt;JavaBean 元件具有的条件： 必须实现 java.io.Serializable 接口 没有公开的类变量 具有无参数的构造器 具有公开的设值(setXXX)和取值(getXXX)方法 &lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt; 这三个标准标签就是搭配 JavaBean 元件的。 12&lt;jsp:useBean id=\"user\" class=\"User\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"*\"/&gt; 1.用来取得或创建 JavaBean id 指定 JavaBean 的实例名，之后可使用这个指定的名称设值和取值。 class 属性指定要实例化哪个类。 还有一个属性 scope （默认为 page 范围）指定先查找设定的属性范围是否有名为id 指定值的 JavaBean 的属性存在，如果找到就直接使用，没有找到就会新建新的对象。 type 属性，指定声明 JavaBean 的类型，可以是一个抽象类、也可以是一个接口。但如果只设置了 type 而没有 class , 如果指定范围内找不到对象会抛出异常。 2.设置 JavaBean 的属性值 name 指定要使用哪个名称来使用 JavaBean 实例，property 表示要设置的 JavaBean 属性，这两个属性在这个标签中必需的。 value 和 param 两个属性可选，找到 JavaBean 后，如果指定了 value 元素，会将value的值转换为合适的基本类型赋值给指定的 JavaBean 属性。有 param 属性的话会将指定的参数的值转化会合适的基本类型赋给 JavaBean 属性。 如果value 和 param 都省略，可以用 JSP 的自省机制判断是否有 property 值相同的请求参数，有的话就赋给 JavaBean。 最有弹性的写法是示例代码第二行所示，标签中只有必要元素，property 值设为 *，代表将请求参数名称和 JavaBean 属性名交给自省机制自动匹配。自省机制可以自动转换基本类型。 有两种很容易混淆的写法： 12&lt;jsp:useBean id=\"user\" class=\"User\"/&gt;&lt;jsp:setProperty name=\"user\" property=\"*\"/&gt; 这种写法无论如何都会使用设值。 123&lt;jsp:useBean id=\"user\" class=\"User\"&gt; &lt;jsp:setProperty name=\"user\" property=\"*\"/&gt;&lt;/jsp:useBean&gt; 这种只有找不到 JavaBean 对象的时候，才会新建对象并设置值。 &lt;jsp:getProperty&gt; 只有一种使用方法：&lt;jsp:getProperty name=&quot;JavaBean 对象实例名&quot;, property=&quot;JavaBean 对象属性名&quot;&gt; ，然后用 pageContext 的 findAttribute()依次查找。 表达式语言（EL）JSP 中一些简单的属性、请求参数、标头和 Cookie 等信息可以用 EL 来处理，更加简便。 EL 是使用 ${ 与 } 来包括要处理的表达式。EL 处理了null值的情况，对 null 值直接以空字符串显示，运算时不会因此发生错误而抛出异常。 由于某些时候网页使用了模板等有类似EL表达式的语法存在，可以设置 JSP 网页是否使用 EL. web.xml 中修改 123456789&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; page 指示元素的属性 isELIgnored (default: false) 如果在 page 中设置了属性，以 page 中的设置为主。 隐式对象EL 中，可以用 EL 隐式对象指定范围来存取属性。如果不指定属性的范围，以 page、request、session、application 的顺序依次查找。 EL 中有11个隐式对象，只有 pageContext 隐式对象对应 PageContext ，其他都对应 Map 类型 pageContext PageContext 本身是 JavaBean 对象，所以只要是 getXXX() 方法，就可以使用 ${pageContext.xxx} 来取得。也可以使用点运算符连续存取对象。 属性范围相关隐式对象 表示作用范围，pageScope, requestScope, sessionScope, applicationScope 分别可以取得使用对应 JSP 隐式对象的 setAttribute() 方法所设置的属性对象。 请求参数相关隐式对象：param 和 paramValues ${param.user} 想当于 &lt;%= request.getParameter(&quot;user&quot;)%&gt; paramValues 相当于 request.getParameterValues() ，因为返回的可能是多个值，可以用 [] 运算符指定取得的是那个元素。 标头相关隐式对象：header 和 headersValues ${header[&quot;User-Agent&quot;]} reqest.getHeader(&quot;User-Agent&quot;) Cookie 隐式对象：cookie 用来取得用户 Cookie 设置值。 初始参数隐式对象：initParam 可以取得 web.xml 中设置的 ServletContext 初始参数 取得元素的方式可以用 . 和 [] 来取得属性中的元素： . 运算符：左边可以是 JavaBean 或 Map 对象（Map 建议用 [] 运算符） [] 运算符：左边可以是 JavaBean 属性，Map，数组或 List 对象 [] 在指定索引是使用双引号，就是作为键名或索引来使用，不加双引号会先尝试运算。 运算符 算数运算符：+, -, *(mod), /(div), %(mod), ? : 逻辑运算符：and, or, not 关系运算符：&lt;(lt), &gt;(gt), &lt;=(le), &gt;=(ge), ==(eq), !=(ne) 自定义函数第一步：编写类，公开类，且调用的方法是公开且为静态方法 第二步：编写 TLD（标签程序描述）文件（xml文件，以 .tld 为后缀），告诉容器如何将类中的方法作为 EL 函数 第三步：将文件放在 WEB-INF 文件夹下或 JAR 文件中","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://phoenixxc.github.io/categories/Servlet/"}],"tags":[{"name":"JSP&Servlet学习笔记","slug":"JSP-Servlet学习笔记","permalink":"https://phoenixxc.github.io/tags/JSP-Servlet学习笔记/"},{"name":"Note","slug":"Note","permalink":"https://phoenixxc.github.io/tags/Note/"}]},{"title":"Chapter2 编写与设置Servlet","slug":"Chapter2-编写与设置Servlet","date":"2019-07-21T15:32:17.768Z","updated":"2019-06-05T12:58:10.000Z","comments":true,"path":"posts/92aa08ef/","link":"","permalink":"https://phoenixxc.github.io/posts/92aa08ef/","excerpt":"","text":"在 HelloServlet 之后关于 HttpServletServlet 需要的包： 1234567// 与 Servlet 定义相关的类或接口都位于 javax.servlet 包中// 与 HTTP 定义先关的类与接口都位于 javax.servlet.http 包中import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletRequest; 当请求到来时，Web容器会调用 Servlet 的 service() 方法． HttpServlet 的 service() 方法的流程： 123456789101112protected void servlet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); // 取得请求的方法 if (method.equals(METHOD_GET)) &#123; // ... doGet(req, resp); // ... &#125; else if (method.equals(METHOD_HEAD)) &#123; // ... doHead(req, resp); // ... &#125; else ...&#125; 使用@WebServlet在Servlet3.0中，可以使用标注来告诉容器哪些Servlet会提供服务和额外的信息. 123@WebServlet(\"/hello.view\")public class HelloServlet extends HttpServlet &#123;// 告诉容器请求的URL如果是＂/hello.view＂，就由 HelloServlet 的实例来提供服务 1234567891011@WebServlet( name = \"Hello\", // 告诉容器这个 Servlet 的名称为 Hello, 默认为 Servlet 类的完整名称 urlPatterns = &#123;\"/hello.view\"&#125;, // 如果客户端的请求的URL是/hello.view，由这个Servlet的实例来处理 loadOnStartup = 1 // 默认值: -1 // 容器在首次处理某个Servlet服务时才会初始化对应的Servlet实例， // 如果希望应用程序启动时就将Servlet类载入, 实例化并初始化 // 可以用loadOnStartup设置为大于0的值, 数字小的初始化, 相同的值由容器自定义行为) 使用Web.xmlServlet3.0 之前, 必须通过web.xml来定义Servlet的相关信息, Servlet3.0中也可以用他来定义相关的信息. web.xml 中的设置会覆盖 Servlet 中定义的值（name 值要相同）. 123456789101112131415&lt;!--...--&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--名字--&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;!--Servlet 是 servlet-class 指定类的实例--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!--设置何时初始化, 值相同按照在web.xml中设置的顺序初始化--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloUser.view&lt;/url-pattern&gt; &lt;!--如果客户端请求的URL是/helloUser.view, 则由HelloServlet这个Servlet来处理--&gt; &lt;/servlet-mapping&gt;&lt;!--...--&gt; 文件组织与部署Web程序应用程序文件组织: 123456789├── other│ └── \\......└── web ├── index.jsp └── WEB-INF ├── classes │ └── HelloServlet.class ├── lib └── web.xml WEB-INF: 目录名称固定, 该目录对外界封闭, 客户端无法使用HTTP的任何方式直接访问该目录下的文件及目录 web.xml: 放在WEB-INF根目录下, 名称固定, Web应用程序部署描述文件 lib: 放置JAR文件的目录, 放在WEB-INF根目录下, 名称固定 classes: 放置编译后的.class文件的目录, 位于WEB_INF根目录下, 名称固定, 编译后的类文件, 必须有与包名称相符的目录结构 在部署Web应用程序时, 会将Web应用程序封装为WAR文件, 如过服务器使用Tomcat, 可以将war文件放置在tomcat安装目录的webapps目录中, 然后重启Tomcat服务. 然后可以用: http://(服务器ip或域名):(端口号)/(war文件名)/ 来访问 进阶部署设置…","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://phoenixxc.github.io/categories/Servlet/"}],"tags":[{"name":"JSP&Servlet学习笔记","slug":"JSP-Servlet学习笔记","permalink":"https://phoenixxc.github.io/tags/JSP-Servlet学习笔记/"},{"name":"Note","slug":"Note","permalink":"https://phoenixxc.github.io/tags/Note/"}]},{"title":"Chapter4 会话管理基本原理","slug":"Chapter4-会话管理基本原理","date":"2019-07-21T15:32:17.768Z","updated":"2019-02-26T09:42:30.000Z","comments":true,"path":"posts/b2e1ccaf/","link":"","permalink":"https://phoenixxc.github.io/posts/b2e1ccaf/","excerpt":"","text":"会话管理的基本原理Web应用程序中有些功能需要多次请求才能完成，所以需要某些方式来记得此次请求与之后请求之间的关系，这类方式称之为会话管理． 会话管理的基本方式有：隐藏域（Hidden Field），Cookie，URL重写等 使用隐藏域在HTTP协议中，服务器并没有记忆功能，那么可以让浏览器在每次请求时＂主动告知＂服务器多次请求间的必要信息，服务器只需单纯处理请求中的信息就好． 隐藏域就是主动告知服务器多次请求间必要信息的方式之一． 使用隐藏域的缺点： &emsp;&emsp;关掉网页后会丢失之前的信息，仅适合简单的状态管理，查看网页源码可以看到隐藏的信息，不适合用于隐秘性较高的数据． 隐藏域不是Servlet/JSP实际管理会话时的机制，实现Web应用程序会话的基本原理是由浏览器主动告知必要的信息． 使用 CookieCookie 是在浏览器存储信息的一种方式，服务器可以响应浏览器 set-cookie 标头，浏览器收到标头与数值后会以文件的形式存储在计算机上，即 Cookie. Cookie 可以设置存活期限．Servlet可以通过Cookie类的getMaxAge()方法获取Cookie的有效期；Servlet可以通过设置Cookie类的setMaxAge( int expiry ); //expiry默认值为 -1；1.如果expiry大于0，则保存有效期为expire时间长度，单位毫秒；2.如果expiry等于0，则指示浏览器删除当前cookie；3.如果expiry小于0，则指示浏览器不保存该cookie到硬盘，就保存在内存中，浏览器关闭就消失； 创建Cookie: 12345Cookie cookie = new Cookie(\"user\", \"caterpillar\");cookie.setMaxAge(7 * 24 * 60 * 60); // 以秒为单位// 创建cookie及其存活期限response.addCookie(cookie);// 将cookie加入响应之中 获取Cookie 12345678910111213Cookie[] cookies = request.getCookies();// 取得 Cookieif(cookies != null) &#123; for (Cookie cookie : cookies) &#123; String name = cookie.getName(); // 获取Cookie名称 String value = cookie.getValue(); // 获取Cookie数值 if (\"user\".equals(name) &amp;&amp; \"caterpillar\".equals(value)) &#123; request.setAttribute(name, value); request.getRequestDispatcher(\"/user.view\").forward(request, response); return; &#125; &#125;&#125; Servlet 3.0 中，Cookie增加了setHttpOnly()方法，将Cookie标示为仅用于HTTP，如果浏览器支持，这个Cookie不会被客户端脚本读取，可以用isHttpOnly()方法判断是否被标示 使用 URL 重写URL重写就是GET请求参数的应用，当服务器响应浏览器的上一次请求时，将某些相关信息以超链接的方式响应给浏览器，超链接包括请求参数信息． 由于URL重写是在超链接之后附加信息，所以必须以GET方式发送请求． 通常URL重写是用在一些简单的客户端信息保留，或者辅助会话管理． HttpSession 会话管理Servlet/JSP中会话管理的机制：HttpSession 使用 HttpSession获得HttpSession实例： 12345HttpSession session = request.getSession();// getSession()有两个版本// 另一个可以传入布尔值作为参数, // 默认为true，表示尚未存在HttpSession对象时, 直接创建一个新的对象// 如果是false，如不存在实例返回null 默认在浏览器关闭前，HttpSession都是相同的实例，如果想要让目前的HttpSession失效可以调用HttpSession的invalidate()方法，执行这个方法后，容器会销毁回收HttpSession对象，再调用getSession()取得的对象是另一个新对象. 设置与获得属性： setAttribute()：设置属性 getAttribute()：获得属性 HttpSession不是线程安全，需要注意属性设定的共享存取问题 HttpSession 会话管理原理尝试运行HttpSession的getSession()方法时，Web容器会创建HttpSession对象，每个对象都有一个特殊的ID: Session ID，可以用HttpSession的getId()来取得Session ID，ID默认使用Cookie存储在浏览器中． HttpSession中存放的属性也存放在服务端的Web容器里，当浏览器请求应用程序时，会将Cookie中的Session ID 一同发送给应用程序里，Web容器会根据得到的ID找到对应的Session对象，这样就可以取得各浏览器的各自的会话数据． Web容器存储Session ID的Cookie默认设置当浏览器被关闭就失效，浏览器重新启动后由于ID失效，尝试getSession()后，容器会产生新的HttpSession对象，如果不使用invalidate()使对象立即失效，对象会等到设定的失效期间过后才会被销毁回收． 设置HttpSession对象失效时间的方法： 调用该对象的setMaxInactiveInterval()方法，设定浏览器多久没请求应用程序的话就自动失效，单位为秒； 也可以在web.xml中修改，设定的单位是分钟 123456&lt;web-app...&gt; ... &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; HttpSession的属性中尽量不要存储耗资源的对象，必要时将属性移除（public void removeAttribute(String name)），或者让其失效． Servlet 3.0 中新增了SessonCookieConfig接口，可以通过ServleContext的getSessionCookieConfig()取得该接口的对象，通过这个接口的实现对象可以设定存储Session ID的Cookie相关的信息，设定必须在ServletContext初始化之前 在web.xml中设定 实现ServletContextListener HttpSession 与 URL 重写因为HttpSession默认使用Cookie来存储ID，如果浏览器禁用Cookie，还想使用HttpSession来进行会话管理的话，可以搭配URL重写，向浏览器响应一段超链接，超链接URL附加上Session ID，单击超链接后将Session ID以GET请求发送给Web应用程序． 如果要使用URL重写的方式发送Session ID，可以使用HttpServletResponse的encodeURL()协助产生需要的URL，如果Cookie可用，将URL本身输出，如果不可以会自动产生带有Session ID的URL重写．","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://phoenixxc.github.io/categories/Servlet/"}],"tags":[{"name":"JSP&Servlet学习笔记","slug":"JSP-Servlet学习笔记","permalink":"https://phoenixxc.github.io/tags/JSP-Servlet学习笔记/"},{"name":"Note","slug":"Note","permalink":"https://phoenixxc.github.io/tags/Note/"}]},{"title":"Chapter5 Servlet 进阶API,过滤器与监听器","slug":"Chapter5-Servlet进阶API，过滤器与监视器","date":"2019-07-21T15:32:17.768Z","updated":"2019-02-26T09:42:30.000Z","comments":true,"path":"posts/fd419a6b/","link":"","permalink":"https://phoenixxc.github.io/posts/fd419a6b/","excerpt":"","text":"使用 ServletContext 你可以把它想象成一个公用的空间，可以被所有的客户访问，也就是说A客户端可以访问D，B客户端可以访问D，C客户端也可以访问D。 WEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext，它代表当前Web应用。并且它被所有客户端共享。 ServletContext对象可以通过ServletConfig.getServletContext()方法获得对ServletContext对象的引用，也可以通过this.getServletContext()方法获得其对象的引用。 由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。公共聊天室就会用到它。 当web应用关闭、Tomcat关闭或者Web应用reload的时候，ServletContext对象会被销毁 作者：KLeonard来源：CSDN原文：https://blog.csdn.net/gavin_john/article/details/51399425版权声明：本文为博主原创文章，转载请附上博文链接！ 当整个Web应用程序加载Web容器后，容器会生成一个ServletContext对象作为整个应用程序的代表，可以通过ServletConfig的getServletContext()方法就可以取得ServletContext对象． ServletContext接口定义了运行Servlet的应用环境的一些行为，可以使用该接口的实现对象来取得所请求资源的URL，设置和存储属性，应用程序初始参数等． getRequestDispatcher() 用来取得RequestDispatcher()实例，路径必须是绝对路径，即以＂/＂开头（代表应用程序根目录）． HttpServletRequest.getRequestDispatcher(String)既可以使用相对路径也可以使用绝对路径，但是实际上在实现时，如果是环境相对路径则直接委托给ServletContext的getServletContext()，如果是请求相对路径则转换为环境相对路径后，再委托．","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://phoenixxc.github.io/categories/Servlet/"}],"tags":[{"name":"JSP&Servlet学习笔记","slug":"JSP-Servlet学习笔记","permalink":"https://phoenixxc.github.io/tags/JSP-Servlet学习笔记/"},{"name":"Note","slug":"Note","permalink":"https://phoenixxc.github.io/tags/Note/"}]},{"title":"Chapter3 请求与响应","slug":"Chapter3-请求与响应","date":"2019-07-21T15:32:17.758Z","updated":"2019-02-26T09:42:30.000Z","comments":true,"path":"posts/2b70cf0d/","link":"","permalink":"https://phoenixxc.github.io/posts/2b70cf0d/","excerpt":"","text":"从容器到 HttpServletweb 容器做了什么当浏览器请求来到HTTP服务器, HTTP服务器转交给容器, 容器会创建一个代表本次请求的HttpServlet对象, 并传给请求的相关信息, 同时会创建一个HttpServletResponse对象, 作为稍后要对客户端进行响应的Java对象. 然后, 容器会根据@WebServlet标注或web.xml的设置, 找到处理该请求的Servlet, 调用它的service()方法, 传入容器在之前所创建的两个对象, 在service()方法中会根据HTTP请求的方式来调用对应的doXXX()方法. 最后容器将HttpServletRequest对象和HttpServletResponse对象销毁回收, 结束本次响应. doXXX() 方法Servlet接口的service()方法中, 实际接受的参数是ServletRequest, ServletResponse, 在定义Servlet时, 期待Servlet不止用于HTTP, 与HTTP相关的行为由两者的子接口HttpServletRequest, HttpServletResponse 定义. 关于 HttpServletRequest处理请求参数与标头HttpServletRequest中定义了取得通用请求信息的方法 getParameter(): 指定请求参数名称来取得对应的值 1String username = request.getParameter(\"name\"); 返回String对象, 如果请求中没有指定的参数名称, 返回null getParameterValues(): 若同一个请求参数名称有多个值, 可以使用这个方法 1String[] values = request.getParameterValues(\"param\"); 返回一个存储了参数的值的String数组 getParameterNames(): 获取请求中所有的请求参数名称, 返回Enumeration对象 12345Enumeration&lt;String&gt; e = req.getParameterNames();while (e.hasMoreElements()) &#123; String name = e.nextElement(); // ...&#125; getParameterMap(): 将请求参数以Map对象返回, 键为请求参数名(String), 值为请求参数值(String[]) 获取HTTP标头信息 getHeader(): 与getParameter()类似, 指定标头名称返回标头信息 getHeaders(): 与getParameterValues()类似, 指定标头名称返回Enumeration对象, 元素为字符串 getHeaderName(): 与getParameterNames()类似, 取得所有标头名称, 返回Enumeration 请求参数编码处理 POST 如果客户端没有在 Content-Type 标头中设置字符编码, 使用HttpSerletRequest的getCharacterEncoding()返回值是null 可以使用HttpServletRequest的setCharacterEncoding()方法指定取得POST请求参数时使用的编码, 只有在取得参数前执行才有用. GET 如果是GET, 上述的方法设置编码无用. 另一种处理编码的方式: 通过String 的 getBytes()指定编码来取得字符串的字节数组, 然后再重新构造为正确编码的字符串. 1234String name = req.getParameter(\"name\");// 假设浏览器使用UTF-8, web容器使用ISO-8859-1name = new String(name.getBytes(\"ISO-8859-1\"), \"UTF-8\");// public String(byte[] bytes, String charsetName); Tomcat8URI默认编码为“UTF-8”，而Tomcat7URI默认编码为“ISO-8859-1” 原书为繁体, 如果要使结果正常需要使用Tomcat7环境, form-get.html, form-post.html两个网页用繁体(编码为Big5), 或者简体(编码为GBK) 参考资料: (转)Java 正确的做字符串编码转换 那么，如何利用getBytes 和 new String() 来进行编码转换呢？ 网上流传着一种错误的方法:GBK–&gt; UTF-8: new String( s.getBytes(“GBK”) , “UTF-8); ,这种方式是完全错误的，因为getBytes 的编码与 UTF-8 不一致，肯定是乱码。但是为什么在tomcat 下，使用 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 却可以用呢？ 答案是：tomcat 默认使用iso-8859-1编码， 也就是说，如果原本字符串是GBK的，tomcat传输过程中，将GBK转成iso-8859-1了，默认情况下，使用iso-8859-1读取中文肯定是有问题的，那么我们需要将iso-8859-1 再转成GBK， 而iso-8859-1 是单字节编码的，即他认为一个字节是一个字符， 那么这种转换不会对原来的字节数组做任何改变，因为字节数组本来就是由单个字节组成的，如果之前用GBK编码，那么转成iso-8859-1后编码内容完全没变， 则 s.getBytes(“iso-8859-1”) 实际上还是原来GBK的编码内容则 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 就可以正确解码了。 所以说这是一种巧合。 getReader(), getInputStream() 读取 Body 内容HttpServletRequest上有getReader()方法, 可以取得BufferedReader对象, 通过这个对象可以读取请求的 Body 数据. 12345678910private String readBody(HttpServletRequest request) throws IOException &#123; BufferedReader reader = request.getReader(); // 取得 BufferedReader 对象, 通过该对象可以读取请求的 Body 数据 String input = null; String requestBody = \"\"; while ((input = reader.readLine()) != null) &#123; requestBody = requestBody + input + \"&lt;br&gt;\"; &#125; return requestBody;&#125; 输出:1user=%E5%BC%A0%E4%B8%89&amp;passed=1234567&amp;login=%E9%80%81%E5%87%BA 如果要上传文件, \\&lt;form> 标签需要设置enctype属性为: multipart/form-data getPart() , getParts() 取得上传文件在Servlet3.0之后, 新增了Part接口, 可以方便的进行文件上传处理, 可以通过HttpServletRequest的getPart()方法并指定名称才能取得Part实现对象. Servlet中要设置@MultipartConfig标注才能取得Part对象, 否则会得到null, 仅仅标注@MultipartConfig表示相关属性使用默认值: fileSizeThreshold: 0 整数值, 若上传文件大小超过设置的值, 会先写入缓存文件 loaction: 空字符串 “” 设置写入文件时的目录 maxFileSize: -1L 不限制大小 限制上传文件的大小 maxRequestSize: -1L 不限制请求个数 限制 multipart/form-data请求个数 也可以使用getParts()来上传多个文件, 该方法返回一个Collection&lt;Part&gt; 123456789// ... for (Part part : req.getParts()) &#123; if(part.getName().startsWith(\"file\")) &#123; // 使用getName()获取名称, startsWith()判断名称是否以file开头 String filename= getFilename(part); part.write(filename); &#125; &#125;// ... 在 web.xml 中也可以设置@MultipartConfig属性: 123456789...&lt;servlet&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;UploadServlet&lt;/servlet-class&gt; &lt;multipart-config&gt; &lt;location&gt;/tmp/&lt;/location&gt; &lt;/multipart-config&gt;&lt;/servlet&gt;... 使用 RequestDispatcher 调派请求在 Web 应用程序中, 经常需要多个 Servlet 来完成请求, 这时可以使用HttpServletRequest的getRequestDispatcher()方法取得RequestDispatcher接口的实例, 调用时只需指定转发或包含相对的URL网址. 使用 include() 方法 RequestDispatcher 的 include() 方法可以将另一个 Servlet 的操作流程包括至目前 Servlet 操作流程之中. 12RequestDispatcher dispatcher = req.getRequestDispatcher(\"other.view\");dispatcher.include(req, resp); 在取得RequestDispatcher时也可以包括查询字符串, ...(&quot;other.view?data=123456&quot;); 请求范围属性 在include()或forward()时如果包括请求参数的做法只适用于传递字符串给另一个Servlet, 在调派请求中, 如果有必须共享的对象, 可以设置请求范围属性 HttpServletRequest上与请求范围属性有关的方法: setAttribute(): 指定名称与对象设置属性 getAttribute(): 指定名称取得属性 getAttributeNames(): 取得所有属性名称 remoteAttribute(): 指定名称移除属性 以java., javax.开头的名称通常保留, 用于表示一些特定的意义: javax.servlet.include.request_uri javax.servlet.include.context_path javax.servlet.include.servlet_path javax.servlet.include.path_info javax.servlet.include.query_string 在被包含的 Servlet 中分别表示上一个 Servlet 的 Request URI, Context path, Servlet path, Path info 和取得RequestDispatcher时给定的参数 使用 forward() 方法 调用时同样也要传入请求和响应对象, 表示要将请求处理转发给别的 Servlet , 对客户端的响应同时转发给另一个 Servlet 如果要调用forward()方法, 当前的Servlet中不能有任何响应确认, 如果通过响应对象设置了响应但未确认, 响应设置会全部被忽略, 如果有响应确认了仍调用这个方法, 会抛出IllegalStateException","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://phoenixxc.github.io/categories/Servlet/"}],"tags":[{"name":"JSP&Servlet学习笔记","slug":"JSP-Servlet学习笔记","permalink":"https://phoenixxc.github.io/tags/JSP-Servlet学习笔记/"},{"name":"Note","slug":"Note","permalink":"https://phoenixxc.github.io/tags/Note/"}]},{"title":"Servlet请求转发","slug":"Servlet请求转发","date":"2019-07-21T15:32:17.734Z","updated":"2019-03-17T08:17:06.000Z","comments":true,"path":"posts/e0aa16fa/","link":"","permalink":"https://phoenixxc.github.io/posts/e0aa16fa/","excerpt":"","text":"在 Servlet 中请求转发的方法无非两种： 使用 RequestDispatcher 来调派请求 使用 include() 来将另一个 Servlet 的操作流程包括至目前的操作流程中 使用 forward() 方法将请求处理转发给其他的 Servlet 使用 HttpServletResponse 的 sendRedirect() 方法要求浏览器重新请求另一个 URL 如果要调用 forward() 和 sendRedirect() 方法，那么目前的 Servlet 不能有任何响应确认，否则会抛出异常。 调用 forward() 方法时需要传入请求与响应对象，由于传递的是同一个 request，所以在转发过程中可以使用请求范围属性来传递一些属性。但 forward() 转发的这个动作是在 Web 容器中进行的，浏览器不知道请求被转发，地址栏也不会发生变化，转发也限制只能转发到服务器的另一个资源。而在整个转发过程中，都还是在同一个请求周期中。 当浏览器请求 Servlet1 后，Servlet1 将请求转发给了 Servlet2，之后 Servlet2 对浏览器进行响应，全程浏览器都不知道发送的请求已被转发。这样会存在的一个问题：当我刷新页面后，不过不加以处理会导致数据被重复提交。 比如现在有如下代码： 123456789101112131415161718&lt;%@page pageEncoding=\"UTF-8\" contentType=\"text/html; UTF-8\" %&gt;&lt;!doctype html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"testServlet\" method=\"post\"&gt; 用户名&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 消息&amp;emsp;&lt;input type=\"text\" name=\"message\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738package xuac;import java.io.*;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;/** * ClassName ServletTest-ServletOne * Description forward() * @author xuanc * @version 1.0 * @date 19-3-17 下午2:04 */@WebServlet(\"/testServlet\")public class ServletOne extends HttpServlet&#123; private void processRequest(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; System.out.println(\"forward() 测试 ----------------------\"); String username = request.getParameter(\"username\"); String message = request.getParameter(\"message\"); System.out.println(\"Username: \" + username + \"\\n\" + \"Message: \" + message); request.getRequestDispatcher(\"index.jsp\").forward(request, response); System.out.println(\"after forward()......................\"); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; processRequest(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; processRequest(request, response); &#125;&#125; 提交表单后在输出了表单内容。 而当刷新一次后： 浏览器会提醒重复提交表单 当确认后发现内容被重复提交： sendRedirect() 方法顾名思义，是重定向而非转发。可以让浏览器重新请求另一个 URL，请求的资源也可以是其他服务端的资源。与 forward() 不同，重定向实际上是两次请求，浏览器请求 Servlet1 时，Servlet1 将浏览器重定向到 Servlet2，然后浏览器向 Servlet2 发出请求，之后则由 Servlet2 做出响应或者其他的操作。这样的重定向浏览器是可以知道的，地址栏也会发生变化。 上面的例子中，解决刷新重复提交表单的方法之一就是使用重定向而不是转发（forward()）。另一种方法是使用 token，通过它来判断是否是重复提交，进而进行处理。 由于在重定向的过程中，并没有使用同一个 HttpRequest 对象，所以想要传递属性只能通过 Session 来处理。而且因为是两次请求，需要额外的往返行为，所以相比 forward() 来说重定向会慢一些。 在上面的例子中我们也可以看到，调用 forward 或 sendRedirect 不会停止执行方法中的其余代码。所以如果转发和重定向之后还有可能会执行其他语句的话应该加上 return。","categories":[{"name":"Servlet","slug":"Servlet","permalink":"https://phoenixxc.github.io/categories/Servlet/"}],"tags":[{"name":"JSP&Servlet学习笔记","slug":"JSP-Servlet学习笔记","permalink":"https://phoenixxc.github.io/tags/JSP-Servlet学习笔记/"},{"name":"Note","slug":"Note","permalink":"https://phoenixxc.github.io/tags/Note/"}]},{"title":"SpringBoot之Web开发","slug":"SpringBoot之Web开发","date":"2019-07-21T14:58:19.000Z","updated":"2019-07-21T14:59:02.000Z","comments":false,"path":"posts/d16715c9/","link":"","permalink":"https://phoenixxc.github.io/posts/d16715c9/","excerpt":"","text":"使用 SpringBoot： 创建 SpringBoot 应用，选中需要的模块 SpringBoot 默认将这些场景自动配置好，只需要在配置文件中指定少量配置 自己编写业务逻辑代码 SpringBoot 对静态资源的映射规则1234// org/springframework/boot/autoconfigure/web/ResourceProperties.java@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties &#123; // 可以设置与静态资源有关的设置，例如缓冲时间等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125;// 配置首页@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext) &#123; return new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125;// 配置喜欢的图标@Configuration@ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true)public static class FaviconConfiguration implements ResourceLoaderAware &#123; private final ResourceProperties resourceProperties; private ResourceLoader resourceLoader; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); // 在静态文件夹中寻找 mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler.setLocations(resolveFaviconLocations()); return requestHandler; &#125; private List&lt;Resource&gt; resolveFaviconLocations() &#123; String[] staticLocations = getResourceLocations(this.resourceProperties.getStaticLocations()); List&lt;Resource&gt; locations = new ArrayList&lt;&gt;(staticLocations.length + 1); Arrays.stream(staticLocations).map(this.resourceLoader::getResource).forEach(locations::add); locations.add(new ClassPathResource(\"/\")); return Collections.unmodifiableList(locations); &#125; 所有 /webjars/**，都去 classpath:/META-INF/resources/webjars/ 找资源； webjars：以 jar 包的方式引入静态资源； 在 webjars 这个网站上可以使用 maven 导入常用 js 库的 webjar 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; “/**” 访问当前项目的任何资源，对应 classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ /：当前项目根路径 12345678910public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" &#125;; /** * Locations of static resources. Defaults to classpath:[/META-INF/resources/, * /resources/, /static/, /public/]. */ private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; 欢迎页面的映射 页面图标映射（可能需要清除浏览器缓存 - Chrome 插件或者 Shift+F5） 需要放在映射路径的根目录下才可以。 By default, resources are mapped on /**, but you can tune that with the spring.mvc.static-path-pattern property. For instance, relocating all resources to /resources/** can be achieved as follows: 12&gt; spring.mvc.static-path-pattern=/resources/**&gt; You can also customize the static resource locations by using the spring.resources.static-locations property (replacing the default values with a list of directory locations). The root Servlet context path, &quot;/&quot;, is automatically added as a location as well. In addition to the “standard” static resource locations mentioned earlier, a special case is made for Webjars content. Any resources with a path in/webjars/** are served from jar files if they are packaged in the Webjars format. Do not use the src/main/webapp directory if your application is packaged as a jar. Although this directory is a common standard, it works only with war packaging, and it is silently ignored by most build tools if you generate a jar. 模板引擎Jsp、Thymeleaf、Velocity、Freemarker … SpringBoot 如果以 jar 的形式打包，而且由于 SpringBoot 使用的是内嵌的 Tomcat ，所以 SpringBoot 推荐使用 Thymeleaf. 引入Thymeleafpom.xml 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; Thymeleaf 语法自动配置的默认规则： 12345678@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; 只要把 html 放在 classpath:/templates/ 后，Thymeleaf 就会自动渲染。 使用： 导入 thymeleaf 名称空间： 1&lt;html lang=\"zh\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 使用语法 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;SUCCESS&lt;/h1&gt; &lt;!-- 将 div 的内容设置为... --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎数据&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 语法规则 th:text 改变当前元素里面的文本内容 th: 任意 html 属性，来替换原生属性的值 对应的行内写法： th:text =&gt; [[]] th:utext =&gt; [()] 表达式 Simple expressions:（表达式语法） Variable Expressions: ${...} 获取对象的属性，调用方法 使用内置的基本对象 #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 使用内置的工具对象 #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as theywould be obtained using #{…} syntax. #uris : methods for escaping parts of URLs/URIs #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{...}（选择表达式）和#{} 功能相同，补充使用：配置 th:object 使用，可以直接引用 th:object 的属性 Message Expressions: #{...} 获取国际化内容 Link URL Expressions: @{...} 定义 url，里面可以使用变量等值 Fragment Expressions: ~{...} 片段引用表达式 **Literals**（字面量） - Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… - Number literals: 0 , 34 , 3.0 , 12.3 ,… - Boolean literals: true , false - Null literal: null - Literal tokens: one , sometext , main ,… **Text operations:**（文本操作） - String concatenation: + - Literal substitutions: |The name is ${name}| **Arithmetic operations:**（数学运算） - Binary operators: + , - , * , / , % - Minus sign (unary operator): - **Boolean operations:**（布尔运算） - Binary operators: and , or - Boolean negation (unary operator): ! , not **Comparisons and equality:**（比较运算） - Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) - Equality operators: == , != ( eq , ne ) **Conditional operators:**（条件运算） - If-then: (if) ? (then) - If-then-else: (if) ? (then) : (else) - Default: (value) ?: (defaultvalue) **Special tokens:** - Page 17 of 104 - No-Operation: _","categories":[{"name":"springboot","slug":"springboot","permalink":"https://phoenixxc.github.io/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://phoenixxc.github.io/tags/springboot/"}]},{"title":"SpringBoot之日志","slug":"SpringBoot之日志","date":"2019-07-21T14:57:13.000Z","updated":"2019-07-21T14:59:02.000Z","comments":false,"path":"posts/18e9d6ab/","link":"","permalink":"https://phoenixxc.github.io/posts/18e9d6ab/","excerpt":"","text":"日志框架日志门面：日志的一个抽象层 市面上的日志框架：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…** 日志门面 日志实现 JCL（久不更新）、SLF4j、jboss-logging（不适用于普通人群） Log4j、JUL（Java 自带）、log4j2（框架好但是有些尚未适配）、Logback（与Log4j是同一个作者） 左边选一个门面（抽象层），右边选一个实现； SpringBoot ：底层为 Spring框架默认选择 JCL、而 SpringBoot 选择 SLF4j、logback SLF4j 的使用如何使用在开发时，不应直接调用日志的实现类，而是应该调用日志的抽象层的方法。 导入 SLF4j 的 jar 和 logback 的 jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 图示： 每一个日志的实现框架都有自己的配置文件，使用 SLF4j后，配置还是做成日志实现框架的自己的配置文件。 遗留问题A（SLF4j + logback）：Spring 、Hibernate、MyBatis、….. A 系统的依赖使用了其他的日志框架 统一日志记录，即使是别的框架也统一使用 SLF4j 输出 如何让系统中所有的日志都统一到slf4j： 将系统中其他日志框架先排除出去 用中间包来替换原有的日志框架 导入 slf4j 其他的实现 SpringBoot 与日志的关系SpringBoot 使用日志功能 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 底层依赖关系： 总结： SpringBoot 底层也是使用 slf4j + logback 的方式进行日志记录的 SpringBoot 把其他的日志都替换为了 slf4j Maven 排除 jar 包的方法： 12345678910111213&lt;dependency&gt; &lt;groupId&gt;sample.ProjectB&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;!-- declare the exclusion here --&gt; &lt;groupId&gt;sample.ProjectC&lt;/groupId&gt; &lt;artifactId&gt;Project-C&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;!-- ... --&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 也可以在 idea 的 maven 依赖树里面选中不需要的依赖，右键选择 删除 日志使用LogBack入门实践 12345678910111213141516171819// 记录器 private Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; // 日志的级别，由低到高 ------------------- // 可以调整输出的日志的级别；日志就只会在这个级别的以后的高级别生效 // 跟踪轨迹 logger.trace(\"这是 trace 日志...\"); // 调试信息 logger.debug(\"这是 debug 日志...\"); // SpringBoot 默认只会输出 info 级别：root 级别 // info logger.info(\"这是 info 日志...\"); // warning logger.warn(\"这是 warning 日志...\"); // error logger.error(\"这是 error 日志...\"); &#125; 1234567891011logging.level.com.xuanc=trace# =========== logging.path 与 logging.file 冲突 ===========# 指定目录，创建路径的文件夹，日志输出文件名默认使用 spring.loglogging.path=/tmp/spring/log# 如果不指定路径则在当前项目下生成日志，也可以指定路径#logging.file=springboot.log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中输出的日志的格式#logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n 日志输出格式： %d 表示时间日期 %thread 表示线程名 %-5level级别从左显示5个字符宽度 %logger{50} 表示 logger 名字最长为50个字符，否则按照据点分隔 %msg 日志消息 %n 换行符 具体的可以在 SpringBoot 的 logging 下面的文件中查看： 也可以自定义日志配置，在类路径下放上每个日志框架自己的配置文件后，SpringBoot 就不使用默认的配置了。 以下文件会根据你选择的日志系统进行加载： 日志系统 定制配置 Logback logback-spring.xml,logback-spring.groovy,logback.xml或logback.groovy Log4j log4j.properties或log4j.xml Log4j2 log4j2-spring.xml或log4j2.xml JDK (Java Util Logging) logging.properties 注 如果可能的话，建议你使用-spring变种形式定义日志配置（例如，使用logback-spring.xml（由 SpringBoot 完全控制）而不是logback.xml（日志框架会读取，跳过 SpringBoot））。如果你使用标准的配置路径，Spring可能不能够完全控制日志初始化。 使用 -spring 还有一个优点：由 SpringBoot 来解析日志配置，可以使用 SpringBoot 的高级 Profile 功能。 123&lt;springProfile name=\"staging\"&gt; &lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;&lt;/springProfile&gt; &lt;springProfile&gt;标签可用于根据激活的Spring profiles，选择性的包含或排除配置片段。Profile片段可以放在&lt;configuration&gt;元素内的任何地方，使用name属性定义哪些profile接受该配置，多个profiles以逗号分隔。 123456789101112&gt; &lt;springProfile name=\"staging\"&gt;&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt;&gt; &lt;/springProfile&gt;&gt; &gt; &lt;springProfile name=\"dev, staging\"&gt;&gt; &lt;!-- configuration to be enabled when the \"dev\" or \"staging\" profiles are active --&gt;&gt; &lt;/springProfile&gt;&gt; &gt; &lt;springProfile name=\"!production\"&gt;&gt; &lt;!-- configuration to be enabled when the \"production\" profile is not active --&gt;&gt; &lt;/springProfile&gt;&gt; 切换日志框架按照 SLF4j 的日志适配图，进行响应的转换。","categories":[{"name":"springboot","slug":"springboot","permalink":"https://phoenixxc.github.io/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://phoenixxc.github.io/tags/springboot/"}]},{"title":"SpringBoot之属性配置","slug":"SpringBoot之属性配置","date":"2019-07-21T14:55:00.000Z","updated":"2019-07-21T14:59:02.000Z","comments":false,"path":"posts/a29f8391/","link":"","permalink":"https://phoenixxc.github.io/posts/a29f8391/","excerpt":"","text":"配置文件SpringBoot 使用一个全局的配置文件： application.properties application.yml 配置文件的作用：修改 SpringBoot 自动配置的默认值。 以前的配置文件：使用的大多是 xml 文件。 yml 是YAML（YAML Ain’t Markup Language）语言的文件，以数据为中心，更适合做配置文件 YAML 语法基本语法key: value ==&gt; 表示一对键值对（空格不能省略），且对大小写敏感。 以空格的缩进来控制层级关系；只要是左对齐的一列数据都是同一层级的数据 1234server: port: 8081 path: /hello# 这是注释.. 值的写法 字面量：普通的值（数字、字符串、布尔） 字面量直接写，字符串默认不用加上单引号或者双引号； “”: 不会转义字符串的特殊字符，特殊字符作为本身要表示的意思 ‘’：会转义特殊字符，特殊字符只是一个普通的字符串数据 对象、Map（属性和值） Key: Value 对象还是键值对的形式，在下一行写对象的KV，但需要注意缩进 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangshan, age: 18&#125; 数组（List、Set） 用 - 值 表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法： 1pets: [cat, dog, pig] 上面三种格式可以互相嵌套。 获取配置文件值一、使用 @ConfigurationProperties配置文件 12345678910111213person: lastName: zhangsan # 驼峰命名可以转化为横杠：last-name age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1, k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2 Java Bean 123456789101112@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 还需要导入配置文件处理器，在 pom.xml 中加入： 123456&lt;!-- 配置文件处理器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 同样，在 properties文件中也可以配置，但是在里面输入中文会出现乱码（Spring Boot 是以 iso-8859 的编码方式读取 application.properties 配置文件）。 解决方法： 在 .properties 中加入: 12345&gt; spring.http.encoding.force=true&gt; spring.http.encoding.charset=UTF-8&gt; spring.http.encoding.enabled=true&gt; server.tomcat.uri-encoding=UTF-8&gt; 将 IDEA 设置中的 File Encodings 的 Transparent native-to-ascii conversion 打钩。 属性名匹配规则： person.firstName：使用标准方式 person.first-name：大写用 - person.first_name：大写用_ PERSON_FIRST_NAME： 推荐系统属性使用这种写法 二、使用 @Value使用 Spring 底层注解 @Value 来实现，获取配置文件或环境变量的值，或使用 SpEL @ConfigurationProperties 和 @Value 区别 Feature @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（属性名匹配规则） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持（注入时校验数据） 不支持 复杂类型封装 支持 不支持（只支持基本类型） 数据校验： 123456@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; @Email private String lastName; 这样，如果 lastName 不是一个有效的 email 的话会抛出异常。 加载指定的配置文件使用 @PropertySource 和 @ImportResource 可以记载指定的配置文件。 使用 @ConfigurationProperties 默认是从全局配置文件中获取值。 @PropertySource： 加载指定的配置文件 12345@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")// @Validatedpublic class Person &#123; @ImportResource：导入 Spring 的配置文件，让配置文件里面的内容生效 SpringBoot 里面没有 Spring 的配置文件，自己编写的配置文件也不能自动识别，想让 Spring 的配置文件生效，加载进来，需要把 @ImportResource 标注在配置类上： 123@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)@SpringBootApplicationpublic class SpringBoot02ConfigApplication &#123; SpringBoot 推荐的给容器添加组件的方式： 编写配置类 使用 @Bean 给容器中添加组件 12345678910@Configurationpublic class MyAppConfig &#123; // bean 的 id 与方法名相同 @Bean public HelloService helloService() &#123; return new HelloService(); &#125;&#125; 配置文件占位符 RandomValuePropertySource：配置文件中可以使用随机数 ${random.value}、${random.int}、${random.long}、${random.int(10)、${random.int[1024,65536]} 属性配置占位符 可以在配置文件中引用前面配置过的属性（优先级前面配置过得这里都能用） ${app.name: 默认值}来指定找不到属性的默认值 123456789#person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/12person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,c,dperson.dog.name=$&#123;person.last-name&#125;_dogperson.dog.age=15 如果属性不存在，则会将占位符当做字符串处理 ProfileProfile 是 Spring 对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境 多 profile 文件形式格式：application-{profile}.properties 默认使用 application.properties 配置文件。 YAML 文档块模式YAML 中如果使用 --- 可以将文件划分为不同的文档块，多个 profile 可以写在同一个文件中 1234567891011121314151617181920212223242526272829303132# Document1server: port: 8081person: lastName: zhangsan age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1, k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2spring: profiles: active: dev # 指定激活哪一个 profile---# Document2server: port: 8011spring: profiles: dev # 指定文档块属于哪个 profile---# Document3server: port: 8022spring: profiles: prod 使用其他环境的配置文件的方式： application.properties 或 application.yml 指定 YAML 的优先级比 .properties 要低 spring.profiles.active={profile} `spring: profiles: active: {profile}` 命令行方式（优先级较高）： idea 的 program arguments 设置 -- spring.profiles.active={profile} maven 打包后，在命令行执行并加上参数 虚拟机参数 idea 的 VM options: -Dspring.profiles.active={profile} 配置文件的加载位置SpringBoot 启动会扫描以下位置的 application.properties或者 application.yml 文件作为 SpringBoot 的默认配置文件：（Idea 中类路径即 classpath:对应 resources 目录） file:/config/ file:/ classpath:/config classpath:/ 以上按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置的内容会覆盖低优先级配置的内容，也可以通过配置 spring.config.location 来改变默认内容。 SpringBoot 会加载上述的所有文件，只是如果配置冲突，高优先级的配置文件中的设置会覆盖低优先级配置文件的设置，低优先级的其他配置依然会生效。 例如在上述四个配置文件中分别定义不同的端口号，在 /resource/application.properties 文件中定义项目的访问路径，那么运行后低优先级配置的项目访问路径仍然有效： 12345server.port=8081# 配置项目的访问路径server.servlet.context-path=/springboot-demo# 新版本的配置改为：server.servlet.context-path，而不是 server.context-path 指定配置文件路径项目打包好后，可以使用命令行参数的形式，在启动项目时指定配置文件的新位置，指定的配置文件和默认加载的配置文件会共同启动作用，形成互补配置。 直接在上述的四个配置文件中指定 spring.config.location 并不会生效。 外部配置的加载顺序官网文档中文手册上提到的外部配置的加载顺序： Spring Boot允许将配置外部化（externalize），这样你就能够在不同的环境下使用相同的代码。你可以使用properties文件，YAML文件，环境变量和命令行参数来外部化配置。使用@Value注解，可以直接将属性值注入到beans中，然后通过Spring的Environment抽象或通过@ConfigurationProperties绑定到结构化对象来访问。 Spring Boot设计了一个非常特别的PropertySource顺序，以允许对属性值进行合理的覆盖，属性会以如下的顺序进行设值：（优先级从高到低，高优先级覆盖低优先级，形成互补） home目录下的devtools全局设置属性（~/.spring-boot-devtools.properties，如果devtools激活）。 测试用例上的@TestPropertySource注解。 测试用例上的@SpringBootTest#properties注解。 命令行参数（多个参数可以用空格分隔开） 来自SPRING_APPLICATION_JSON的属性（环境变量或系统属性中内嵌的内联JSON）。 ServletConfig初始化参数。 ServletContext初始化参数。 来自于java:comp/env的JNDI属性。 Java系统属性（System.getProperties()）。 操作系统环境变量。 RandomValuePropertySource，只包含random.中的属性。 没有打进jar包的Profile-specific应用属性（application-{profile}.properties和YAML变量）。 打进jar包中的Profile-specific应用属性（application-{profile}.properties和YAML变量）。 没有打进jar包的应用配置（application.properties和YAML变量）。 打进jar包中的应用配置（application.properties和YAML变量）。 @Configuration类上的@PropertySource注解。 默认属性（使用SpringApplication.setDefaultProperties指定）。 自动配置的原理配置文件可配置属性的范围： 官方文档 自动配置原理： SpringBoot 启动时，加载主配置类，开启了自动配置功能 @EnableAutoConfiguration @EnableAutoConfiguration 作用 利用 AutoConfigurationImportSelector.class 给容器中导入组件，里面的 public String[] selectImports(AnnotationMetadata annotationMetadata) { ... } 方法中， 调用了 protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {...} 方法，这里面有一句代码是这样的： 1List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 通过这行代码来获取候选的配置。 1234567protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames( this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\"); return configurations;&#125; 里面的 loadFactoryNames 方法的源码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; try &#123; // 扫描所有jar包类路径下的 META-INF/spring.factories 文件 Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); // 获取 url 后对每个 url 进行遍历 while (urls.hasMoreElements()) &#123; // 把扫描到的文件内容包装为 properties 对象 URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; // 从 properties 对象中获取全类名 String factoryClassName = ((String) entry.getKey()).trim(); for (String factoryName : StringUtils. commaDelimitedListToStringArray((String) entry.getValue())) &#123; // 添加 result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(\"Unable to load factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); &#125;&#125;// 返回 EnableAutoConfiguration.class 类protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123; return EnableAutoConfiguration.class;&#125; 所以总的来说，是将 META-INF/spring.factories 里面的所有 EnableAutoConfiguration 的值加入到容器中。使用这些类来做自动配置： 每一个自动配置类进行自动配置功能 以 HttpEncodingAutoConfiguration 为例 1234567891011121314151617181920212223242526272829303132333435@Configuration// 表示这是一个配置类@EnableConfigurationProperties(HttpProperties.class)// 启用指定类的 ConfigurationProperties 功能，将配置文件中对应的值与这个properties类绑定在一起，并把 HttpProperties 加入到 Ioc 容器中@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)// Spring 底层注解，根据不同的条件决定配置是否生效；// 判断当前应用是否为 web 应用，如果是则生效@ConditionalOnClass(CharacterEncodingFilter.class)// 判断当前项目有没有这个类(Spring MVC 解决乱码中的过滤器)@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true)// 判断在配置文件中是否启用，如果配置这个属性，也生效public class HttpEncodingAutoConfiguration &#123; // 已近与 SpringBoot 的配置文件映射了 private final HttpProperties.Encoding properties; // 只有一个有参构造器的情况下，参数的值会从容器中获取 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; // 给容器中添加组件，有些值需要从 properties 中获取 @Bean // 容器中没有这个组件时候才会执行 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding( this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding( this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断。决定配置类是否生效，一旦配置类生效，这个配置类就会在容器中添加各种组件，这些组件的属性是从对应的 propertie 类中获取的，而这些类的每一个属性又是和配置文件绑定的。 所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类 123@ConfigurationProperties(prefix = \"spring.http\")// 从配置文件中获取指定的值和 bean 的属性进行绑定public class HttpProperties &#123; SpingBoot 的精髓： SpringBoot 启动会加载大量的自动配置类 我们需要的功能有没有 SpringBoot 默认写好的自动配置类 在看这个自动配置类到底配置了哪些组件，如果有，就不需要自动配置了 给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性，可以在配置文件中指定属性的值 @Conditional 扩展注解 @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 查看哪些配置类自动生效： 通过启用 debug 属性来打印自动配置报告： 12# 开启 SpringBoot 的 debug 模式debug=true","categories":[{"name":"springboot","slug":"springboot","permalink":"https://phoenixxc.github.io/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://phoenixxc.github.io/tags/springboot/"}]},{"title":"SpringBoot之环境配置","slug":"SpringBoot之环境配置","date":"2019-07-21T14:51:45.000Z","updated":"2019-07-21T14:59:02.000Z","comments":false,"path":"posts/cb2b0fb3/","link":"","permalink":"https://phoenixxc.github.io/posts/cb2b0fb3/","excerpt":"","text":"将 SpringBoot 项目打包为 Jar 包maven pom.xml 中加入如下代码： 123456789&lt;build&gt; &lt;!-- 插件作用：将应用打包为可执行的 jar 包 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 使用 mvn package 就可以将应用打包。 在终端里 cd 到 jar 的位置后，java -jar (jar包名称或路径） 就可以运行项目，而且不需要配置 tomcat 环境，因为 SpringBoot 集成了 tomcat。 POM 文件解析父项目123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 父项目作用：依赖管理 这个父项目还有一个父项目： 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 这个父项目才是真正管理 Spring Boot 应用里面的所有的依赖管理的，其 &lt;properties&gt; 属性规定了常用包的版本号。所以导入以及规定版本的包是不需要写版本号的。 导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web: spring-boot 场景启动器，导入了 web 模块正常运行需要的依赖 Sping Boot 将所有的功能场景都抽取出来，做成一个 starters，只需要在项目里面引入这些 starter 相关的场景依赖都会自动导入进来。 主程序类1234567891011@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring 应用启动起来 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125; @SpringBootApplication 说明被注解标注的类是 SpringBoot 的主配置类，SpringBoot 应该运行这个类的 main 方法来启动 SpringBoot 应用。 注解部分源码： 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration : 表示被标注的类是 SpringBoot 的配置类，配置类也是容器中的一个组件 @EnableAutoConfiguration：开启自动配置的功能 自动配置的原理： 注解部分源码： 1234&gt; @AutoConfigurationPackage&gt; @Import(&#123;AutoConfigurationImportSelector.class&#125;)&gt; public @interface EnableAutoConfiguration &#123;&gt; @AutoConfigurationPackage : 自动配置包，使用 @Import({Registrar.class}) 这个 Spring 底层注解来实现，给容器中导入一个组件。 12&gt; &gt; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;&gt; &gt; 将主配置类 （@SpringBootApplication 标注的类）的所在包下面的所有子包里面的所有组件扫描到 Spring 容器 @Import({AutoConfigurationImportSelector.class}): 给容器中导入组件 将所有需要导入的组件以全类名的方式返回，添加到容器中。会给容器中导入非常多的自动配置类（xxxAutoConfiguration），就是给容器中导入这个场景所需要的所有组件，并配置好这些组件。 AutoConfigurationImportSelector 类部分代码： 12345678910&gt; &gt; public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;&gt; &gt; if (!this.isEnabled(annotationMetadata)) &#123;&gt; &gt; return NO_IMPORTS;&gt; &gt; &#125; else &#123;&gt; &gt; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);&gt; &gt; AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);&gt; &gt; return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&gt; &gt; &#125;&gt; &gt; &#125;&gt; &gt; 方法 getAutoConfigurationEntry 中的 List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations 数组就是容器中需要导入的组件。 SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); 从类加载器中获取资源，将资源作为 properties 配置文件，从中拿出工程的名字：factoryClass.getName()。 从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中。 有了自动配置类，就免去了手动编写而配置注入功能组件等的工作。 J2EE 的整体解决方案和自动配置都在 spring-boot-autoconfigure-xxx.RELEASE.jar; 使用 Spring Initializr 快速创建项目Idea 或者官网的 Spring Initialzr 可以快速创建项目。 默认生成的 Spring Boot 项目： 主程序、测试文件生成好了 resource 文件夹的目录结构 static: 保存所有的静态资源：js、css、images； templates: 保存所有的模板页面；（由于使用嵌入式的 Tomcat，默认不支持 JSP） application.properties: Spring Boot 应用的配置文件，可以修改默认设置；","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://phoenixxc.github.io/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://phoenixxc.github.io/tags/SpringBoot/"}]},{"title":"readline库的简单使用","slug":"readline库的简单使用","date":"2019-01-26T09:37:00.000Z","updated":"2019-02-26T09:42:30.000Z","comments":true,"path":"posts/3faf94c3/","link":"","permalink":"https://phoenixxc.github.io/posts/3faf94c3/","excerpt":"","text":"&emsp;&emsp;这周要实现一个简单的 shell, 平时使用bash, zsh这些shell的时候, 如果文件名或命令太长，又或者要频繁执行几条命令的话，最常用的应该就是tab键补全和上下键切换历史命令了。 &emsp;&emsp;想要在自己的shell里面实现这两个功能很困难，但有一个Ｃ语言库集成了这些功能，只需要调用几个函数就可以实现这两个功能。 &emsp;&emsp;The GNU Readline Library &emsp;&emsp;可以在这里找到有关 readline 库的相关资料和下载地址，软件包里面也提供了很多手册和示例。 &emsp;&emsp;实现shell用到的函数不是很多，tab键补全，上下键切换历史命令，添加历史命令等等 readline()&emsp;&emsp;在 readline.h 里可以找到关于他的定义： 123/* Readline functions. *//* Read a line of input. Prompt with PROMPT. A NULL PROMPT means none. */extern char *readline PARAMS((const char *)); &nbsp;&nbsp;&nbsp;&nbsp;readline() 的参数是一个字符串，调用函数的时候会在屏幕上输出，这个函数会读取一行输入，然后返回一个指向输入字符串的指针，readline 会为输入的字符串动态分配内存，所以使用完之后需要free掉。 &emsp;&emsp;下面举一个简单的例子 1234567891011#include &lt;stdlib.h&gt;#include &lt;readline/readline.h&gt;int main(void)&#123; while (1) &#123; char * str = readline(\"Myshell $ \"); free(str); &#125;&#125; &nbsp;&emsp;&emsp;由于readline是一个动态库，编译的时候需要加上 -lreadline，不然会找不到相关的函数当我们按下tab键之后发现就可以实现bash里面的补全功能了。 &emsp;用惯了zsh后发现黑白的提示符好难看，于是也想着给里面的参数加上颜色。C语言中输出有颜色的字符printf就可以实现，模板类似这样printf(&quot;\\033[47;31m string \\033[0m&quot;); &emsp;&emsp;47是背景色，31是字符的颜色，string 是要输出的字符串，\\033[5m 是ANSI控制码，意思是关闭输出的属性，不然以后的输出都会是之前设置的颜色。相关的内容网上有很多可以自行查阅。 &emsp;&emsp;为了方便使用，加上了这些宏定义 123#define CLOSE \"\\033[0m\" // 关闭所有属性#define BLOD \"\\033[1m\" // 强调、加粗、高亮#define BEGIN(x,y) \"\\033[\"#x\";\"#y\"m\" // x: 背景，y: 前景 &emsp;&emsp;在修改一下readline()这个函数 1char * str = readline(BEGIN(49, 34)\"Myshell $ \"CLOSE); &emsp;&emsp;然后编译运行： &emsp;&emsp;似乎一切完美，但当我们输入很长很长的字符串之后：&emsp;&emsp; &emsp;&emsp;emmmm……………输入太多会导致提示符被输入覆盖，写个shell出现这种状况岂不是贼尴尬 &emsp;&emsp;查资料查了很久才找到解决方法：这个bug需要在非打印字符前后加上 \\001 和 \\002 才能解决 &emsp;&emsp;其实头文件就有提到 &emsp;&emsp;在之前定义的宏里面加上这两个字符之后终于解决了 &emsp;&emsp;最后的代码为： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;readline/readline.h&gt;#define CLOSE \"\\001\\033[0m\\002\" // 关闭所有属性#define BLOD \"\\001\\033[1m\\002\" // 强调、加粗、高亮#define BEGIN(x,y) \"\\001\\033[\"#x\";\"#y\"m\\002\" // x: 背景，y: 前景int main(void)&#123; while (1) &#123; char * str = readline(BEGIN(49, 34)\"Myshell $ \"CLOSE); free(str); &#125;&#125; &emsp;&emsp;readline使用的时候默认了tab补全，但是我们平时用到的shell不但可以补全文件名，还可以补全命令。readline库当然也提供了这个功能，具体如何使用可以看这篇博客。 &emsp;&emsp;GNU Readline 库及编程简介 &emsp;&emsp;单独的使用readline()并没有上下键切换补全的功能，实现这个需要用到另一个函数 - add_history() history.h&emsp;&emsp;上下键切换需要我们把输入的字符串加入到历史命令中，需要调用 123/* Place STRING at the end of the history list. The associated data field (if any) is set to NULL. */extern void add_history PARAMS((const char *)); &emsp;&emsp;函数接受一个字符串作为参数存入到历史文件中，函数的定义在history.h中，使用的时候需要包含头文件 &lt;readline/history.h&gt; &emsp;&emsp;我们在代码中加入这个函数的调用就可以使用上下键切换历史命令了 123char * str = readline(BEGIN(49, 34)\"Myshell $ \"CLOSE);add_history(str);free(str); &emsp;&emsp;编译后测试了一下发现功能完美运行。 &emsp;&emsp;但是关掉程序在尝试一下发现，诶？我不能切换到上一次运行程序的历史命令，只能记录本次运行中输入的命令。然后开始查看头文件的内容，发现了不少和history有关的函数。 &emsp;&emsp;其中有两个正好用的上 12345678/* Add the contents of FILENAME to the history list, a line at a time. If FILENAME is NULL, then read from ~/.history. Returns 0 if successful, or errno if not. */extern int read_history PARAMS((const char *));/* Write the current history to FILENAME. If FILENAME is NULL, then write the history list to ~/.history. Values returned are as in read_history (). */extern int write_history PARAMS((const char *)); &emsp;&emsp;read_history()和write_history()都接受一个字符串做参数，成功返回０，错误则把相应的错误码赋值给errno。 &emsp;&emsp;两个函数接受的参数都是一个文件名，read_history() 从指定的文件中读取历史记录，write_history() 将历史记录存入指定的文件。如果参数为NULL默认的文件是：~/.history &emsp;&emsp;有了这个函数，我们只要在程序最开处加上read_history(NULL), add_history(str)之后加上 write_history() 就可以了。 &emsp;&emsp;这样下次运行程序的时候我们就可以找到上次运行的历史命令了。 &emsp;&emsp;shell 的内置命令不多，cd 是一个, history也是一个shell内置的命令。 &emsp;&emsp;readline既然可以把输入加入历史，读入和写进历史，那么自然可以读取历史文件列表，头文件中我们可以找到这样一个函数： 12/* Return a NULL terminated array of HIST_ENTRY which is the current input history. Element 0 of this list is the beginning of time. If there is no history, return NULL. */extern HIST_ENTRY **history_list PARAMS((void)); &emsp;&emsp;这个函数可以查看存储的 history 列表，HIST_ENTRY 是一个结构体类型，存储了很多信息：&emsp;&emsp; &emsp;&emsp;我们要的历史内容就存储在 data 元素里面。 &emsp;&emsp;这个函数返回一个数组，以空指针为结束标志，我们简单封装一下就可以实现一个自己 shell 内置的 history 函数了。 1234567891011void ShowHistory()&#123; int i = 0; HIST_ENTRY ** his; his = history_list(); while(his[i] != NULL) &#123; printf(\"%s\\n\", his[i]-&gt;line); i++; &#125;&#125; &emsp;&emsp;history.h 里面提供了很多函数，我们的要实现一个简单的shell用到的函数上面都提到过，更多的函数可以在官方文档里面查看。 &emsp;&emsp;realine 这个库很强大，现在只是发现了他的冰山一角，提供的功能远远超过上述所说的。","categories":[{"name":"Linux C","slug":"Linux-C","permalink":"https://phoenixxc.github.io/categories/Linux-C/"}],"tags":[{"name":"readline","slug":"readline","permalink":"https://phoenixxc.github.io/tags/readline/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-22T01:39:00.000Z","updated":"2019-02-26T09:42:30.000Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"https://phoenixxc.github.io/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}