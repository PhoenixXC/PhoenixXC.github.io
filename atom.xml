<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pxBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://phoenixxc.github.io/"/>
  <updated>2019-07-22T12:41:48.464Z</updated>
  <id>https://phoenixxc.github.io/</id>
  
  <author>
    <name>PhoenixBM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot之Web开发</title>
    <link href="https://phoenixxc.github.io/posts/d16715c9/"/>
    <id>https://phoenixxc.github.io/posts/d16715c9/</id>
    <published>2019-07-21T14:58:19.000Z</published>
    <updated>2019-07-22T12:41:48.464Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><p>使用 SpringBoot：</p><ol><li><p>创建 SpringBoot 应用，选中需要的模块</p></li><li><p>SpringBoot 默认将这些场景自动配置好，只需要在配置文件中指定少量配置</p></li><li><p>自己编写业务逻辑代码</p></li></ol><h2 id="SpringBoot-对静态资源的映射规则"><a href="#SpringBoot-对静态资源的映射规则" class="headerlink" title="SpringBoot 对静态资源的映射规则"></a>SpringBoot 对静态资源的映射规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/springframework/boot/autoconfigure/web/ResourceProperties.java</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以设置与静态资源有关的设置，例如缓冲时间等</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">    CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">                                             .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">    String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                                             .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置首页</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(<span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext),</span><br><span class="line">                                         applicationContext, getWelcomePage(), <span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置喜欢的图标</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">        mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">// 在静态文件夹中寻找</span></span><br><span class="line">        mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>, faviconRequestHandler()));</span><br><span class="line">        <span class="keyword">return</span> mapping;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">        requestHandler.setLocations(resolveFaviconLocations());</span><br><span class="line">        <span class="keyword">return</span> requestHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Resource&gt; <span class="title">resolveFaviconLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] staticLocations = getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">        List&lt;Resource&gt; locations = <span class="keyword">new</span> ArrayList&lt;&gt;(staticLocations.length + <span class="number">1</span>);</span><br><span class="line">        Arrays.stream(staticLocations).map(<span class="keyword">this</span>.resourceLoader::getResource).forEach(locations::add);</span><br><span class="line">        locations.add(<span class="keyword">new</span> ClassPathResource(<span class="string">"/"</span>));</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(locations);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>所有 /webjars/**，都去 classpath:/META-INF/resources/webjars/ 找资源；</p><p><a href="https://www.webjars.org/" target="_blank" rel="noopener">webjars</a>：以 jar 包的方式引入静态资源；</p><p>在 <strong><em>webjars</em></strong> 这个网站上可以使用 maven 导入常用 js 库的 webjar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190721132241.png" alt></p><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190721131900.png" alt></p></li><li><p>“/**” 访问当前项目的任何资源，对应</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public/</li><li>/：当前项目根路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">"classpath:/META-INF/resources/"</span>,</span><br><span class="line">                                                                  <span class="string">"classpath:/resources/"</span>, <span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Locations of static resources. Defaults to classpath:[/META-INF/resources/,</span></span><br><span class="line"><span class="comment"> * /resources/, /static/, /public/].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br></pre></td></tr></table></figure></li><li><p>欢迎页面的映射</p></li><li><p>页面图标映射（可能需要清除浏览器缓存 - <a href="https://chrome.google.com/webstore/detail/classic-cache-killer/kkmknnnjliniefekpicbaaobdnjjikfp" target="_blank" rel="noopener">Chrome 插件</a>或者 <kbd>Shift+F5</kbd>）</p><p>需要放在映射路径的根目录下才可以。</p></li></ol><blockquote><p>By default, resources are mapped on <code>/**</code>, but you can tune that with the <code>spring.mvc.static-path-pattern</code> property. For instance, relocating all resources to <code>/resources/**</code> can be achieved as follows:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.static-path-pattern=/resources/**</span><br></pre></td></tr></table></figure><blockquote><p>You can also customize the static resource locations by using the <code>spring.resources.static-locations</code> property (replacing the default values with a list of directory locations). The root Servlet context path, <code>&quot;/&quot;</code>, is automatically added as a location as well.</p><p>In addition to the “standard” static resource locations mentioned earlier, a special case is made for <a href="https://www.webjars.org/" target="_blank" rel="noopener">Webjars content</a>. Any resources with a path in<code>/webjars/**</code> are served from jar files if they are packaged in the Webjars format.</p><table><thead><tr><th><img src="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/images/tip.png" alt="[Tip]"></th></tr></thead><tbody><tr><td>Do not use the <code>src/main/webapp</code> directory if your application is packaged as a jar. Although this directory is a common standard, it works <strong>only</strong> with war packaging, and it is silently ignored by most build tools if you generate a jar.</td></tr></tbody></table></blockquote><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>Jsp、Thymeleaf、Velocity、Freemarker …</p><p>SpringBoot 如果以 jar 的形式打包，而且由于 SpringBoot 使用的是内嵌的 Tomcat ，所以 SpringBoot 推荐使用 <strong><em>Thymeleaf</em></strong>.</p><h3 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h3><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Thymeleaf-语法"><a href="#Thymeleaf-语法" class="headerlink" title="Thymeleaf 语法"></a>Thymeleaf 语法</h3><p>自动配置的默认规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br></pre></td></tr></table></figure><p>只要把 html 放在 classpath:/templates/ 后，Thymeleaf 就会自动渲染。</p><p>使用：</p><ol><li><p>导入 thymeleaf 名称空间：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>SUCCESS<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将 div 的内容设置为... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这是显示欢迎数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><ul><li><p><code>th:text</code> 改变当前元素里面的文本内容</p><p><code>th:</code> 任意 html 属性，来替换原生属性的值</p><p>对应的行内写法：</p><ul><li><code>th:text</code> =&gt; <code>[[]]</code></li><li><code>th:utext</code> =&gt; <code>[()]</code></li></ul><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190721160559.png" alt></p></li></ul><ul><li><p>表达式</p><p><strong>Simple expressions:</strong>（表达式语法）</p><ul><li><p>Variable Expressions: <code>${...}</code></p><ul><li><p>获取对象的属性，调用方法</p></li><li><p>使用内置的基本对象</p><ul><li>#ctx : the context object.</li><li>#vars: the context variables.</li><li>#locale : the context locale.</li><li>#request : (only in Web Contexts) the HttpServletRequest object.</li><li>#response : (only in Web Contexts) the HttpServletResponse object.</li><li>#session : (only in Web Contexts) the HttpSession object.</li><li>#servletContext : (only in Web Contexts) the ServletContext object.</li></ul></li><li><p>使用内置的工具对象</p><ul><li>#execInfo : information about the template being processed.</li><li>#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.</li><li>#uris : methods for escaping parts of URLs/URIs</li><li>#conversions : methods for executing the configured conversion service (if any).</li><li>#dates : methods for java.util.Date objects: formatting, component extraction, etc.</li><li>#calendars : analogous to #dates , but for java.util.Calendar objects.</li><li>#numbers : methods for formatting numeric objects.</li><li>#strings : methods for String objects: contains, startsWith, prepending/appending, etc.</li><li>#objects : methods for objects in general.</li><li>#bools : methods for boolean evaluation.</li><li>#arrays : methods for arrays.</li><li>#lists : methods for lists.</li><li>#sets : methods for sets.</li><li>#maps : methods for maps.</li><li>#aggregates : methods for creating aggregates on arrays or collections.</li><li>#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</li></ul></li></ul></li></ul></li></ul><ul><li><p>Selection Variable Expressions:</p><p><code>*{...}</code>（选择表达式）和<code>#{}</code> 功能相同，补充使用：配置 <code>th:object</code> 使用，可以直接引用 <code>th:object</code> 的属性</p></li><li><p>Message Expressions: <code>#{...}</code></p><p>获取国际化内容</p></li><li><p>Link URL Expressions: <code>@{...}</code></p><p>定义 url，里面可以使用变量等值</p></li><li><p>Fragment Expressions: <code>~{...}</code></p><p>片段引用表达式</p></li></ul><p><strong>Literals</strong>（字面量）</p><ul><li><p>Text literals: ‘one text’ , ‘Another one!’ ,…</p></li><li><p>Number literals: 0 , 34 , 3.0 , 12.3 ,…</p></li><li><p>Boolean literals: true , false</p></li><li><p>Null literal: null</p></li><li><p>Literal tokens: one , sometext , main ,…</p></li></ul><p><strong>Text operations:</strong>（文本操作）</p><ul><li><p>String concatenation: +</p></li><li><p>Literal substitutions: |The name is ${name}|</p></li></ul><p><strong>Arithmetic operations:</strong>（数学运算）</p><ul><li><p>Binary operators: + , - , * , / , %</p></li><li><p>Minus sign (unary operator): -</p></li></ul><p><strong>Boolean operations:</strong>（布尔运算）</p><ul><li><p>Binary operators: and , or</p></li><li><p>Boolean negation (unary operator): ! , not</p></li></ul><p><strong>Comparisons and equality:</strong>（比较运算）</p><ul><li><p>Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</p></li><li><p>Equality operators: == , != ( eq , ne )</p></li></ul><p><strong>Conditional operators:</strong>（条件运算）</p><ul><li><p>If-then: (if) ? (then)</p></li><li><p>If-then-else: (if) ? (then) : (else)</p></li><li><p>Default: (value) ?: (defaultvalue)</p></li></ul><p><strong>Special tokens:</strong></p><ul><li>Page 17 of 104</li><li>No-Operation: _</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;使用 SpringBoot：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;创建 SpringBoot 应用，选中需要的模块&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Spring
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/categories/SpringBoot/"/>
    
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之日志</title>
    <link href="https://phoenixxc.github.io/posts/18e9d6ab/"/>
    <id>https://phoenixxc.github.io/posts/18e9d6ab/</id>
    <published>2019-07-21T14:57:13.000Z</published>
    <updated>2019-07-22T12:12:34.535Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><p>日志门面：日志的一个抽象层</p><p>市面上的日志框架：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…<em>**</em></p><table><thead><tr><th>日志门面</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（久不更新）</del>、SLF4j、<del>jboss-logging（不适用于普通人群）</del></td><td>Log4j、JUL（Java 自带）、log4j2（框架好但是有些尚未适配）、Logback（与Log4j是同一个作者）</td></tr></tbody></table><p>左边选一个门面（抽象层），右边选一个实现；</p><p><strong>SpringBoot</strong> ：底层为 Spring框架默认选择 JCL、而 SpringBoot 选择 SLF4j、logback</p><h2 id="SLF4j-的使用"><a href="#SLF4j-的使用" class="headerlink" title="SLF4j 的使用"></a>SLF4j 的使用</h2><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在开发时，不应直接调用日志的实现类，而是应该调用日志的抽象层的方法。</p><p>导入 SLF4j 的 jar 和 logback 的 jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190720143617.png" alt></p><p>每一个日志的实现框架都有自己的配置文件，使用 SLF4j后，<strong>配置还是做成日志实现框架的自己的配置文件</strong>。</p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>A（SLF4j + logback）：Spring 、Hibernate、MyBatis、….. A 系统的依赖使用了其他的日志框架</p><p>统一日志记录，即使是别的框架也统一使用 SLF4j 输出</p><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190720144123.png" alt></p><p><strong>如何让系统中所有的日志都统一到slf4j：</strong></p><ol><li>将系统中其他日志框架先排除出去</li><li>用中间包来替换原有的日志框架</li><li>导入 slf4j 其他的实现</li></ol><h3 id="SpringBoot-与日志的关系"><a href="#SpringBoot-与日志的关系" class="headerlink" title="SpringBoot 与日志的关系"></a>SpringBoot 与日志的关系</h3><p>SpringBoot 使用日志功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>底层依赖关系：</p><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190720145802.png" alt></p><p>总结：</p><ol><li>SpringBoot 底层也是使用 slf4j + logback 的方式进行日志记录的</li><li>SpringBoot 把其他的日志都替换为了 slf4j</li></ol><p>Maven 排除 jar 包的方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectB<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  <span class="comment">&lt;!-- declare the exclusion here --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectC<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在 idea 的 maven 依赖树里面选中不需要的依赖，右键选择 删除</p><h2 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h2><p><a href="https://segmentfault.com/a/1190000004693427" target="_blank" rel="noopener">LogBack入门实践</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录器</span></span><br><span class="line">   <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 日志的级别，由低到高 -------------------</span></span><br><span class="line">       <span class="comment">// 可以调整输出的日志的级别；日志就只会在这个级别的以后的高级别生效</span></span><br><span class="line">       <span class="comment">// 跟踪轨迹</span></span><br><span class="line">       logger.trace(<span class="string">"这是 trace 日志..."</span>);</span><br><span class="line">       <span class="comment">// 调试信息</span></span><br><span class="line">       logger.debug(<span class="string">"这是 debug 日志..."</span>);</span><br><span class="line">       <span class="comment">// SpringBoot 默认只会输出 info 级别：root 级别</span></span><br><span class="line">       <span class="comment">// info</span></span><br><span class="line">       logger.info(<span class="string">"这是 info 日志..."</span>);</span><br><span class="line">       <span class="comment">// warning</span></span><br><span class="line">       logger.warn(<span class="string">"这是 warning 日志..."</span>);</span><br><span class="line">       <span class="comment">// error</span></span><br><span class="line">       logger.error(<span class="string">"这是 error 日志..."</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logging.level.com.xuanc=trace</span><br><span class="line"># =========== logging.path 与 logging.file 冲突 ===========</span><br><span class="line"># 指定目录，创建路径的文件夹，日志输出文件名默认使用 spring.log</span><br><span class="line">logging.path=/tmp/spring/log</span><br><span class="line"># 如果不指定路径则在当前项目下生成日志，也可以指定路径</span><br><span class="line">#logging.file=springboot.log</span><br><span class="line"></span><br><span class="line"># 在控制台输出的日志的格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line"># 指定文件中输出的日志的格式</span><br><span class="line">#logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br></pre></td></tr></table></figure><p>日志输出格式：</p><ul><li><code>%d</code> 表示时间日期</li><li><code>%thread</code> 表示线程名</li><li><code>%-5level</code>级别从左显示5个字符宽度</li><li><code>%logger{50}</code> 表示 logger 名字最长为50个字符，否则按照据点分隔</li><li><code>%msg</code> 日志消息</li><li><code>%n</code> 换行符</li></ul><p>具体的可以在 SpringBoot 的 logging 下面的文件中查看：</p><p><img src="../../../IdeaProjects/SpringBoot-ShangGuiG/images/1563610047818.png" alt="1563610047818"></p><p>也可以<a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/content/IV.%20Spring%20Boot%20features/26.5.%20Custom%20log%20configuration.html" target="_blank" rel="noopener">自定义日志配置</a>，在类路径下放上每个日志框架自己的配置文件后，SpringBoot 就不使用默认的配置了。</p><p>以下文件会根据你选择的日志系统进行加载：</p><table><thead><tr><th>日志系统</th><th style="text-align:center">定制配置</th></tr></thead><tbody><tr><td>Logback</td><td style="text-align:center"><code>logback-spring.xml</code>,<code>logback-spring.groovy</code>,<code>logback.xml</code>或<code>logback.groovy</code></td></tr><tr><td>Log4j</td><td style="text-align:center"><code>log4j.properties</code>或<code>log4j.xml</code></td></tr><tr><td>Log4j2</td><td style="text-align:center"><code>log4j2-spring.xml</code>或<code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td style="text-align:center"><code>logging.properties</code></td></tr></tbody></table><p><strong>注</strong> 如果可能的话，建议你使用<code>-spring</code>变种形式定义日志配置（例如，使用<code>logback-spring.xml</code>（由 SpringBoot 完全控制）而不是<code>logback.xml</code>（日志框架会读取，跳过 SpringBoot））。如果你使用标准的配置路径，Spring可能不能够完全控制日志初始化。</p><p>使用 <code>-spring</code> 还有一个优点：由 SpringBoot 来解析日志配置，可以使用 SpringBoot 的高级 <strong><em>Profile</em></strong> 功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;springProfile&gt;</code>标签可用于根据激活的Spring profiles，选择性的包含或排除配置片段。Profile片段可以放在<code>&lt;configuration&gt;</code>元素内的任何地方，使用<code>name</code>属性定义哪些profile接受该配置，多个profiles以逗号分隔。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">&gt;  <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev, staging"</span>&gt;</span></span><br><span class="line">&gt;  <span class="comment">&lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!production"</span>&gt;</span></span><br><span class="line">&gt;  <span class="comment">&lt;!-- configuration to be enabled when the "production" profile is not active --&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h2><p>按照 SLF4j 的日志适配图，进行响应的转换。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;日志框架&quot;&gt;&lt;a href=&quot;#日志框架&quot; class=&quot;headerlink&quot; title=&quot;日志框架&quot;&gt;&lt;/a&gt;日志框架&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/categories/SpringBoot/"/>
    
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之属性配置</title>
    <link href="https://phoenixxc.github.io/posts/a29f8391/"/>
    <id>https://phoenixxc.github.io/posts/a29f8391/</id>
    <published>2019-07-21T14:55:00.000Z</published>
    <updated>2019-07-22T12:12:12.018Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SpringBoot 使用一个全局的配置文件：</p><ul><li>application.properties</li><li>application.yml</li></ul><p>配置文件的作用：修改 SpringBoot 自动配置的默认值。</p><p>以前的配置文件：使用的大多是 xml 文件。</p><p>yml 是YAML（YAML Ain’t Markup Language）语言的文件，<u>以数据为中心</u>，更适合做配置文件</p><h2 id="YAML-语法"><a href="#YAML-语法" class="headerlink" title="YAML 语法"></a>YAML 语法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>key: value ==&gt; 表示一对键值对（空格不能省略），且对大小写敏感。</p><p>以空格的缩进来控制层级关系；只要是左对齐的一列数据都是同一层级的数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/hello</span></span><br><span class="line"><span class="comment"># 这是注释..</span></span><br></pre></td></tr></table></figure><h3 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h3><ul><li><p><strong>字面量：普通的值（数字、字符串、布尔）</strong></p><p>字面量直接写，字符串默认不用加上单引号或者双引号；</p><p>“”: 不会转义字符串的特殊字符，特殊字符作为本身要表示的意思</p><p>‘’：会转义特殊字符，特殊字符只是一个普通的字符串数据</p></li><li><p><strong>对象、Map（属性和值）</strong></p><p>Key: Value 对象还是键值对的形式，在下一行写对象的KV，但需要注意缩进</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangshan,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>数组（List、Set）</strong></p><p>用 <code>- 值</code> 表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,</span> <span class="string">dog,</span> <span class="string">pig]</span></span><br></pre></td></tr></table></figure></li></ul><p>上面三种格式可以互相嵌套。</p><h2 id="获取配置文件值"><a href="#获取配置文件值" class="headerlink" title="获取配置文件值"></a>获取配置文件值</h2><h3 id="一、使用-ConfigurationProperties"><a href="#一、使用-ConfigurationProperties" class="headerlink" title="一、使用 @ConfigurationProperties"></a>一、使用 @ConfigurationProperties</h3><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="comment"># 驼峰命名可以转化为横杠：last-name</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">  maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,</span> <span class="attr">k2:</span> <span class="string">v2&#125;</span></span><br><span class="line"><span class="attr">  lists:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">zhaoliu</span></span><br><span class="line"><span class="attr">  dog:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">小狗</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>Java Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>还需要导入配置文件处理器，在 pom.xml 中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样，在 properties文件中也可以配置，但是在里面输入<strong>中文会出现乱码</strong>（Spring Boot 是以 iso-8859 的编码方式读取 application.properties 配置文件）。</p><p>解决方法：</p><blockquote><ol><li>在 .properties 中加入:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; spring.http.encoding.force=true</span><br><span class="line">&gt; spring.http.encoding.charset=UTF-8</span><br><span class="line">&gt; spring.http.encoding.enabled=true</span><br><span class="line">&gt; server.tomcat.uri-encoding=UTF-8</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="2"><li>将 IDEA 设置中的 File Encodings 的 Transparent native-to-ascii conversion 打钩。</li></ol></blockquote><p><strong>属性名匹配规则</strong>：</p><ul><li>person.firstName：使用标准方式</li><li>person.first-name：大写用 -</li><li>person.first_name：大写用_</li><li>PERSON_FIRST_NAME：<ul><li>推荐系统属性使用这种写法</li></ul></li></ul><h3 id="二、使用-Value"><a href="#二、使用-Value" class="headerlink" title="二、使用 @Value"></a>二、使用 @Value</h3><p>使用 Spring 底层注解 <code>@Value</code> 来实现，获取配置文件或环境变量的值，或使用 SpEL</p><h3 id="ConfigurationProperties-和-Value-区别"><a href="#ConfigurationProperties-和-Value-区别" class="headerlink" title="@ConfigurationProperties 和 @Value 区别"></a><code>@ConfigurationProperties</code> 和 <code>@Value</code> 区别</h3><table><thead><tr><th>Feature</th><th><code>@ConfigurationProperties</code></th><th><code>@Value</code></th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（属性名匹配规则）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持（注入时校验数据）</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持（只支持基本类型）</td></tr></tbody></table><p>数据校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br></pre></td></tr></table></figure><p>这样，如果 lastName 不是一个有效的 email 的话会抛出异常。</p><h3 id="加载指定的配置文件"><a href="#加载指定的配置文件" class="headerlink" title="加载指定的配置文件"></a>加载指定的配置文件</h3><p>使用 <code>@PropertySource</code> 和 <code>@ImportResource</code> 可以记载指定的配置文件。</p><p>使用 <code>@ConfigurationProperties</code> 默认是从全局配置文件中获取值。</p><p><strong><code>@PropertySource</code></strong>： 加载指定的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">// @Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><strong><code>@ImportResource</code></strong>：导入 Spring 的配置文件，让配置文件里面的内容生效</p><p>SpringBoot 里面没有 Spring 的配置文件，自己编写的配置文件也不能自动识别，想让 Spring 的配置文件生效，加载进来，需要把 <code>@ImportResource</code> 标注在配置类上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBoot02ConfigApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>SpringBoot 推荐的给容器添加组件的方式：</p><ol><li><p>编写配置类</p></li><li><p>使用 <code>@Bean</code> 给容器中添加组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 的 id 与方法名相同</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><ul><li><p>RandomValuePropertySource：配置文件中可以使用随机数</p><p><code>${random.value}、${random.int}、${random.long}、${random.int(10)、${random.int[1024,65536]}</code></p></li><li><p>属性配置占位符</p><p>可以在配置文件中引用前面配置过的属性（优先级前面配置过得这里都能用）</p><p><code>${app.name: 默认值}</code>来指定找不到属性的默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#person.last-name=张三$&#123;random.uuid&#125;</span><br><span class="line">person.age=$&#123;random.int&#125;</span><br><span class="line">person.birth=2017/12/12</span><br><span class="line">person.boss=false</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=14</span><br><span class="line">person.lists=a,b,c,d</span><br><span class="line">person.dog.name=$&#123;person.last-name&#125;_dog</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure><p>如果属性不存在，则会将占位符当做字符串处理</p></li></ul><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>Profile 是 Spring 对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境</p><h3 id="多-profile-文件形式"><a href="#多-profile-文件形式" class="headerlink" title="多 profile 文件形式"></a>多 profile 文件形式</h3><p>格式：<code>application-{profile}.properties</code></p><p>默认使用 application.properties 配置文件。</p><h3 id="YAML-文档块模式"><a href="#YAML-文档块模式" class="headerlink" title="YAML 文档块模式"></a>YAML 文档块模式</h3><p>YAML 中如果使用 <code>---</code> 可以将文件划分为不同的文档块，多个 profile 可以写在同一个文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Document1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">  maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,</span> <span class="attr">k2:</span> <span class="string">v2&#125;</span></span><br><span class="line"><span class="attr">  lists:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">zhaoliu</span></span><br><span class="line"><span class="attr">  dog:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">小狗</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev</span> <span class="comment"># 指定激活哪一个 profile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Document2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span> <span class="comment"># 指定文档块属于哪个 profile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Document3</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8022</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure><h3 id="使用其他环境的配置文件的方式："><a href="#使用其他环境的配置文件的方式：" class="headerlink" title="使用其他环境的配置文件的方式："></a>使用其他环境的配置文件的方式：</h3><ul><li><p>application.properties 或 application.yml 指定</p><blockquote><p>YAML 的优先级比 .properties 要低</p></blockquote><p><code>spring.profiles.active={profile}</code></p><p>`spring:<br>profiles:</p><pre><code>active: {profile}`</code></pre></li><li><p>命令行方式（优先级较高）：</p><p>idea 的 <em>program arguments</em> 设置 <code>-- spring.profiles.active={profile}</code></p><p>maven 打包后，在命令行执行并加上参数</p></li><li><p>虚拟机参数</p><p>idea 的 <em>VM options</em>: <code>-Dspring.profiles.active={profile}</code></p></li></ul><h2 id="配置文件的加载位置"><a href="#配置文件的加载位置" class="headerlink" title="配置文件的加载位置"></a>配置文件的加载位置</h2><p>SpringBoot 启动会扫描以下位置的 application.properties或者 application.yml 文件作为 SpringBoot 的默认配置文件：（Idea 中类路径即 <em>classpath:</em>对应 <strong>resources</strong> 目录）</p><ul><li>file:/config/</li><li>file:/</li><li>classpath:/config</li><li>classpath:/</li></ul><p>以上按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置的内容会覆盖低优先级配置的内容，也可以通过配置 <code>spring.config.location</code> 来改变默认内容。</p><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190720084452.png" alt></p><p>SpringBoot 会加载上述的所有文件，只是如果配置冲突，高优先级的配置文件中的设置会覆盖低优先级配置文件的设置，低优先级的其他配置依然会生效。</p><p>例如在上述四个配置文件中分别定义不同的端口号，在 /resource/application.properties 文件中定义项目的访问路径，那么运行后低优先级配置的项目访问路径仍然有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br><span class="line"></span><br><span class="line"># 配置项目的访问路径</span><br><span class="line">server.servlet.context-path=/springboot-demo</span><br><span class="line"># 新版本的配置改为：server.servlet.context-path，而不是　server.context-path</span><br></pre></td></tr></table></figure><p><img src="../../../IdeaProjects/SpringBoot-ShangGuiG/images/1563584399179.png" alt="1563584399179"></p><h3 id="指定配置文件路径"><a href="#指定配置文件路径" class="headerlink" title="指定配置文件路径"></a>指定配置文件路径</h3><p>项目打包好后，可以使用<strong>命令行参数</strong>的形式，在启动项目时指定配置文件的新位置，指定的配置文件和默认加载的配置文件会共同启动作用，形成互补配置。</p><p>直接在上述的四个配置文件中指定 <code>spring.config.location</code> 并不会生效。</p><h2 id="外部配置的加载顺序"><a href="#外部配置的加载顺序" class="headerlink" title="外部配置的加载顺序"></a>外部配置的加载顺序</h2><p><a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/content/IV.%20Spring%20Boot%20features/24.%20Externalized%20Configuration.html" target="_blank" rel="noopener">官网文档中文手册</a>上提到的外部配置的加载顺序：</p><blockquote><p>Spring Boot允许将配置外部化（externalize），这样你就能够在不同的环境下使用相同的代码。你可以使用properties文件，YAML文件，环境变量和命令行参数来外部化配置。使用@Value注解，可以直接将属性值注入到beans中，然后通过Spring的<code>Environment</code>抽象或通过<code>@ConfigurationProperties</code><a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties" target="_blank" rel="noopener">绑定到结构化对象</a>来访问。</p><p>Spring Boot设计了一个非常特别的<code>PropertySource</code>顺序，以允许对属性值进行合理的覆盖，属性会以如下的顺序进行设值：（优先级从高到低，高优先级覆盖低优先级，形成互补）</p><ol><li>home目录下的<a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/reference/htmlsingle/#using-boot-devtools-globalsettings" target="_blank" rel="noopener">devtools全局设置属性</a>（<code>~/.spring-boot-devtools.properties</code>，如果devtools激活）。</li><li>测试用例上的<a href="http://docs.spring.io/spring/docs/4.3.3.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html" target="_blank" rel="noopener">@TestPropertySource</a>注解。</li><li>测试用例上的<a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/api/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTest.html" target="_blank" rel="noopener">@SpringBootTest#properties</a>注解。</li><li><strong>命令行参数</strong>（多个参数可以用空格分隔开）</li><li>来自<code>SPRING_APPLICATION_JSON</code>的属性（环境变量或系统属性中内嵌的内联JSON）。</li><li><code>ServletConfig</code>初始化参数。</li><li><code>ServletContext</code>初始化参数。</li><li><strong>来自于<code>java:comp/env</code>的JNDI属性。</strong></li><li><strong>Java系统属性（System.getProperties()）。</strong></li><li><strong>操作系统环境变量。</strong></li><li><strong>RandomValuePropertySource，只包含<code>random.</code>中的属性。</strong></li><li><strong>没有打进jar包的<a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/reference/htmlsingle/#boot-features-external-config-profile-specific-properties" target="_blank" rel="noopener">Profile-specific应用属性</a>（<code>application-{profile}.properties</code>和YAML变量）。</strong></li><li><strong>打进jar包中的<a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/reference/htmlsingle/#boot-features-external-config-profile-specific-properties" target="_blank" rel="noopener">Profile-specific应用属性</a>（<code>application-{profile}.properties</code>和YAML变量）。</strong></li><li><strong>没有打进jar包的应用配置（<code>application.properties</code>和YAML变量）。</strong></li><li><strong>打进jar包中的应用配置（<code>application.properties</code>和YAML变量）。</strong></li><li><strong><code>@Configuration</code>类上的<a href="http://docs.spring.io/spring/docs/4.3.3.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html" target="_blank" rel="noopener"><code>@PropertySource</code>注解</a>。</strong></li><li><strong>默认属性（使用<code>SpringApplication.setDefaultProperties</code>指定）。</strong></li></ol></blockquote><h2 id="自动配置的原理"><a href="#自动配置的原理" class="headerlink" title="自动配置的原理"></a>自动配置的原理</h2><p>配置文件可配置属性的范围：</p><ul><li><a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/content/X.%20Appendices/A.%20Common%20application%20properties.html" target="_blank" rel="noopener">官方文档</a></li></ul><p>自动配置原理：</p><ol><li><p>SpringBoot 启动时，加载主配置类，开启了自动配置功能 <code>@EnableAutoConfiguration</code></p></li><li><p><code>@EnableAutoConfiguration</code> 作用</p><p>利用 <code>AutoConfigurationImportSelector.class</code> 给容器中导入组件，里面的 <code>public String[] selectImports(AnnotationMetadata annotationMetadata) { ... }</code> 方法中，</p><p>调用了 <code>protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {...}</code> 方法，这里面有一句代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br></pre></td></tr></table></figure><p>通过这行代码来获取候选的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">        <span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">        <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的 <code>loadFactoryNames</code> 方法的源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描所有jar包类路径下的 META-INF/spring.factories 文件</span></span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">                                 classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :                        ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取 url 后对每个 url 进行遍历</span></span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            <span class="comment">// 把扫描到的文件内容包装为 properties 对象</span></span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = </span><br><span class="line">                PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 从 properties 对象中获取全类名</span></span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                <span class="keyword">for</span> (String factoryName : </span><br><span class="line">                     StringUtils.</span><br><span class="line">                     commaDelimitedListToStringArray((String) </span><br><span class="line">                                                     entry.getValue())) &#123;</span><br><span class="line">                    <span class="comment">// 添加</span></span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> </span><br><span class="line">            IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +　FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 EnableAutoConfiguration.class 类</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>所以总的来说，是将 META-INF/spring.factories 里面的所有 EnableAutoConfiguration 的值加入到容器中。使用这些类来做自动配置：</p><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190720100554.png" alt></p><ol start="3"><li><p>每一个自动配置类进行自动配置功能</p></li><li><p>以 <code>HttpEncodingAutoConfiguration</code> 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 表示这是一个配置类</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpProperties.class)</span><br><span class="line"><span class="comment">// 启用指定类的 ConfigurationProperties 功能，将配置文件中对应的值与这个properties类绑定在一起，并把 HttpProperties 加入到 Ioc 容器中</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="comment">// Spring 底层注解，根据不同的条件决定配置是否生效；</span></span><br><span class="line"><span class="comment">// 判断当前应用是否为 web 应用，如果是则生效</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter.class)</span><br><span class="line"><span class="comment">// 判断当前项目有没有这个类(Spring MVC 解决乱码中的过滤器)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="comment">// 判断在配置文件中是否启用，如果配置这个属性，也生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已近与 SpringBoot 的配置文件映射了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpProperties.Encoding properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个有参构造器的情况下，参数的值会从容器中获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties.getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器中添加组件，有些值需要从 properties 中获取</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 容器中没有这个组件时候才会执行</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> </span><br><span class="line">            OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(</span><br><span class="line">            <span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(</span><br><span class="line">            <span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断。决定配置类是否生效，一旦配置类生效，这个配置类就会在容器中添加各种组件，这些组件的属性是从对应的 propertie 类中获取的，而这些类的每一个属性又是和配置文件绑定的。</p></li><li><p>所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装着；<strong>配置文件能配置什么就可以参照某个功能对应的这个属性类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http"</span>)</span><br><span class="line"><span class="comment">// 从配置文件中获取指定的值和 bean 的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure></li></ol><p>SpingBoot 的精髓：</p><ol><li>SpringBoot 启动会加载大量的自动配置类</li><li>我们需要的功能有没有 SpringBoot 默认写好的自动配置类</li><li>在看这个自动配置类到底配置了哪些组件，如果有，就不需要自动配置了</li><li>给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性，可以在配置文件中指定属性的值</li></ol><h3 id="Conditional-扩展注解"><a href="#Conditional-扩展注解" class="headerlink" title="@Conditional 扩展注解"></a><code>@Conditional</code> 扩展注解</h3><table><thead><tr><th style="text-align:left">@Conditional扩展注解</th><th style="text-align:left">作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td style="text-align:left">@ConditionalOnJava</td><td style="text-align:left">系统的java版本是否符合要求</td></tr><tr><td style="text-align:left">@ConditionalOnBean</td><td style="text-align:left">容器中存在指定Bean；</td></tr><tr><td style="text-align:left">@ConditionalOnMissingBean</td><td style="text-align:left">容器中不存在指定Bean；</td></tr><tr><td style="text-align:left">@ConditionalOnExpression</td><td style="text-align:left">满足SpEL表达式指定</td></tr><tr><td style="text-align:left">@ConditionalOnClass</td><td style="text-align:left">系统中有指定的类</td></tr><tr><td style="text-align:left">@ConditionalOnMissingClass</td><td style="text-align:left">系统中没有指定的类</td></tr><tr><td style="text-align:left">@ConditionalOnSingleCandidate</td><td style="text-align:left">容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td style="text-align:left">@ConditionalOnProperty</td><td style="text-align:left">系统中指定的属性是否有指定的值</td></tr><tr><td style="text-align:left">@ConditionalOnResource</td><td style="text-align:left">类路径下是否存在指定资源文件</td></tr><tr><td style="text-align:left">@ConditionalOnWebApplication</td><td style="text-align:left">当前是web环境</td></tr><tr><td style="text-align:left">@ConditionalOnNotWebApplication</td><td style="text-align:left">当前不是web环境</td></tr><tr><td style="text-align:left">@ConditionalOnJndi</td><td style="text-align:left">JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>查看哪些配置类自动生效：</p><p>通过启用 debug 属性来打印自动配置报告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开启 SpringBoot 的 debug 模式</span><br><span class="line">debug=true</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190720112722.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;配置文件&quot;&gt;&lt;a href=&quot;#配置文件&quot; class=&quot;headerlink&quot; title=&quot;配置文件&quot;&gt;&lt;/a&gt;配置文件&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/categories/SpringBoot/"/>
    
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之环境配置</title>
    <link href="https://phoenixxc.github.io/posts/cb2b0fb3/"/>
    <id>https://phoenixxc.github.io/posts/cb2b0fb3/</id>
    <published>2019-07-21T14:51:45.000Z</published>
    <updated>2019-07-22T12:12:51.369Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h2 id="将-SpringBoot-项目打包为-Jar-包"><a href="#将-SpringBoot-项目打包为-Jar-包" class="headerlink" title="将 SpringBoot 项目打包为 Jar 包"></a>将 SpringBoot 项目打包为 Jar 包</h2><p>maven <code>pom.xml</code> 中加入如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插件作用：将应用打包为可执行的 jar 包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 mvn package 就可以将应用打包。</p><p>在终端里 cd 到 jar 的位置后，<code>java -jar (jar包名称或路径）</code> 就可以运行项目，而且不需要配置 tomcat 环境，因为 SpringBoot 集成了 tomcat。</p><h2 id="POM-文件解析"><a href="#POM-文件解析" class="headerlink" title="POM 文件解析"></a>POM 文件解析</h2><h4 id="父项目"><a href="#父项目" class="headerlink" title="父项目"></a>父项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父项目作用：依赖管理</p><p>这个父项目还有一个父项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个父项目才是真正管理 Spring Boot 应用里面的所有的依赖管理的，其 <code>&lt;properties&gt;</code> 属性规定了常用包的版本号。所以导入以及规定版本的包是不需要写版本号的。</p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-starter-web</code>: spring-boot 场景启动器，导入了 web 模块正常运行需要的依赖</p><p>Sping Boot 将所有的功能场景都抽取出来，做成一个 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">starters</a>，只需要在项目里面引入这些 starter 相关的场景依赖都会自动导入进来。</p><h2 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring 应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@SpringBootApplication</code> 说明被注解标注的类是 SpringBoot 的主配置类，SpringBoot 应该运行这个类的 main 方法来启动 SpringBoot 应用。</p><p>注解部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), <span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p><code>@SpringBootConfiguration</code> : 表示被标注的类是 SpringBoot 的配置类，配置类也是容器中的一个组件</p><p><code>@EnableAutoConfiguration</code>：开启自动配置的功能</p><blockquote><p>自动配置的原理：</p><p>注解部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@AutoConfigurationPackage</span></span><br><span class="line">&gt; <span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>@AutoConfigurationPackage</code> : 自动配置包，使用 <code>@Import({Registrar.class})</code> 这个 Spring 底层注解来实现，给容器中导入一个组件。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>将主配置类 （<code>@SpringBootApplication</code> 标注的类）的<u>所在包下面的所有子包</u>里面的所有组件扫描到 Spring 容器</strong></p><hr><p><code>@Import({AutoConfigurationImportSelector.class})</code>: 给容器中导入组件</p><p>将所有需要导入的组件以全类名的方式返回，添加到容器中。会给容器中导入非常多的<strong>自动配置类</strong>（xxxAutoConfiguration），就是给容器中导入这个场景所需要的所有组件，并配置好这些组件。</p><blockquote><p><code>AutoConfigurationImportSelector</code> 类部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">&gt; &gt;  <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">&gt; &gt;      <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&gt; &gt;  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt; &gt;      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&gt; &gt;      AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">&gt; &gt;      <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&gt; &gt;  &#125;</span><br><span class="line">&gt; &gt; &#125;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>方法 <code>getAutoConfigurationEntry</code> 中的 <code>List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</code> <code>configurations</code> 数组就是容器中需要导入的组件。</p><blockquote><p><code>SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</code></p><p>从类加载器中获取资源，将资源作为 <code>properties</code> 配置文件，从中拿出工程的名字：<code>factoryClass.getName()</code>。</p><p>从类路径下的 <strong><em>META-INF/spring.factories</em></strong> 中获取 <code>EnableAutoConfiguration</code> 指定的值，将这些值作为自动配置类导入到容器中。</p><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190719105837.png" alt></p></blockquote><p><img src="https://gitee.com/PhoenixBM/FigureBed/raw/picgo/img/20190719104706.png" alt></p></blockquote></blockquote><p>有了自动配置类，就免去了手动编写而配置注入功能组件等的工作。</p><p>J2EE 的整体解决方案和自动配置都在 <strong>spring-boot-autoconfigure-xxx.RELEASE.jar</strong>;</p><h2 id="使用-Spring-Initializr-快速创建项目"><a href="#使用-Spring-Initializr-快速创建项目" class="headerlink" title="使用 Spring Initializr 快速创建项目"></a>使用 Spring Initializr 快速创建项目</h2><p>Idea 或者<a href="https://start.spring.io/" target="_blank" rel="noopener">官网</a>的 Spring Initialzr 可以快速创建项目。</p><p>默认生成的 Spring Boot 项目：</p><ul><li>主程序、测试文件生成好了</li><li>resource 文件夹的目录结构<ul><li>static: 保存所有的静态资源：js、css、images；</li><li>templates: 保存所有的模板页面；（由于使用嵌入式的 Tomcat，默认不支持 JSP）</li><li>application.properties: Spring Boot 应用的配置文件，可以修改默认设置；</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;将-SpringBoot-项目打包为-Jar-包&quot;&gt;&lt;a href=&quot;#将-SpringBoot-项目打包为-Jar-包&quot; class=&quot;h
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Servlet请求转发</title>
    <link href="https://phoenixxc.github.io/posts/e0aa16fa/"/>
    <id>https://phoenixxc.github.io/posts/e0aa16fa/</id>
    <published>2019-03-05T10:44:23.000Z</published>
    <updated>2019-07-22T12:18:05.429Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><p>在 Servlet 中请求转发的方法无非两种：</p><ul><li><p>使用 <code>RequestDispatcher</code> 来调派请求</p><ul><li><p>使用 <code>include()</code> 来将另一个 Servlet 的操作流程包括至目前的操作流程中</p></li><li><p>使用 <code>forward()</code> 方法将请求处理转发给其他的 Servlet</p></li></ul></li></ul><ul><li>使用 <code>HttpServletResponse</code> 的 <code>sendRedirect()</code> 方法要求浏览器重新请求另一个 URL</li></ul><p>如果要调用 <code>forward()</code> 和 <code>sendRedirect()</code> 方法，那么目前的 Servlet 不能有任何响应确认，否则会抛出异常。</p><p>调用 <code>forward()</code> 方法时需要传入请求与响应对象，由于传递的是同一个 request，所以在转发过程中可以使用请求范围属性来传递一些属性。但 <code>forward()</code> 转发的这个动作是在 Web 容器中进行的，浏览器不知道请求被转发，地址栏也不会发生变化，转发也限制只能转发到服务器的另一个资源。而在整个转发过程中，都还是在<strong>同一个请求周期</strong>中。</p><p>当浏览器请求 Servlet1 后，Servlet1 将请求转发给了 Servlet2，之后 Servlet2 对浏览器进行响应，全程浏览器都不知道发送的请求已被转发。这样会存在的一个问题：当我刷新页面后，不过不加以处理会导致数据被重复提交。</p><p>比如现在有如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">"UTF-8"</span> contentType=<span class="string">"text/html; UTF-8"</span> %&gt;</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"zh"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">          content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">"testServlet"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br/&gt;</span><br><span class="line">        消息&amp;emsp;&lt;input type=<span class="string">"text"</span> name=<span class="string">"message"</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"上传"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xuac;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName    ServletTest-ServletOne</span></span><br><span class="line"><span class="comment"> * Description  forward()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xuanc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 19-3-17 下午2:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/testServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletOne</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"forward() 测试 ----------------------"</span>);</span><br><span class="line">        String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String message = request.getParameter(<span class="string">"message"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Username: "</span> + username + <span class="string">"\n"</span> + <span class="string">"Message: "</span> + message);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"index.jsp"</span>).forward(request, response);</span><br><span class="line">        System.out.println(<span class="string">"after forward()......................"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交表单后在输出了表单内容。</p><p><img src="/images/1552806823414.png" alt="1552806823414"></p><p>而当刷新一次后：</p><p>浏览器会提醒重复提交表单</p><p><img src="/images/1552806904960.png" alt="1552806904960"></p><p>当确认后发现内容被重复提交：</p><p><img src="/images/1552806949391.png" alt="1552806949391"></p><p><code>sendRedirect()</code> 方法顾名思义，是重定向而非转发。可以让浏览器重新请求另一个 URL，请求的资源也可以是其他服务端的资源。与 <code>forward()</code> 不同，重定向实际上是<strong>两次请求</strong>，浏览器请求 Servlet1 时，Servlet1 将浏览器重定向到 Servlet2，然后浏览器向 Servlet2 发出请求，之后则由 Servlet2 做出响应或者其他的操作。这样的重定向浏览器是可以知道的，地址栏也会发生变化。</p><p>上面的例子中，解决刷新重复提交表单的方法之一就是使用重定向而不是转发（<code>forward()</code>）。另一种方法是使用 token，通过它来判断是否是重复提交，进而进行处理。</p><p>由于在重定向的过程中，并没有使用同一个 <code>HttpRequest</code> 对象，所以想要传递属性只能通过 Session 来处理。而且因为是两次请求，需要额外的往返行为，所以相比 <code>forward()</code> 来说重定向会慢一些。</p><p>在上面的例子中我们也可以看到，调用 <code>forward</code> 或 <code>sendRedirect</code> 不会停止执行方法中的其余代码。所以如果转发和重定向之后还有可能会执行其他语句的话应该加上 <code>return</code>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在 Servlet 中请求转发的方法无非两种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;RequestDispatcher&lt;/code&gt; 来调派
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记－疯狂Java讲义[4]</title>
    <link href="https://phoenixxc.github.io/posts/603dd0d7/"/>
    <id>https://phoenixxc.github.io/posts/603dd0d7/</id>
    <published>2019-02-27T05:23:18.000Z</published>
    <updated>2019-07-22T12:11:17.277Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h2 id="第四章-流程控制与数组"><a href="#第四章-流程控制与数组" class="headerlink" title="第四章　流程控制与数组"></a>第四章　流程控制与数组</h2><h3 id="1-流程控制"><a href="#1-流程控制" class="headerlink" title="1.流程控制"></a>1.流程控制</h3><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>&emsp;&emsp;switch 语句后面控制表达式的数据类型<u>只能是</u><code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>、枚举类型和<code>java.lang.String</code>类型。<code>switch</code>中其他类型会隐式向上转换为<code>int</code>，<code>long</code>比<code>int</code>范围大，转换可能会损失精度，Java通过<code>string</code>的<code>hash()</code>值把<code>string</code>也转换为<code>int</code>。</p><h4 id="控制循环结构"><a href="#控制循环结构" class="headerlink" title="控制循环结构"></a>控制循环结构</h4><p>&emsp;&emsp;Java没有提供<code>goto</code>语句，与C类似，也有<code>continue</code>、<code>break</code>语句。不同的是，<code>break</code>和<code>continue</code>后可以紧跟标签来使得可以结束或直接跳到外层循环。</p><p>&emsp;&emsp;标签是一个紧跟英文冒号的标识符，Java中的标签<u>只有放在循环语句前才有用</u>。</p><p><center><u>代码清单</u></center><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">              System.out.println(<span class="string">"Hello ~"</span>);</span><br><span class="line">              <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="keyword">break</span> outer;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h3><p>&emsp;&emsp;数组也是一种数据类型，属于引用类型。数组用来存储一组具有相同数据类型的元素。Java中类与类可以继承，会造成一个数组中有多个类型的假象，但归根到底元素都属于同一种类型。<u>数组一旦初始化完成后，其长度将固定不变。</u></p><p>&emsp;&emsp;数组是一种引用类型，定义一个数组后相当于只定义了一个指针，这个指针还没指向任何有效内存。所以<u>定义数组的时候不能指定数组的长度。</u></p><hr><ol><li><p>数组的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName; </span><br><span class="line">type arrayName[];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了更好的可读性，推荐使用第一种定义方式。</p></li><li><p>数组的初始化</p><p>&emsp;&emsp;初始化，即为数组的数组元素分配内存空间，并给每个数组元素赋值，数组的<u>定义和初始化可以同时</u>完成。</p><p>初始化的两种方式：</p><ul><li><p>静态初始化</p><p>初始化时显式指定数组元素的初值，长度由系统决定（指定长度会报错）。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> type[] &#123;element1, element2, ..., elementn&#125;;</span><br><span class="line"><span class="comment">// 数组的定义和静态初始化同时完成可以省略 new type[]</span></span><br><span class="line"><span class="comment">// type[] arrayName = &#123;element1, element2, ...&#125;;</span></span><br></pre></td></tr></table></figure><p>初始化时type类型以及元素的类型要与定义数组时指定的类型一致（相同或为定义时指定类型的子类），元素以逗号分隔开。</p></li><li><p>动态初始化</p><p>初始化时只指定数组的长度，系统为数组元素分配初值。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> type[length];</span><br></pre></td></tr></table></figure><p>type类型要求同上。length可以是已初始化的变量。</p><p>系统默认分配的初值为：</p><ul><li><p>整数类型：0</p></li><li><p>浮点类型：0.0</p></li><li><p>字符类型：’\u0000’</p></li><li><p>布尔类型：false</p></li><li><p>引用类型：null</p></li></ul></li></ul></li></ol><ol start="3"><li><p>数组的使用</p><ul><li><p>数组可以通过索引的方式去除数组元素或对其进行赋值</p><p>如果索引超出数组大小范围在运行时会抛出异常：<code>java.lang.ArrayIndexOutOfBoundsException: N</code>，N的值即为非法的数组索引。</p></li><li><p>数组的长度可以通过其<code>length</code>属性获得</p></li><li><p>Java5之后，Java提供了更简单的循环：<code>foreach</code>循环，可以自动遍历数组和集合的每个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type variableName : array | collection) &#123;</span><br><span class="line">    <span class="comment">// variableName 自动访问每个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>foreach</code>循环中的循环变量variableName是一个临时变量，改变他并不能改变数或集合中元素的值</p></li></ul></li><li><p>数组的实质</p><p>&emsp;&emsp;数组引用变量只是一个引用，数组元素和数组变量在内存里分开存储。而引用变量是访问真实对象的根本方式，只能通过数组的引用变量才能访问数组对象本身。</p><p>&emsp;&emsp;实际的数组对象存储在堆中，如果引用数组对象的数组引用变量是局部变量，它被存储在栈中，如果堆中的对象不在有任何变量指向它，会被JVM的垃圾回收机制回收。</p><p>&emsp;&emsp;通过对数组的重新赋值，产生数组长度可变的错觉，但实际堆中实际的数组对象并不可变。</p><p><center><u>程序清单</u></center></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayInRam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        System.out.println(<span class="string">"b 数组的长度"</span> + b.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> temp : a) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> temp : b) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        b = a;</span><br><span class="line">        System.out.println(<span class="string">"b 数组的长度"</span> + b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多维数组</p><p>&emsp;&emsp;Java支持多维数组，但从本质上来说并没有多维数组。<u>多维数组实质上其元素也是引用变量</u>。</p><p><center><u>代码清单</u></center></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimensionTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 定义一个二维数组</span></span><br><span class="line">      <span class="keyword">int</span>[][] a;</span><br><span class="line">      <span class="comment">// 初始化数组，数组a有四个元素，每一个元素都是int[]类型</span></span><br><span class="line">      a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">      <span class="comment">// Error!</span></span><br><span class="line">      <span class="comment">// a = new int[][4];</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">         System.out.println(a[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">      </span><br><span class="line">      a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">         System.out.println(a[<span class="number">0</span>][i]);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"==========="</span>);</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 初始化的多种方式</span></span><br><span class="line">      <span class="comment">// One</span></span><br><span class="line">      <span class="comment">// int[][] b = new int[][] &#123;</span></span><br><span class="line">      <span class="comment">//    new int[]&#123;1&#125;,</span></span><br><span class="line">      <span class="comment">//    new int[]&#123;1, 2&#125;, </span></span><br><span class="line">      <span class="comment">//    new int[]&#123;1, 2, 3&#125;</span></span><br><span class="line">      <span class="comment">// &#125;;</span></span><br><span class="line">      <span class="comment">// Two</span></span><br><span class="line">      <span class="keyword">int</span>[][] b = &#123;</span><br><span class="line">         &#123;<span class="number">1</span>&#125;,</span><br><span class="line">         <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>],</span><br><span class="line">         <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// foreach()</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] tempArray : b) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> tempValue : tempArray) &#123;</span><br><span class="line">            System.out.println(tempValue);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"==========="</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Error!      </span></span><br><span class="line">      <span class="comment">// int[][] c = new int[2][] &#123;</span></span><br><span class="line">      <span class="comment">//    1, 2, 3, 4, 5, 6</span></span><br><span class="line">      <span class="comment">// &#125;;</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Arrays类</p><p>&emsp;&emsp;Java中Arrays类中的一些static方法可以直接操作数组，使用这些方法需要导入java.util.Arrays类(<code>import java.util.Arrays</code>)，static方法可以直接通过类名调用。</p><ul><li><p>int binarySearch(type[] a, type key)</p><p>使用二分法在数组a中查询值为key的元素，返回其索引，查找失败返回负数。要求数组为升序排列。</p></li><li><p>int binarySearch(type[] a, int fromIndex, int toIndex, type key)</p><p>与上一个类似，只是限定查找索引范围为fromIndex到toIndex。</p></li><li><p>type[] copyOf(type[] original, int length)</p><p>将original复制为一个新的数组，新数组长为length，如果length大于原数组的长度，后面元素补充为0、false或null。</p></li><li><p>type[] copyOfRange(type[] original, int from, int to)</p><p>只复制数组的from索引到to索引的元素</p></li><li><p>boolean equals(type[] a, type[] a2)</p><p>判断两个数组是否相等（长度+数组对应元素）</p></li><li><p>void fill(type[] a, type val)</p><p>将数组的所有元素设为val</p></li><li><p>void fill(type[] a, int fromIndex, int toIndex, type val)</p><p>与上一个相同，只是限制了赋值的索引范围</p></li><li><p>void sort(type[] a)</p><p>对数组元素排序（自定义排序方法涉及到重载）</p></li><li><p>void sort(type[] a, int fromIndex, int toIndex)</p><p>作用同上，只限制了排序的范围</p></li><li><p>String toString(type[] a)</p><p>将一个数组转换为字符串</p><p><center><u>代码清单</u></center></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimensionTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String names[] = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">         <span class="string">"人生苦短"</span>, </span><br><span class="line">         <span class="string">"来杯Java"</span></span><br><span class="line">      &#125;;</span><br><span class="line">      String namesCopy[] = Arrays.copyOf(names, names.length);</span><br><span class="line">      System.out.println(Arrays.toString(namesCopy));</span><br><span class="line">      names[<span class="number">0</span>] = <span class="string">"HelloWorld"</span>;</span><br><span class="line">      System.out.println(Arrays.toString(names));</span><br><span class="line">      System.out.println(Arrays.toString(namesCopy));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output------------------------------------------------------</span></span><br><span class="line"><span class="comment">// [人生苦短, 来杯Java]</span></span><br><span class="line"><span class="comment">// [HelloWorld, 来杯Java]</span></span><br><span class="line"><span class="comment">// [人生苦短, 来杯Java]</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;第四章-流程控制与数组&quot;&gt;&lt;a href=&quot;#第四章-流程控制与数组&quot; class=&quot;headerlink&quot; title=&quot;第四章　流程控制
      
    
    </summary>
    
      <category term="Java" scheme="https://phoenixxc.github.io/categories/Java/"/>
    
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
      <category term="Java" scheme="https://phoenixxc.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Chapter7-使用JSTL</title>
    <link href="https://phoenixxc.github.io/posts/2f1b8bf3/"/>
    <id>https://phoenixxc.github.io/posts/2f1b8bf3/</id>
    <published>2019-02-25T11:10:34.000Z</published>
    <updated>2019-07-22T12:16:20.733Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h2 id="JSTL-简介"><a href="#JSTL-简介" class="headerlink" title="JSTL 简介"></a>JSTL 简介</h2><p>JSTL 提供了与页面呈现相关的逻辑判断标签，也提供了对应 JSP 标注标签的扩展标签和更多的功能标签，可以分为五类：</p><ul><li>核心标签库：提供条件判断、属性访问、URL 处理及错误处理等</li><li>I18N 兼容格式标签库：提供数字、日期等的格式化和区域、编码处理等功能</li><li>SQL 标签库</li><li>XML 标签库：提供 XML 解析、流程控制、转换等功能</li><li>函数标签库：提供常用字串处理的已定义 EL 标签库</li></ul><p>idea 使用 JSTL 标签库：</p><ol><li>在 <a href="http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/" target="_blank" rel="noopener">JSTL</a> 中下载最新的 zip 文件，解压。</li><li>idea 中打开设置，搜索 Schemas and DTDs，点右边的 +，URL中输入 <a href="http://java.sun.com/jsp/jstl/core，浏览文件选择刚才解压后文件夹中的" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core，浏览文件选择刚才解压后文件夹中的</a> tld 目录下的 c.tld 文件。</li><li>将 zip 文件夹中的 lib 里的文件复制到项目中的 WEB-INF 的 lib 目录下，或者在 Project Setting -&gt; Libraries 中点＋，选择 lib 文件夹里面的文件。</li></ol><h2 id="核心标签库"><a href="#核心标签库" class="headerlink" title="核心标签库"></a>核心标签库</h2><h3 id="流程处理标签"><a href="#流程处理标签" class="headerlink" title="流程处理标签"></a>流程处理标签</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;param.name == 'momor'&amp;&amp; param.password == '1234'&#125;"</span>&gt;</span><br><span class="line">    &lt;h1&gt;$&#123;param.name&#125; 登录成功 &lt;/h1&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;%-- JSTL中可以使用EL表达式--%&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>test</code> 属性为 true，才会输出 <code>&lt;c:if&gt;</code> 标签中的语句。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;user.valid&#125;"</span>&gt;</span><br><span class="line">        &lt;jsp:getProperty name=<span class="string">"user"</span> property=<span class="string">"name"</span>/&gt; 登录成功</span><br><span class="line">        &lt;%--</span><br><span class="line">    * 属性的名称就是get/set方法去除get/set后 ,再把首字母小写</span><br><span class="line">* <span class="keyword">boolean</span>的方法可以是is开头</span><br><span class="line">--%&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        &lt;h1&gt; 登录失败 &lt;/h1&gt;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><p>当 <code>&lt;c:when&gt;</code> test 为 true 时，只会输出这个标签中的 Body 内容。否则继续判断下一个 <code>&lt;c:when&gt;</code> 标签中的 test，如果所有的 <code>&lt;c:when&gt;</code> 都不满足，就输出 <code>&lt;c:otherwise&gt;</code> 的内容（如果有这个标签）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"message"</span> items=<span class="string">"$&#123;messageService.messages&#125;"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;message.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;message.text&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>类似 Java 中的 forEach 循环，<code>items</code> 属性可以是数组、<code>Collection</code>、<code>Iterator</code>、<code>Enumeration</code>、<code>Map</code> 与字符串。每次会从 <code>items</code> 中取出元素，指定给 <code>var</code> 属性设置的变量。</p><p><code>items</code> 属性是 <code>Map</code> :</p><p>&emsp;&emsp;设置给 <code>var</code> 的对象是 <code>Map.Entry</code> ，有 <code>getKey()</code> <code>getValue()</code> 方法取得键与值。</p><p><code>items</code> 属性是字符串：</p><p>&emsp;&emsp;以逗号来切割字符串，如果要自定义切割依据可以使用<code>&lt;c:forTokens&gt;</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forTokens <span class="keyword">var</span>=<span class="string">"token"</span> delims=<span class="string">";"</span> items=<span class="string">"a;b;c;d;e"</span>&gt;</span><br><span class="line">&lt;%-- ... --%&gt;</span><br><span class="line">&lt;/c:forTokens&gt;</span><br></pre></td></tr></table></figure><h3 id="错误处理标签"><a href="#错误处理标签" class="headerlink" title="错误处理标签"></a>错误处理标签</h3><p>错误发生时，在当前网页捕捉异常并显示相关信息。使用 <code>&lt;c:catch&gt;</code> 标签。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">catch</span> <span class="keyword">var</span>=<span class="string">"error"</span>&gt;</span><br><span class="line">    $&#123;param.a&#125; + $&#123;param.b&#125; = $&#123;param.a + param.b&#125;</span><br><span class="line">&lt;/c:catch&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;error != null&#125;"</span>&gt;</span><br><span class="line">    &lt;br&gt;&lt;span style="color: red;"&gt;$&#123;error.message&#125;&lt;/span&gt;</span><br><span class="line">    &lt;br&gt;$&#123;error&#125;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><p>用 <code>&lt;c:catch&gt;</code> 标签将可能产生异常的部分包起来，如果有异常会给 <code>var</code> 设值。所有的异常都是 <code>Throwable</code> 的子类，都有 <code>getMessage()</code> 方法。</p><h3 id="网页导入、重定向、URL处理标签"><a href="#网页导入、重定向、URL处理标签" class="headerlink" title="网页导入、重定向、URL处理标签"></a>网页导入、重定向、URL处理标签</h3><p>包含其他 JSP 网页到当前网页的几种方式：</p><ul><li><code>&lt;%@include file=&quot;/....&quot; %&gt;</code></li><li>使用 <code>&lt;jsp:include&gt;</code> 标签，动态包含，还可传递参数</li></ul><p>JSTL 中有一个 <code>&lt;c:import&gt;</code> 标签，也可以在运行时动态导入到另一个网页。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">import</span> url=<span class="string">"add.jsp"</span>&gt;</span><br><span class="line">&lt;c:param name=<span class="string">"a"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">    &lt;%-- 用 &lt;c:param&gt; 标签传递参数--%&gt;</span><br><span class="line">&lt;/c:import&gt;</span><br><span class="line">&lt;c:<span class="keyword">import</span> url=<span class="string">"https://...."</span> charEncoding=<span class="string">"BIG5"</span> /&gt;</span><br><span class="line">&lt;%--导入外部网页，如果编码不同需指定具体编码--%&gt;</span><br><span class="line">&lt;%--没有使用参数--%&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;c:redirect&gt;</code> 标签，可以重定向网页，类似 Servlet 中的 <code>HttpServletResponse.sendRedirect()</code> 方法，可以使用 <code>&lt;c:param&gt;</code> 标签在重定向时指定参数。</p><p>之前利用 <code>response.encodeURL()</code> 方法来作 URL 重写，以在关闭 Cookie 后正常维持 Session 进行会话管理，现在可以用 <code>&lt;c:url&gt;</code> 标签达到同样的目的。</p><h3 id="属性处理与输出标签"><a href="#属性处理与输出标签" class="headerlink" title="属性处理与输出标签"></a>属性处理与输出标签</h3><p>可以用 JSTL 设置属性：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"p1q1"</span> value=<span class="string">"$&#123;param.p1q1&#125;"</span> scope=<span class="string">"session"</span> /&gt;</span><br><span class="line">&lt;%--属性值太长可以用 Body 形式--%&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"p1q2"</span> scope=<span class="string">"session"</span>&gt;</span><br><span class="line">    some....</span><br><span class="line">&lt;/c:set&gt;</span><br></pre></td></tr></table></figure><p><code>var</code> 用来设置属性名，<code>value</code> 设置属性值（可以用 EL 表达式），如果不设置 <code>scope</code> ，会从 <code>page</code> 、<code>request</code> 、<code>session</code>、<code>application</code> 的范围中查找属性名称，如果找到就在该范围设置，找不到就在<code>page</code> 范围新建。</p><p>移除属性：<code>&lt;c:remove var=&quot;login&quot; scope=&quot;session&quot;/&gt;</code></p><p><code>&lt;c:set&gt;</code> 可以设置 JavaBean 的属性或 <code>Map</code> 对象的键/值，需要使用 <code>target</code> 属性进行设置。</p><p><code>&lt;c:set target=&quot;${pageContext.request}&quot; property=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;</code></p><p>如果 <code>target</code> 属性是 JavaBean，就用 JavaBean 的 <code>setXXX</code> 方法为 <code>property</code> 设值。</p><p>如果是 <code>Map</code> 对象，则会以 <code>property</code> 为键，以 <code>value</code> 为值。</p><hr><p><code>&lt;c：out&gt;</code> 标签可以输出内容，并用合适的字符替换 &lt;、&gt;、”等字符。eg.<code>&lt;c:out value=&quot;some&quot;&gt;</code></p><p>如果不想取代字符，可以设置属性 <code>escapeXml</code> 为 <code>false</code> （默认为 true），如果输出内容的 EL 表达式结果为 null 时，不会显示任何内容，也可以加上 <code>default</code> 属性设置为null时的默认值。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;JSTL-简介&quot;&gt;&lt;a href=&quot;#JSTL-简介&quot; class=&quot;headerlink&quot; title=&quot;JSTL 简介&quot;&gt;&lt;/a&gt;JST
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter6-使用jsp</title>
    <link href="https://phoenixxc.github.io/posts/2bd95d05/"/>
    <id>https://phoenixxc.github.io/posts/2bd95d05/</id>
    <published>2019-02-22T06:22:34.000Z</published>
    <updated>2019-08-18T08:46:37.130Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指示元素"><a href="#指示元素" class="headerlink" title="指示元素"></a>指示元素</h3><p>JSP指示元素主要是为了表示容器将 JSP 转译为 Servlet 源代码时所必须遵守的信息。</p><p>语法为：<code>&lt;%@ 指示类型 [属性=&quot;值&quot;]* %&gt;</code>，指示元素可以有多对的属性/值</p><p>JSP 常用的三种指示类型为：<code>page</code> 、<code>include</code>、<code>taglib</code></p><ul><li><code>page</code>： 告知容器如何转译当前的JSP网页</li><li><code>include</code>： 告知容器将别的JSP页面包括进来进行转译</li><li><code>taglib</code>： 告知容器如何转译这个页面的标签库</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.util.Date"</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br></pre></td></tr></table></figure><p><code>1</code>：告知容器转译时要包括<code>import</code>属性中的值的包，即 Servlet 要有<code>import java.uutil.Date;</code>，如果有多个包要包含，可以用逗号分割开：<code>... import=&quot;java.util.Date, java.util.io*, ...&quot;</code></p><p><code>2</code>：<code>contenType</code>属性对应转译后的<code>response.setContentType(&quot;...&quot;)</code>，<code>pageEncoding</code>告诉容器这个网页的编码</p><p><code>include</code>类型的范例：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- includeDemo.jsp --&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">"/WEB-INF/jspf/header.jspf"</span>%&gt;</span><br><span class="line">&lt;h1&gt;这是本尊&lt;/h1&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">"/WEB-INF/jspf/foot.jspf"</span>%&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--header.jspf--&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"zh"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;示范开头&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;这是开头&lt;/h1&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--foot,jspf--&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;h1&gt;这是结尾&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>includeDemo.jsp 第一次执行时会将上面两个文件的内容包括起来，然后进行转译，所以最终会生成一个Servlet，这是一种静态的包括方式。<code>&lt;jsp:include&gt;</code>标签是运行时动态包括别的网页执行流程进行响应的方式，会各自生成独立的 Servlet。</p><p>同时也可以看到，包含的两个文件的后缀名是 .jspf，.jspf 文件通常是通过include伪指令包含在.jsp文件中的文件。’f’代表’fragment’，因为这些文件本身可能并不是完整的JSP，而是JSP的片段。类似这样的后缀名还有一个 .jspx。</p><p>同样，关于一些JSP的设置也可以在 web.xml 中更改，例如网页编码、内容类型等等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">page-encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">page-encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">default-content-type</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">default-content-type</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以声明指定的JSP文件的开头和结尾所要包括的网页</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include-perlude</span>&gt;</span>some...<span class="tag">&lt;/<span class="name">include-perlude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include-coda</span>&gt;</span>some...<span class="tag">&lt;/<span class="name">include-coda</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在编写JSP网页时，换行字符不会忽略，所以最后产生的换行字符也会输出，如果要忽略，可以在 web.xml 中的<code>&lt;jsp-property-group&gt;标签中加上</code> <code>&lt;trim-directive-whitespaces&gt;true&lt;/...&gt;</code></p><h3 id="声明、Scriptlet-与表达式元素"><a href="#声明、Scriptlet-与表达式元素" class="headerlink" title="声明、Scriptlet 与表达式元素"></a>声明、Scriptlet 与表达式元素</h3><p>JSP 中可以使用 声明、Scriptlet 元素和表达式来指定转译后 Servlet 类中包括的类成员、方法声明和语句。</p><p>声明元素的语法：<code>&lt;@! 类成员声明或方法声明 %&gt;</code></p><p>Scriptlet 的语法：<code>&lt;% Java 语句 %&gt;</code></p><p>在 JSP 中的编写的 HTML，都会变成 out 语句所输出的内容，而 Scriptlet 出现的顺序在转译为 Servlet 后，会按顺序出现在 <code>_jsoService()</code> 中。</p><p>表达式元素的语法：<code>&lt;%= Java表达式 %&gt;</code></p><p>表达式的运算结果将直接输出为网页的一部分，但表达式语句不能加上分号，因为在转译后，表达式语句的表达式会转译为 out 对象输出时的指定内容。</p><p>由于<code>&lt;%</code>和<code>%&gt;</code>在 JSP 中用来作为一些元素的开头和结尾，所以如果要在 JSP 网页中输出这两个符号要换成其他字符：<code>&lt;%</code> –&gt; <code>&amp;lt;%</code>，<code>%&gt;</code> –&gt; <code>%&amp;gt;</code>或<code>%\&gt;</code> （HTML输出<code>&amp;</code>用<code>&amp;amp</code>）。</p><p>一个网页通过适当的规划、切割业务逻辑与呈现逻辑，JSP 网页可以通过标准标签、EL 或  JSTL 自定义标签等消除网页上的 Scriptlet。</p><h3 id="注释元素"><a href="#注释元素" class="headerlink" title="注释元素"></a>注释元素</h3><p>使用 <code>&lt;%-- JSP注释 --%&gt;</code>，写出网页注释会输出到网页上。</p><h3 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h3><p><center>JSP 隐式对象</center><br>| 隐式对象    | 说明                                                         |<br>| :———- | ———————————————————— |<br>| out         | 转译后对应 <code>JspWriter</code> 对象，其内部关联一个 <code>PrintWriter</code> 对象 |<br>| request     | 转译后对应 <code>HttpServletRequest</code> 对象                         |<br>| response    | 转译后对应 <code>HttpServletResponse</code> 对象                        |<br>| config      | 转译后对应 <code>ServletConfig</code> 对象                              |<br>| applicaton  | 转译后对应 <code>ServletContext</code> 对象                             |<br>| session     | 转译后对应 <code>HttpSession</code> 对象                                |<br>| pageContext | 转译后对应 <code>pageContext</code> 对象，提供了 JSP 页面资源的封装，可设置页面范围属性 |<br>| exception   | 转译后对应 <code>Throwable</code> 对象 ，代表其他 JSP 页面抛出的异常对象，只会出现于 JSP 错误页面 |<br>| page        | 转译后对应 <code>this</code>                                            |</p><p>隐式对象只能在<code>&lt;%</code>和<code>%&gt;</code>或<code>&lt;%=</code>和<code>%&gt;</code>之间使用。隐式对象转译后是<code>_jspService()</code>中的局部变量。</p><p><code>JspWriter</code> 主要模拟了 <code>BufferedWriter</code> 与 <code>PrintWriter</code> 的功能，内部也是用 <code>PrntWriter</code> 来输出，但 <code>JspWriter</code> 具有缓冲区功能，使用 <code>print()</code> 和 <code>println()</code> 响应输出时，如果 JSP 页面没有缓冲或清楚缓冲时，才会直接创建 <code>printWriter()</code> 对象进行输出。</p><hr><p><code>page</code> 指示元素的 <code>buffer</code> 属性来设置缓冲区的大小，默认是8kb，<code>autoFlush</code> 属性决定缓冲区已满后的行为，默认值是 <code>true</code> ，表示慢了就清除，如果设置为 <code>false</code>，要自行调用 <code>JspWriter</code> 的 <code>flush()</code> 方法来清除，否则调用 <code>println()</code> 会抛出 <code>IOException</code> 异常。</p><hr><p>所有的隐式对象都可以通过 <code>pageContext</code> 的 <code>getXXX()</code> 方法来取得，<code>pageContext</code> 也可以设置页面范围属性，类似 Servlet 中的几个对象，可以使用 <code>setAttribute()</code>、<code>getAttribute()</code>、<code>removeAttribute()</code> 来设置。页面范围属性的作用范围仅仅局限于同一页面中。</p><p><code>pageContext</code> 提供了单一的 API  来设置四种范围属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getAttribute(String name, <span class="keyword">int</span> scope);</span><br><span class="line">setAttribute(String name, Object value, <span class="keyword">int</span> scope);</span><br><span class="line">removeAttribute(String name, <span class="keyword">int</span> scope);</span><br></pre></td></tr></table></figure><p>scope 的取值所代表的范围：</p><ul><li><code>pageContext.PAGE_SCOPE</code>: 页面</li><li><code>pageContext.REQUEST_SCOPE</code> : 请求</li><li><code>pageContext.SESSION_SCOPE</code>: 会话</li><li><code>pageContext.APPLICATION_SCOPE</code> :  应用程序范围</li></ul><p>如果不知道属性范围的名称，可以用 <code>pageContext</code> 的 <code>findAttribute()</code> 方法依序从页面、请求、会话、应用程序范围中寻找，先找到就返回。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>JSP 发生错误按时段分为三种：</p><ul><li>JSP 转换为 Servlet 源代码</li><li>Servlet 源代码编译时</li><li>Servlet 载入容器进行服务但发生运行时错误时</li></ul><p>可以自定义运行时异常发生时的处理页面，需要用 <code>page</code> 指示元素，设置 <code>errorPage</code> 属性来指定错误处理的页面。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--add.jsp--%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> errorPage=<span class="string">"error.jsp"</span> %&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--error.jsp--%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> isErrorPage=<span class="string">"true"</span> %&gt;</span><br></pre></td></tr></table></figure><p><code>exception</code> 对象是 JSP 的隐式对象，只有 <code>isErrorPage</code> 设置为 <code>true</code> 的页面才可以使用这个对象。如果没有处理，会由容器默认处理，直接显示异常信息和堆栈跟踪信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--容器收到某个类型的异常对象时进行转发--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.NullPointerException<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/report.view<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--基于HTTP错误状态码转发至处理页面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标准标签"><a href="#标准标签" class="headerlink" title="标准标签"></a>标准标签</h2><p>JSP 规范中提供了一些标准标签，所有容器都支持，可协助编写 JSP 是减少 Scriptlet 的使用，所有的标签都以 <strong>jsp:</strong> 为前缀。</p><h3 id="lt-jsp-include-、-lt-jsp-forward-标签"><a href="#lt-jsp-include-、-lt-jsp-forward-标签" class="headerlink" title="&lt;jsp:include>、&lt;jsp:forward>标签"></a>&lt;jsp:include>、&lt;jsp:forward>标签</h3><p><code>&lt;jsp:include&gt;</code> 和 <code>&lt;jsp:forward&gt;</code>标签在转译后，底层是取得 <code>RequestDispatcher</code> 对象，并执行对应的 <code>forward()</code> 方法和 <code>include()</code> 方法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">"add.jsp"</span>&gt;</span><br><span class="line">&lt;jsp:param name=<span class="string">"a"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;jsp:param&gt;</code> 指定了动态包括 add.jsp 时需要给页面的请求参数。</p><h3 id="lt-jsp-userBean-、-lt-jsp-setProperty-与-lt-jsp-getProperty-gt"><a href="#lt-jsp-userBean-、-lt-jsp-setProperty-与-lt-jsp-getProperty-gt" class="headerlink" title="&lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt;"></a>&lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt;</h3><p>JavaBean 元件具有的条件：</p><ul><li><p>必须实现 <code>java.io.Serializable</code> 接口</p></li><li><p>没有公开的类变量</p></li><li><p>具有无参数的构造器</p></li><li><p>具有公开的设值(setXXX)和取值(getXXX)方法</p><p>&lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt; 这三个标准标签就是搭配 JavaBean 元件的。</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"User"</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">"user"</span> property=<span class="string">"*"</span>/&gt;</span><br></pre></td></tr></table></figure><p>1.用来取得或创建 JavaBean</p><p><code>id</code> 指定 JavaBean 的实例名，之后可使用这个指定的名称设值和取值。</p><p><code>class</code> 属性指定要实例化哪个类。</p><p>还有一个属性 <code>scope</code> （默认为 <code>page</code> 范围）指定先查找设定的属性范围是否有名为<code>id</code> 指定值的 JavaBean 的属性存在，如果找到就直接使用，没有找到就会新建新的对象。</p><p> <code>type</code> 属性，指定声明 JavaBean 的类型，可以是一个抽象类、也可以是一个接口。但如果只设置了 type 而没有 class , 如果指定范围内找不到对象会抛出异常。</p><p>2.设置 JavaBean 的属性值</p><p><code>name</code> 指定要使用哪个名称来使用 JavaBean 实例，<code>property</code> 表示要设置的 JavaBean 属性，这两个属性在这个标签中必需的。</p><p><code>value</code> 和 <code>param</code> 两个属性可选，找到 JavaBean 后，如果指定了 <code>value</code> 元素，会将value的值转换为合适的基本类型赋值给指定的 JavaBean 属性。有 <code>param</code> 属性的话会将指定的参数的值转化会合适的基本类型赋给 JavaBean 属性。</p><p>如果<code>value</code> 和 <code>param</code> 都省略，可以用 JSP 的自省机制判断是否有 <code>property</code> 值相同的请求参数，有的话就赋给 JavaBean。</p><p>最有弹性的写法是示例代码第二行所示，标签中只有必要元素，<code>property</code> 值设为 <code>*</code>，代表将请求参数名称和 JavaBean 属性名交给自省机制自动匹配。自省机制可以自动转换基本类型。</p><p>有两种很容易混淆的写法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"User"</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">"user"</span> property=<span class="string">"*"</span>/&gt;</span><br></pre></td></tr></table></figure><p>这种写法无论如何都会使用设值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"User"</span>&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">"user"</span> property=<span class="string">"*"</span>/&gt;</span><br><span class="line">&lt;/jsp:useBean&gt;</span><br></pre></td></tr></table></figure><p>这种只有找不到 JavaBean 对象的时候，才会新建对象并设置值。</p><hr><p><code>&lt;jsp:getProperty&gt;</code> 只有一种使用方法：<code>&lt;jsp:getProperty name=&quot;JavaBean 对象实例名&quot;, property=&quot;JavaBean 对象属性名&quot;&gt;</code> ，然后用 <code>pageContext</code> 的 <code>findAttribute()</code>依次查找。</p><h3 id="表达式语言（EL）"><a href="#表达式语言（EL）" class="headerlink" title="表达式语言（EL）"></a>表达式语言（EL）</h3><p>JSP 中一些简单的属性、请求参数、标头和 Cookie 等信息可以用 EL 来处理，更加简便。</p><p>EL 是使用 <code>${</code> 与 <code>}</code> 来包括要处理的表达式。EL 处理了<code>null</code>值的情况，对 <code>null</code> 值直接以空字符串显示，运算时不会因此发生错误而抛出异常。</p><p>由于某些时候网页使用了模板等有类似EL表达式的语法存在，可以设置 JSP 网页是否使用 EL.</p><ul><li><p>web.xml 中修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-ignored</span>&gt;</span>true<span class="tag">&lt;/<span class="name">el-ignored</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>page</code> 指示元素的属性 <code>isELIgnored</code> (<em>default:</em>  <code>false</code>)</p></li></ul><p>如果在 <code>page</code> 中设置了属性，以 <code>page</code> 中的设置为主。</p><hr><h3 id="隐式对象-1"><a href="#隐式对象-1" class="headerlink" title="隐式对象"></a>隐式对象</h3><p>EL 中，可以用 EL 隐式对象指定范围来存取属性。如果不指定属性的范围，以 page、request、session、application 的顺序依次查找。</p><p>EL 中有11个隐式对象，只有 <code>pageContext</code> 隐式对象对应 <code>PageContext</code> ，其他都对应 <code>Map</code> 类型</p><ul><li><p><code>pageContext</code></p><p>PageContext 本身是 JavaBean 对象，所以只要是 getXXX() 方法，就可以使用 <code>${pageContext.xxx}</code> 来取得。也可以使用点运算符连续存取对象。</p></li><li><p>属性范围相关隐式对象</p><p>表示作用范围，<code>pageScope</code>, <code>requestScope</code>, <code>sessionScope</code>, <code>applicationScope</code> 分别可以取得使用对应 JSP 隐式对象的 <code>setAttribute()</code> 方法所设置的属性对象。</p></li><li><p>请求参数相关隐式对象：<code>param</code> 和 <code>paramValues</code></p><p><code>${param.user}</code> 想当于 <code>&lt;%= request.getParameter(&quot;user&quot;)%&gt;</code></p><p><code>paramValues</code> 相当于 <code>request.getParameterValues()</code> ，因为返回的可能是多个值，可以用 [] 运算符指定取得的是那个元素。</p></li><li><p>标头相关隐式对象：<code>header</code> 和 <code>headersValues</code>，</p><p><code>${header[&quot;User-Agent&quot;]}</code> <--> <code>reqest.getHeader(&quot;User-Agent&quot;)</code></--></p></li><li><p>Cookie 隐式对象：<code>cookie</code></p><p>用来取得用户 Cookie 设置值。</p></li><li><p>初始参数隐式对象：<code>initParam</code> 可以取得 web.xml 中设置的 <code>ServletContext</code> 初始参数</p></li></ul><h3 id="取得元素的方式"><a href="#取得元素的方式" class="headerlink" title="取得元素的方式"></a>取得元素的方式</h3><p>可以用 . 和 [] 来取得属性中的元素：</p><ul><li>. 运算符：左边可以是 JavaBean 或 Map 对象（Map 建议用 [] 运算符）</li><li>[] 运算符：左边可以是 JavaBean 属性，Map，数组或 List 对象</li></ul><p>[] 在指定索引是使用双引号，就是作为键名或索引来使用，不加双引号会先尝试运算。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol><li>算数运算符：+, -, *(mod), /(div), %(mod), ? : </li><li>逻辑运算符：and, or, not</li><li>关系运算符：&lt;(lt), &gt;(gt), &lt;=(le), &gt;=(ge), ==(eq), !=(ne)</li></ol><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><strong>第一步</strong>：编写类，公开类，且调用的方法是公开且为静态方法</p><p><strong>第二步</strong>：编写 TLD（标签程序描述）文件（xml文件，以 .tld 为后缀），告诉容器如何将类中的方法作为 EL 函数</p><p><strong>第三步</strong>：将文件放在 WEB-INF 文件夹下或 JAR 文件中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;指示元素&quot;&gt;&lt;a href=&quot;#指示元素&quot; class=&quot;headerlink&quot; title=&quot;指示元素&quot;&gt;&lt;/a&gt;指示元素&lt;/h3&gt;&lt;p&gt;JSP指示元素主要是为了表示容器将 JSP 转译为 Servlet 源代码时所必须遵守的信息。&lt;/p&gt;
&lt;p&gt;语法为：&lt;co
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5 Servlet 进阶API,过滤器与监听器</title>
    <link href="https://phoenixxc.github.io/posts/fd419a6b/"/>
    <id>https://phoenixxc.github.io/posts/fd419a6b/</id>
    <published>2019-02-18T02:44:34.000Z</published>
    <updated>2019-07-22T12:15:56.236Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h3 id="使用-ServletContext"><a href="#使用-ServletContext" class="headerlink" title="使用 ServletContext"></a>使用 ServletContext</h3><blockquote><p><img src="https://img-blog.csdn.net/20160513225142387" alt></p><ul><li><p>你可以把它想象成一个公用的空间，可以被所有的客户访问，也就是说A客户端可以访问D，B客户端可以访问D，C客户端也可以访问D。</p></li><li><p>WEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext，它代表当前Web应用。并且它被所有客户端共享。</p></li><li><p>ServletContext对象可以通过ServletConfig.getServletContext()方法获得对ServletContext对象的引用，也可以通过this.getServletContext()方法获得其对象的引用。</p></li><li><p>由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。公共聊天室就会用到它。</p></li><li><p>当web应用关闭、Tomcat关闭或者Web应用reload的时候，ServletContext对象会被销毁</p></li></ul><hr><p>作者：KLeonard<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/gavin_john/article/details/51399425" target="_blank" rel="noopener">https://blog.csdn.net/gavin_john/article/details/51399425</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p></blockquote><p>当整个Web应用程序加载Web容器后，容器会生成一个<code>ServletContext</code>对象作为<strong>整个应用程序的代表</strong>，可以通过<code>ServletConfig</code>的<code>getServletContext()</code>方法就可以取得<code>ServletContext</code>对象．</p><p><code>ServletContext</code>接口定义了运行Servlet的应用环境的一些行为，可以使用该接口的实现对象来取得所请求资源的URL，设置和存储属性，应用程序初始参数等．</p><ol><li><p><code>getRequestDispatcher()</code></p><p>用来取得<code>RequestDispatcher()</code>实例，路径必须是绝对路径，即以＂/＂开头（代表应用程序根目录）．</p><p><code>HttpServletRequest.getRequestDispatcher(String)</code>既可以使用相对路径也可以使用绝对路径，但是实际上在实现时，如果是环境相对路径则直接委托给<code>ServletContext</code>的<code>getServletContext()</code>，如果是请求相对路径则转换为环境相对路径后，再委托．</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;使用-ServletContext&quot;&gt;&lt;a href=&quot;#使用-ServletContext&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter4 会话管理基本原理</title>
    <link href="https://phoenixxc.github.io/posts/b2e1ccaf/"/>
    <id>https://phoenixxc.github.io/posts/b2e1ccaf/</id>
    <published>2019-02-15T08:18:34.000Z</published>
    <updated>2019-07-22T12:15:38.596Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h2 id="会话管理的基本原理"><a href="#会话管理的基本原理" class="headerlink" title="会话管理的基本原理"></a>会话管理的基本原理</h2><p>Web应用程序中有些功能需要多次请求才能完成，所以需要某些方式来记得此次请求与之后请求之间的关系，这类方式称之为<strong>会话管理</strong>．</p><p>会话管理的基本方式有：隐藏域（Hidden Field），Cookie，URL重写等</p><h3 id="使用隐藏域"><a href="#使用隐藏域" class="headerlink" title="使用隐藏域"></a>使用隐藏域</h3><p>在HTTP协议中，服务器并没有记忆功能，那么可以让浏览器在每次请求时＂主动告知＂服务器多次请求间的必要信息，服务器只需单纯处理请求中的信息就好．</p><p>隐藏域就是主动告知服务器多次请求间必要信息的方式之一．</p><p><strong>使用隐藏域的缺点：</strong></p><p>&emsp;&emsp;关掉网页后会丢失之前的信息，仅适合简单的状态管理，查看网页源码可以看到隐藏的信息，不适合用于隐秘性较高的数据．</p><p>隐藏域不是Servlet/JSP实际管理会话时的机制，实现Web应用程序会话的基本原理是由浏览器主动告知必要的信息．</p><h3 id="使用-Cookie"><a href="#使用-Cookie" class="headerlink" title="使用 Cookie"></a>使用 Cookie</h3><p>Cookie 是在浏览器存储信息的一种方式，服务器可以响应浏览器 set-cookie 标头，浏览器收到标头与数值后会以文件的形式存储在计算机上，即 Cookie.</p><p>Cookie 可以设置存活期限．<br>Servlet可以通过<code>Cookie</code>类的<code>getMaxAge()</code>方法获取Cookie的有效期；<br>Servlet可以通过设置<code>Cookie</code>类的<code>setMaxAge( int expiry );</code></p><p>//expiry默认值为 -1；<br>1.如果expiry大于0，则保存有效期为expire时间长度，单位毫秒；<br>2.如果expiry等于0，则指示浏览器删除当前cookie；<br>3.如果expiry小于0，则指示浏览器不保存该cookie到硬盘，就保存在内存中，浏览器关闭就消失；</p><p>创建Cookie:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user"</span>, <span class="string">"caterpillar"</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>); <span class="comment">// 以秒为单位</span></span><br><span class="line"><span class="comment">// 创建cookie及其存活期限</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"><span class="comment">// 将cookie加入响应之中</span></span><br></pre></td></tr></table></figure><p>获取Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">// 取得 Cookie</span></span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        String name = cookie.getName();<span class="comment">// 获取Cookie名称</span></span><br><span class="line">        String value = cookie.getValue();   <span class="comment">// 获取Cookie数值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"user"</span>.equals(name) &amp;&amp; <span class="string">"caterpillar"</span>.equals(value)) &#123;</span><br><span class="line">            request.setAttribute(name, value);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/user.view"</span>).forward(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet 3.0 中，<code>Cookie</code>增加了<code>setHttpOnly()</code>方法，将Cookie标示为仅用于HTTP，如果浏览器支持，这个Cookie不会被客户端脚本读取，可以用<code>isHttpOnly()</code>方法判断是否被标示</p><h3 id="使用-URL-重写"><a href="#使用-URL-重写" class="headerlink" title="使用 URL 重写"></a>使用 URL 重写</h3><p>URL重写就是GET请求参数的应用，当服务器响应浏览器的上一次请求时，将某些相关信息以超链接的方式响应给浏览器，超链接包括请求参数信息．</p><p>由于URL重写是在超链接之后附加信息，所以必须以GET方式发送请求．</p><p>通常URL重写是用在一些简单的客户端信息保留，或者辅助会话管理．</p><h2 id="HttpSession-会话管理"><a href="#HttpSession-会话管理" class="headerlink" title="HttpSession 会话管理"></a>HttpSession 会话管理</h2><p>Servlet/JSP中会话管理的机制：<code>HttpSession</code></p><h3 id="使用-HttpSession"><a href="#使用-HttpSession" class="headerlink" title="使用 HttpSession"></a>使用 HttpSession</h3><p>获得<code>HttpSession</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line"><span class="comment">// getSession()有两个版本</span></span><br><span class="line"><span class="comment">// 另一个可以传入布尔值作为参数, </span></span><br><span class="line"><span class="comment">// 默认为true，表示尚未存在HttpSession对象时, 直接创建一个新的对象</span></span><br><span class="line"><span class="comment">// 如果是false，如不存在实例返回null</span></span><br></pre></td></tr></table></figure><p>默认在浏览器关闭前，<code>HttpSession</code>都是相同的实例，如果想要让目前的<code>HttpSession</code>失效可以调用<code>HttpSession</code>的<code>invalidate()</code>方法，执行这个方法后，容器会销毁回收<code>HttpSession</code>对象，再调用<code>getSession()</code>取得的对象是另一个新对象.</p><p>设置与获得属性：</p><ul><li><code>setAttribute()</code>：设置属性</li><li><code>getAttribute()</code>：获得属性</li></ul><p><strong><code>HttpSession</code>不是线程安全，需要注意属性设定的共享存取问题</strong></p><h3 id="HttpSession-会话管理原理"><a href="#HttpSession-会话管理原理" class="headerlink" title="HttpSession 会话管理原理"></a>HttpSession 会话管理原理</h3><p>尝试运行<code>HttpSession</code>的<code>getSession()</code>方法时，Web容器会创建<code>HttpSession</code>对象，每个对象都有一个特殊的ID: <strong>Session ID</strong>，可以用<code>HttpSession</code>的<code>getId()</code>来取得Session ID，ID默认使用Cookie存储在浏览器中．</p><p><code>HttpSession</code>中存放的属性也存放在服务端的Web容器里，当浏览器请求应用程序时，会将Cookie中的Session ID 一同发送给应用程序里，Web容器会根据得到的ID找到对应的Session对象，这样就可以取得各浏览器的各自的会话数据．</p><p>Web容器存储Session ID的Cookie默认设置当浏览器被关闭就失效，浏览器重新启动后由于ID失效，尝试<code>getSession()</code>后，容器会产生新的<code>HttpSession</code>对象，如果不使用<code>invalidate()</code>使对象立即失效，对象会等到设定的失效期间过后才会被销毁回收．</p><p>设置<code>HttpSession</code>对象失效时间的方法：</p><ul><li><p>调用该对象的<code>setMaxInactiveInterval()</code>方法，设定浏览器多久没请求应用程序的话就自动失效，单位为<strong>秒</strong>；</p></li><li><p>也可以在web.xml中修改，设定的单位是<strong>分钟</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><code>HttpSession</code>的属性中尽量不要存储耗资源的对象，必要时将属性移除（<code>public void removeAttribute(String name)</code>），或者让其失效．</p><p>Servlet 3.0 中新增了<code>SessonCookieConfig</code>接口，可以通过<code>ServleContext</code>的<code>getSessionCookieConfig()</code>取得该接口的对象，通过这个接口的实现对象可以设定存储Session ID的Cookie相关的信息，设定必须在<code>ServletContext</code>初始化之前</p><ul><li>在web.xml中设定</li><li>实现<code>ServletContextListener</code></li></ul><h3 id="HttpSession-与-URL-重写"><a href="#HttpSession-与-URL-重写" class="headerlink" title="HttpSession 与 URL 重写"></a>HttpSession 与 URL 重写</h3><p>因为<code>HttpSession</code>默认使用Cookie来存储ID，如果浏览器禁用Cookie，还想使用<code>HttpSession</code>来进行会话管理的话，可以搭配URL重写，向浏览器响应一段超链接，超链接URL附加上Session ID，单击超链接后将Session ID以<strong>GET</strong>请求发送给Web应用程序．</p><p>如果要使用URL重写的方式发送Session ID，可以使用<code>HttpServletResponse</code>的<code>encodeURL()</code>协助产生需要的URL，如果Cookie可用，将URL本身输出，如果不可以会自动产生带有Session ID的URL重写．</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;会话管理的基本原理&quot;&gt;&lt;a href=&quot;#会话管理的基本原理&quot; class=&quot;headerlink&quot; title=&quot;会话管理的基本原理&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3 请求与响应</title>
    <link href="https://phoenixxc.github.io/posts/2b70cf0d/"/>
    <id>https://phoenixxc.github.io/posts/2b70cf0d/</id>
    <published>2019-02-13T06:30:34.000Z</published>
    <updated>2019-07-22T12:15:21.569Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h2 id="从容器到-HttpServlet"><a href="#从容器到-HttpServlet" class="headerlink" title="从容器到 HttpServlet"></a>从容器到 HttpServlet</h2><h3 id="web-容器做了什么"><a href="#web-容器做了什么" class="headerlink" title="web 容器做了什么"></a>web 容器做了什么</h3><p>当浏览器请求来到HTTP服务器, HTTP服务器转交给容器, 容器会创建一个代表本次请求的<code>HttpServlet</code>对象, 并传给请求的相关信息, 同时会创建一个<code>HttpServletResponse</code>对象, 作为稍后要对客户端进行响应的Java对象.</p><p>然后, 容器会根据@WebServlet标注或web.xml的设置, 找到处理该请求的Servlet, 调用它的<code>service()</code>方法, 传入容器在之前所创建的两个对象, 在service()方法中会根据HTTP请求的方式来调用对应的<code>doXXX()</code>方法.</p><p>最后容器将<code>HttpServletRequest</code>对象和<code>HttpServletResponse</code>对象销毁回收, 结束本次响应.</p><h3 id="doXXX-方法"><a href="#doXXX-方法" class="headerlink" title="doXXX() 方法"></a>doXXX() 方法</h3><p>Servlet接口的<code>service()</code>方法中, 实际接受的参数是<code>ServletRequest</code>, <code>ServletResponse</code>, 在定义Servlet时, 期待Servlet不止用于HTTP, 与HTTP相关的行为由两者的子接口<code>HttpServletRequest</code>, <code>HttpServletResponse</code> 定义.</p><h2 id="关于-HttpServletRequest"><a href="#关于-HttpServletRequest" class="headerlink" title="关于 HttpServletRequest"></a>关于 HttpServletRequest</h2><h3 id="处理请求参数与标头"><a href="#处理请求参数与标头" class="headerlink" title="处理请求参数与标头"></a>处理请求参数与标头</h3><p>HttpServletRequest中定义了取得通用<strong>请求信息</strong>的方法</p><ul><li><p><code>getParameter()</code>: 指定请求参数名称来取得对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String username = request.getParameter(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure><p>返回String对象, 如果请求中没有指定的参数名称, 返回null</p></li><li><p><code>getParameterValues()</code>: 若同一个请求参数名称有多个值, 可以使用这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] values = request.getParameterValues(<span class="string">"param"</span>);</span><br></pre></td></tr></table></figure><p>返回一个存储了参数的值的String数组</p></li><li><p><code>getParameterNames()</code>: 获取请求中所有的请求参数名称, 返回<code>Enumeration</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;String&gt; e = req.getParameterNames();</span><br><span class="line"><span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line">    String name = e.nextElement();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getParameterMap()</code>: 将请求参数以<code>Map</code>对象返回, 键为请求参数名(String), 值为请求参数值(String[])</p></li></ul><p>获取HTTP<strong>标头信息</strong></p><ul><li><code>getHeader()</code>: 与<code>getParameter()</code>类似, 指定标头名称返回标头信息</li><li><code>getHeaders()</code>: 与<code>getParameterValues()</code>类似, 指定标头名称返回<code>Enumeration</code>对象, 元素为字符串</li><li><code>getHeaderName()</code>: 与<code>getParameterNames()</code>类似, 取得所有标头名称, 返回<code>Enumeration</code></li></ul><h3 id="请求参数编码处理"><a href="#请求参数编码处理" class="headerlink" title="请求参数编码处理"></a><del>请求参数编码处理</del></h3><ul><li><p>POST</p><p>如果客户端没有在 Content-Type 标头中设置字符编码, 使用<code>HttpSerletRequest</code>的<code>getCharacterEncoding()</code>返回值是<code>null</code></p><p>可以使用<code>HttpServletRequest</code>的<code>setCharacterEncoding()</code>方法指定取得POST请求参数时使用的编码, 只有在取得参数前执行才有用.</p></li><li><p>GET</p><p>如果是GET, 上述的方法设置编码无用.</p><p>另一种处理编码的方式: 通过<code>String</code> 的 <code>getBytes()</code>指定编码来取得字符串的字节数组, 然后再重新构造为正确编码的字符串.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = req.getParameter(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 假设浏览器使用UTF-8, web容器使用ISO-8859-1</span></span><br><span class="line">name = <span class="keyword">new</span> String(name.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// public String(byte[] bytes, String charsetName);</span></span><br></pre></td></tr></table></figure></li></ul><p>Tomcat8URI默认编码为“UTF-8”，而Tomcat7URI默认编码为“ISO-8859-1”</p><p><strong>原书为繁体, 如果要使结果正常需要使用Tomcat7环境, form-get.html, form-post.html两个网页用繁体(编码为Big5), 或者简体(编码为GBK)</strong></p><p>参考资料: <a href="https://blog.csdn.net/h12kjgj/article/details/73496528" target="_blank" rel="noopener">(转)Java 正确的做字符串编码转换</a></p><blockquote><p>那么，如何利用getBytes 和 new String() 来进行编码转换呢？ 网上流传着一种错误的方法:<br>GBK–&gt; UTF-8: new String( s.getBytes(“GBK”) , “UTF-8); ,这种方式是完全错误的，因为getBytes 的编码与 UTF-8 不一致，肯定是乱码。<br>但是为什么在tomcat 下，使用 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 却可以用呢？ 答案是：<br>tomcat 默认使用iso-8859-1编码， 也就是说，如果原本字符串是GBK的，tomcat传输过程中，将GBK转成iso-8859-1了，<br>默认情况下，使用iso-8859-1读取中文肯定是有问题的，那么我们需要将iso-8859-1 再转成GBK， 而iso-8859-1 是单字节编码的，<br>即他认为一个字节是一个字符， 那么这种转换不会对原来的字节数组做任何改变，因为字节数组本来就是由单个字节组成的，<br>如果之前用GBK编码，那么转成iso-8859-1后编码内容完全没变， 则 s.getBytes(“iso-8859-1”) 实际上还是原来GBK的编码内容<br>则 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 就可以正确解码了。 所以说这是一种巧合。</p></blockquote><h3 id="getReader-getInputStream-读取-Body-内容"><a href="#getReader-getInputStream-读取-Body-内容" class="headerlink" title="getReader(), getInputStream() 读取 Body 内容"></a>getReader(), getInputStream() 读取 Body 内容</h3><p><code>HttpServletRequest</code>上有<code>getReader()</code>方法, 可以取得<code>BufferedReader</code>对象, 通过这个对象可以读取请求的 Body 数据.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">readBody</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader reader = request.getReader();</span><br><span class="line">    <span class="comment">// 取得 BufferedReader 对象, 通过该对象可以读取请求的 Body 数据</span></span><br><span class="line">    String input = <span class="keyword">null</span>;</span><br><span class="line">    String requestBody = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> ((input = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBody = requestBody + input + <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestBody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=%E5%BC%A0%E4%B8%89&amp;passed=1234567&amp;login=%E9%80%81%E5%87%BA</span><br></pre></td></tr></table></figure><p></p><p>如果要上传文件, \&lt;form> 标签需要设置<code>enctype</code>属性为: <code>multipart/form-data</code></p><h3 id="getPart-getParts-取得上传文件"><a href="#getPart-getParts-取得上传文件" class="headerlink" title="getPart() , getParts() 取得上传文件"></a>getPart() , getParts() 取得上传文件</h3><p>在Servlet3.0之后, 新增了<code>Part</code>接口, 可以方便的进行文件上传处理, 可以通过<code>HttpServletRequest</code>的<code>getPart()</code>方法并指定名称才能取得<code>Part</code>实现对象.</p><p>Servlet中要设置<code>@MultipartConfig</code>标注才能取得<code>Part</code>对象, 否则会得到<code>null</code>, 仅仅标注<code>@MultipartConfig</code>表示相关属性使用默认值:</p><ul><li><p><code>fileSizeThreshold</code>: 0</p><p>整数值, 若上传文件大小超过设置的值, 会先写入缓存文件</p></li><li><p><code>loaction</code>: 空字符串 “”</p><p>设置写入文件时的目录</p></li><li><p><code>maxFileSize</code>: -1L 不限制大小</p><p>限制上传文件的大小</p></li><li><p><code>maxRequestSize</code>: -1L 不限制请求个数</p><p>限制 <code>multipart/form-data</code>请求个数</p></li></ul><p>也可以使用<code>getParts()</code>来上传多个文件, 该方法返回一个<code>Collection&lt;Part&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">for</span> (Part part : req.getParts()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(part.getName().startsWith(<span class="string">"file"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 使用getName()获取名称, startsWith()判断名称是否以file开头</span></span><br><span class="line">                String filename= getFilename(part);</span><br><span class="line">                part.write(filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在 web.xml 中也可以设置<code>@MultipartConfig</code>属性:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/tmp/<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="使用-RequestDispatcher-调派请求"><a href="#使用-RequestDispatcher-调派请求" class="headerlink" title="使用 RequestDispatcher 调派请求"></a>使用 RequestDispatcher 调派请求</h3><p>在 Web 应用程序中, 经常需要多个 Servlet 来完成请求, 这时可以使用<code>HttpServletRequest</code>的<code>getRequestDispatcher()</code>方法取得<code>RequestDispatcher</code>接口的实例, 调用时只需指定转发或包含相对的URL网址.</p><ol><li><p>使用 include() 方法</p><p><code>RequestDispatcher</code> 的 include() 方法可以将另一个 Servlet 的操作流程包括至目前 Servlet 操作流程之中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher dispatcher = req.getRequestDispatcher(<span class="string">"other.view"</span>);</span><br><span class="line">dispatcher.include(req, resp);</span><br></pre></td></tr></table></figure><p>在取得<code>RequestDispatcher</code>时也可以包括查询字符串, .<code>..(&quot;other.view?data=123456&quot;);</code></p></li><li><p>请求范围属性</p><p>在<code>include()</code>或<code>forward()</code>时如果包括请求参数的做法只适用于传递字符串给另一个Servlet, 在调派请求中, 如果有必须共享的对象, 可以设置请求范围属性</p><p><code>HttpServletRequest</code>上与请求范围属性有关的方法:</p><ul><li><code>setAttribute()</code>: 指定名称与对象设置属性</li><li><code>getAttribute()</code>: 指定名称取得属性</li><li><code>getAttributeNames()</code>: 取得所有属性名称</li><li><code>remoteAttribute()</code>: 指定名称移除属性</li></ul><p>以<code>java.</code>, <code>javax.</code>开头的名称通常保留, 用于表示一些特定的意义:</p><ul><li><code>javax.servlet.include.request_uri</code></li><li><code>javax.servlet.include.context_path</code></li><li><code>javax.servlet.include.servlet_path</code></li><li><code>javax.servlet.include.path_info</code></li><li><code>javax.servlet.include.query_string</code></li></ul><p>在被包含的 Servlet 中分别表示上一个 Servlet 的 Request URI, Context path, Servlet path, Path info 和取得<code>RequestDispatcher</code>时给定的参数</p></li><li><p>使用 forward() 方法</p><p>调用时同样也要传入请求和响应对象, 表示要将请求处理转发给别的 Servlet , 对客户端的响应同时转发给另一个 Servlet</p><p>如果要调用<code>forward()</code>方法, 当前的Servlet中不能有任何响应确认, 如果通过响应对象设置了响应但未确认, 响应设置会全部被忽略, 如果有响应确认了仍调用这个方法, 会抛出<code>IllegalStateException</code></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;从容器到-HttpServlet&quot;&gt;&lt;a href=&quot;#从容器到-HttpServlet&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter2 编写与设置Servlet</title>
    <link href="https://phoenixxc.github.io/posts/92aa08ef/"/>
    <id>https://phoenixxc.github.io/posts/92aa08ef/</id>
    <published>2019-02-11T10:40:34.000Z</published>
    <updated>2019-07-22T12:15:15.349Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h2 id="在-HelloServlet-之后"><a href="#在-HelloServlet-之后" class="headerlink" title="在 HelloServlet 之后"></a>在 HelloServlet 之后</h2><h3 id="关于-HttpServlet"><a href="#关于-HttpServlet" class="headerlink" title="关于 HttpServlet"></a>关于 HttpServlet</h3><p>Servlet 需要的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 Servlet 定义相关的类或接口都位于 javax.servlet 包中</span></span><br><span class="line"><span class="comment">// 与 HTTP 定义先关的类与接口都位于 javax.servlet.http 包中</span></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br></pre></td></tr></table></figure><p>当请求到来时，Web容器会调用 Servlet 的 <code>service()</code> 方法．</p><p>HttpServlet 的 service() 方法的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">servlet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String method = req.getMethod();<span class="comment">// 取得请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        doGet(req, resp);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        doHead(req, resp);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-WebServlet"><a href="#使用-WebServlet" class="headerlink" title="使用@WebServlet"></a>使用@WebServlet</h3><p>在Servlet3.0中，可以使用标注来告诉容器哪些Servlet会提供服务和额外的信息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/hello.view"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="comment">// 告诉容器请求的URL如果是＂/hello.view＂，就由 HelloServlet 的实例来提供服务</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(</span><br><span class="line">name = <span class="string">"Hello"</span>, </span><br><span class="line">    <span class="comment">// 告诉容器这个 Servlet 的名称为 Hello, 默认为 Servlet 类的完整名称</span></span><br><span class="line">    urlPatterns = &#123;<span class="string">"/hello.view"</span>&#125;,</span><br><span class="line">    <span class="comment">// 如果客户端的请求的URL是/hello.view，由这个Servlet的实例来处理</span></span><br><span class="line">    loadOnStartup = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 默认值: -1</span></span><br><span class="line">    <span class="comment">// 容器在首次处理某个Servlet服务时才会初始化对应的Servlet实例，</span></span><br><span class="line">    <span class="comment">// 如果希望应用程序启动时就将Servlet类载入, 实例化并初始化</span></span><br><span class="line">    <span class="comment">// 可以用loadOnStartup设置为大于0的值, 数字小的初始化, 相同的值由容器自定义行为</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="使用Web-xml"><a href="#使用Web-xml" class="headerlink" title="使用Web.xml"></a>使用Web.xml</h3><p>Servlet3.0 之前, 必须通过web.xml来定义Servlet的相关信息, Servlet3.0中也可以用他来定义相关的信息.</p><p>web.xml 中的设置会覆盖 Servlet 中定义的值（name 值要相同）.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--...--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!--名字--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Servlet 是 servlet-class 指定类的实例--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置何时初始化, 值相同按照在web.xml中设置的顺序初始化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloUser.view<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果客户端请求的URL是/helloUser.view, 则由HelloServlet这个Servlet来处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--...--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件组织与部署"><a href="#文件组织与部署" class="headerlink" title="文件组织与部署"></a>文件组织与部署</h3><p>Web程序应用程序文件组织:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── other</span><br><span class="line">│   └── \......</span><br><span class="line">└── web</span><br><span class="line">    ├── index.jsp</span><br><span class="line">    └── WEB-INF</span><br><span class="line">        ├── classes</span><br><span class="line">        │   └── HelloServlet.class</span><br><span class="line">        ├── lib</span><br><span class="line">        └── web.xml</span><br></pre></td></tr></table></figure><ul><li>WEB-INF: 目录名称固定, 该目录对外界封闭, 客户端无法使用HTTP的任何方式直接访问该目录下的文件及目录</li><li>web.xml: 放在WEB-INF根目录下, 名称固定, Web应用程序部署描述文件</li><li>lib: 放置JAR文件的目录, 放在WEB-INF根目录下, 名称固定</li><li>classes: 放置编译后的.class文件的目录, 位于WEB_INF根目录下, 名称固定, 编译后的类文件, 必须有与包名称相符的目录结构</li></ul><p>在部署Web应用程序时, 会将Web应用程序封装为<strong>WAR</strong>文件, 如过服务器使用Tomcat, 可以将war文件放置在tomcat安装目录的<code>webapps</code>目录中, 然后重启Tomcat服务.</p><p>然后可以用: <code>http://(服务器ip或域名):(端口号)/(war文件名)/</code> 来访问</p><h2 id="进阶部署设置"><a href="#进阶部署设置" class="headerlink" title="进阶部署设置"></a>进阶部署设置</h2><p>…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;在-HelloServlet-之后&quot;&gt;&lt;a href=&quot;#在-HelloServlet-之后&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>线程初探</title>
    <link href="https://phoenixxc.github.io/posts/906de7a0/"/>
    <id>https://phoenixxc.github.io/posts/906de7a0/</id>
    <published>2018-08-09T13:30:59.000Z</published>
    <updated>2019-07-22T12:17:30.868Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><h2 id="1-线程"><a href="#1-线程" class="headerlink" title="[1] 线程"></a>[1] 线程</h2><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是计算机独立运行(操作系统分配CPU时间的基本单位)的最小单位，运行时占用很少的系统资源</li><li>单cpu单核：多个线程是交替执行的　多cpu多核：多个线程可以同时运行</li><li>同一进程内的多个线程共享进程的地址空间</li><li>线程之间的切换速度比进程的切换快很多</li><li>进程通信要以专门的通信方式、一个线程的数据可以直接供同一进程的其他线程使用</li></ul><hr><p>线程节约资源、节约时间、可以提高应用程序的响应速度、可以提高多处理器效率、改善程序的结构</p><p>线程在进程内部共享的资源：</p><ul><li>地址空间、打开的文件描述符等待</li></ul><p>线程的私有数据：</p><ul><li>线程号</li><li>寄存器（程序计数器、堆栈指针）</li><li>栈</li><li>信号掩码</li><li>优先级</li><li>私有的存储空间</li><li>自己的错误返回码</li></ul><p>线程有自己的栈但是共享 <strong>堆(heap)</strong></p><blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuYmFja2JsYXplLmNvbS9ibG9nL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE3LzA4L2RpYWdyYW0tdGhyZWFkcy5wbmc" alt="diagram of single and multi-treaded process"></p><p>We talked about the two types of memory available to a process or a thread, the stack and the heap. It is important to distinguish between these two types of process memory because each thread will have its own stack, but all the threads in a process will share the heap.</p><p>——————————————— <a href="https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/" target="_blank" rel="noopener">What’s the Diff: Programs, Processes, and Threads</a></p><hr><ul><li>A thread in execution works with<ul><li>thread ID</li><li>Registers (program counter and working register set)</li><li>Stack (for procedure call parameters, local variables etc.)</li></ul></li><li>A thread shares with other threads a process’s (to which it belongs to)</li><li>Code section</li><li>Data section (static + heap)</li><li>Permissions<ul><li>Other resources (e.g. files)</li></ul></li></ul><p><a href="https://www.seas.upenn.edu/~cit595/cit595s10/lectures/processvsthreads.pdf" target="_blank" rel="noopener">来源2</a></p></blockquote><p>关于线程的具体信息可以看这篇博客　<a href="https://blog.csdn.net/laviolette/article/details/51507642" target="_blank" rel="noopener">Linux 线程的实质</a></p><h2 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="[2] 创建线程"></a>[2] 创建线程</h2><p>在主线程里创建线程后，程序会在创建线程的地方产生分支，变成两个程序来执行，一段代码可以被多个线程执行，线程在地位上是同等的，不存在父线程和子线程的概念</p><p>创建线程的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>参数意义：</p><ul><li>thread : 指向线程标识符的指针</li><li>attr : 可指定线程的属性，如过是NULL则为默认属性</li><li>start_routinez : 是一个函数指针，指向线程创建后要运行的函数，称为线程函数</li><li>arg : 指向要传递给线程函数的参数</li></ul><p>返回值：</p><ul><li>线程创建成功返回0</li><li>失败则返回出错编号</li></ul><p>其他的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);<span class="comment">// 获取本线程的线程ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;<span class="comment">// 比较线程ID</span></span><br><span class="line"><span class="comment">// 如果两个线程为同一线程返回非0值，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;             <span class="comment">// 保证线程函数只执行一次</span></span><br><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="comment">// 成功完成后，pthread_once（）将返回零; 否则，返回错误编号以指示错误。</span></span><br></pre></td></tr></table></figure><p><strong>[实例1]</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">thread</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> newthid;</span><br><span class="line">    newthid = pthread_self();             <span class="comment">// 返回新创建线程的ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is a new thread, thread ID = %u\n"</span>, newthid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main thread, ID is %u\n"</span>, pthread_self());          </span><br><span class="line">    <span class="comment">// 打印主线程ID</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thid, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)thread, <span class="literal">NULL</span>) != <span class="number">0</span>) </span><br><span class="line">    <span class="comment">// 创建一个线程, 创建成功返回 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread creation failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时需要链接 <code>libpthread.a</code> , <code>gcc createthread.c -lpthread</code></p><p>在某些情况，只需要执行一次函数，这时就需要用到 <code>pthread_once()</code></p><p>函数原型中的控制变量once_control必须初始化为 <code>PTHREAD_ONCE_INIT</code>(0), 否则线程函数不会执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is similar to a lock implementation, but we distinguish between three</span></span><br><span class="line"><span class="comment">   states: not yet initialized (0), initialization in progress, and initialization finished; If in the first state, threads will try to run the initialization by moving to the second state;</span></span><br><span class="line"><span class="comment">   the first thread to do so via a CAS on once_control runs init_routine, other threads block.*/</span></span><br></pre></td></tr></table></figure><p><strong>[实例2]</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="comment">// 使用初值为PTHREAD_ONCE_INIT的once_control变量保证</span></span><br><span class="line"><span class="comment">// 函数在本进程执行序列中仅执行一次。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Function run is running in thread %u\n"</span>, pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread1</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid = pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Current thread's  ID is %u\n"</span>, thid);</span><br><span class="line">    pthread_once(&amp;once, run);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread1 ends\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread2</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid = pthread_self();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Current thread's ID is %u\n"</span>, thid);</span><br><span class="line">    pthread_once(&amp;once, run);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread2 ends\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid1, thid2;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thid1, <span class="literal">NULL</span>, thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thid2, <span class="literal">NULL</span>, thread2, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main thread exit!\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程编程环境下，如果pthread_once()调用出现在多个线程中，init_routine()函数仅执行一次，但究竟在哪个线程中执行是由内核调度来决定的。</p><p>两种情况：</p><p><img src="https://img-blog.csdn.net/20180809212429551?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1YW5jYm0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><hr><h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><p>线程创建函数的第二个参数的类型为: pthread_attr_t, 结构体定义为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> detachstate;<span class="comment">// 线程的分离状态</span></span><br><span class="line">    <span class="keyword">int</span> schedpolicy;<span class="comment">// 线程的调度策略</span></span><br><span class="line">    <span class="keyword">int</span> schedparam;<span class="comment">// 线程的调度参数</span></span><br><span class="line">    <span class="keyword">int</span> inheritsched;<span class="comment">// 线程的继承性</span></span><br><span class="line">    <span class="keyword">int</span> scope;<span class="comment">// 线程的作用域</span></span><br><span class="line">    <span class="keyword">int</span> guardsize;<span class="comment">// 线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="keyword">int</span> stackaddr_set;<span class="comment">// 堆栈地址集</span></span><br><span class="line">    <span class="keyword">int</span> stackaddr;<span class="comment">// 堆栈的大小</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;<span class="comment">// 堆栈的大小</span></span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure><p>如果第二个参数为空，线程会采用默认的属性，绝大多数情况下不需要为线程特殊指定其属性。线程的属性只能在线程创建的时候指定，线程创建完成之后其属性不能被更改。</p><p>默认属性:</p><table><thead><tr><th><strong>属性</strong></th><th><strong>值</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>scope</td><td><code>PTHREAD_SCOPE_PROCESS</code></td><td>新线程与进程中的其他线程发生竞争。</td></tr><tr><td>detachstate</td><td><code>PTHREAD_CREATE_JOINABLE</code></td><td>线程退出后，保留完成状态和线程 ID。</td></tr><tr><td>stackaddr</td><td><code>NULL</code></td><td>新线程具有系统分配的栈地址。</td></tr><tr><td>stacksize</td><td>0</td><td>新线程具有系统定义的栈大小。</td></tr><tr><td>priority</td><td>0</td><td>新线程的优先级为 0。</td></tr><tr><td>inheritsched</td><td><code>PTHREAD_INHERIT_SCHED</code></td><td>新线程继承父线程调度优先级。</td></tr><tr><td>schedpolicy</td><td><code>SCHED_OTHER</code></td><td>新线程对同步对象争用使用 Solaris 定义的固定优先级。线程将一直运行，直到被抢占或者直到线程阻塞或停止为止。</td></tr></tbody></table><p>由于线程的属性是不透明的，所以不能直接修改，而需要使用一系列的函数来初始化、配置、销毁。</p><p>参考资料：</p><ul><li><a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node29.html" target="_blank" rel="noopener">[1]Creating a (Default) Thread</a></li><li><a href="https://docs.oracle.com/cd/E19253-01/819-7051/6n919hpac/index.html" target="_blank" rel="noopener">[2]多线程编程指南 &gt; 第 3 章 线程属性 &gt; 属性对象</a></li></ul><p><strong>初始化/销毁线程属性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_attr_t</span> tattr;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="comment">/* initialize an attribute to the default value */</span></span><br><span class="line">ret = pthread_attr_init(&amp;tattr);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 如果成功会返回0, 失败返回非0的错误代码</span></span><br></pre></td></tr></table></figure><p>初始化线程属性的时候系统会给属性对象分配内存，为了避免内存泄漏，当线程属性不再使用后应当调用pthread_attr_destroy()来释放分配的内存，销毁线程属性并不会影响创建时候使用了该线程属性的线程。当线程属性被销毁之后可以重新初始化它，但对已销毁的线程属性对象的任何使用的结果都是未定义的。</p><p><strong>线程栈大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> *stacksize)</span></span>;</span><br></pre></td></tr></table></figure><p>默认情况下由系统设定栈的大小，可以用命令来查看系统的默认设置 <code>ulimit -s</code></p><p><strong>设置栈的大小不是可移植的</strong></p><p><strong>线程分离属性</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set/get detach state attribute in thread attributes object</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;  </span><br><span class="line"><span class="comment">// On success, these functions return 0; on error, they  return  a  nonzero  error number.</span></span><br></pre></td></tr></table></figure><p>pthread_attr_setdetachstate()中detachstate的值有两种：</p><ul><li>PTHREAD_CREATE_DETACHED</li><li>PTHREAD_CREATE_JOINABLE(默认属性)</li></ul><p>如果是PTHREAD_CREATE_JOINABLE，需要调用　pthread_join 或 pthread_detach来释放资源(线程的描述信息和stack)。调用pthread_detach的过程是不可逆的。</p><p><a href="https://www.jianshu.com/p/3bda7f6134bb" target="_blank" rel="noopener">可连接和分离的线程 | Joinable and Detached Threads</a></p><p><strong>线程栈溢出保护区大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setguardsize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> guardsize)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getguardsize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> *guardsize)</span></span>;</span><br></pre></td></tr></table></figure><p>当我们使用线程栈超过了设定大小之后，系统还会使用部分扩展内存(guardsize大小)来防止栈溢出。</p><p>如果没有guardsize，当一个线程的栈溢出到其他的区域，该区域又是可写的，会造成不可预料的后果，而且覆盖了那部分内存之后也不会产生任何错误或者是信号。</p><p>这种情况很难确定应该为栈分配多大的内存。</p><p>当设置了guardsize之后，如果栈溢出后尝试写入这部分内存，会给进程发送信号并且终止它。</p><p><a href="https://stackoverflow.com/questions/34802140/what-is-guard-size-in-posix" target="_blank" rel="noopener">What is guard size in Posix?</a></p><p><strong>线程竞争CPU的范围</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getscope</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">int</span> *contentionscope)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setscope</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> contentionscope)</span></span>;</span><br></pre></td></tr></table></figure><p>POSIX 定义了两个值:</p><ul><li>PTHREAD_SCOPE_SYSTEM: 与系统中的所有线程一起竞争</li><li>PTHREAD_SCOPE_PROCESS:只与同进程的线程竞争</li></ul><p><strong>线程调度策略</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getschedpolicy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *policy)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setschedpolicy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> policy)</span></span>;</span><br></pre></td></tr></table></figure><p>进程的调度策略和优先级属于主线程，设置进程的调度策略和优先级只会影响主线程的调度策略和优先级。每一个对等线程能够拥有它自己的独立于主线程的调度策略和优先级。</p><p>在 Linux 系统中，进程有三种调度策略：SCHED_FIFO(实时、先入先出)、SCHED_RR(实时、轮转) 和 SCHED_OTHER（正常、非实时）（默认属性）。</p><p><strong>线程继承的调度策略</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getinheritsched</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *inheritsched)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setinheritsched</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> inheritsched)</span></span>;</span><br></pre></td></tr></table></figure><p>在 pthread 库中，提供了一个函数，用来设置被创建的线程的调度属性：是从创建者线程继承调度属性（调度策略和优先级以及竞争范围），还是从属性对象设置调度属性。该函数就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pthread_attr_setinheritsched (pthread_attr_t * attr, int    inherit) 当中，inherit 的值为下列值中的其一：</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">PTHREAD_INHERIT_SCHED, <span class="comment">//线程调度属性从创建者线程继承（默认属性）</span></span><br><span class="line"> PTHREAD_EXPLICIT_SCHED <span class="comment">//线程调度属性设置为 attr 设置的属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设在创建新的线程时，调用该函数将參数设置为 PTHREAD_INHERIT_SCHED 时，那么当改动进程的优先级时。该进程中继承这个优先级而且还没有改变其优先级的所有线程也将会跟着改变优先级。</p><p><strong>线程调度參数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getschedparam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, struct sched_param *param)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setschedparam</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">const</span> struct sched_param *param)</span></span>;  </span><br><span class="line"><span class="comment">//sched_param结构体  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> sched_priority;     <span class="comment">/* Scheduling priority */</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sched_priority　仅当调度策略为(SCHED_RR 或 SCHED_FIFO)时才有效，默认为0</p><h2 id="3-线程终止"><a href="#3-线程终止" class="headerlink" title="[3] 线程终止"></a>[3] 线程终止</h2><p>有两种终止线程的方式：</p><ul><li>通过 return 从线程返回</li><li>调用函数 pthread_exit() 使线程退出</li></ul><h4 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit()"></a>pthread_exit()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_exit - terminate calling thread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure><p>两种特殊情况：</p><ul><li>如果从 main() 函数返回或调用了 exit 函数退出了主线程，则整个进程将会终止，进程终端所有线程也会终止，故主线程不能过早的从　main 函数返回。</li><li>如果主线程调用了 pthread_exit 函数，仅仅是主线程消亡，进程不会结束，进程内的其他线程也不会结束直至所有的线程结束</li></ul><h4 id="线程的取消"><a href="#线程的取消" class="headerlink" title="线程的取消"></a>线程的取消</h4><p>线程可以创建也可以取消，一个线程可以向另一个线程发送结束请求，实现这种机制用到了一个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_cancel - send a cancellation request to a thread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>函数执行成功返回0,失败返回非零的错误码。</p><p><strong>函数执行成功并不意味着所要请求的线程会被取消</strong>，另一个线程接受到取消的请求后，具体行为依赖于线程的类型和状态(tyep and state)。</p><p>线程的state和type可以通过下面两个函数来设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>state</strong></p><ul><li><p>enabled(默认)[PTHREAD_CANCEL_ENABLE]</p><p>如果是这种状态，线程会取消，但何时取消依赖于type的值</p></li></ul><ul><li><p>disabled[PTHREAD_CANCEL_DISABLE]</p><p>线程会继续执行</p></li></ul><p><strong>type:</strong></p><ul><li><p>deferred(默认)[PTHREAD_CANCEL_DEFERRED]－－同步</p><p>state如果为enabled，线程会继续执行，当遇到取消点的时候退出</p><p>POSIX 标准规定了一些函数作为取消点，当线程调用这些函数的时候就会结束，具体函数可以查看 man 7 pthreads</p></li></ul><ul><li><p>asynchronous[PTHREAD_CANCEL_ASYNCHRONOUS]－异步</p><p>state为enabled的情况下，type为这个值意味着线程可以在任何时候取消，当线程收到取消请求后，通常会立即退出</p></li></ul><h4 id="临界资源的释放"><a href="#临界资源的释放" class="headerlink" title="临界资源的释放"></a>临界资源的释放</h4><blockquote><p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。 对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。</p></blockquote><p>临界资源在一段时间内只能被一个线程所持有，当线程要访问临界资源的时候需要提出请求，如果该资源没有被使用则申请成功，否则等待。临界资源使用完后需要释放以供其他线程使用。当一个线程终止时，如果不释放线程所占有的临界资源，则该资源还会被认为被使用中，如果另一个线程在等待使用这个临界资源，那它可能会无限等待下去，形成了<strong>死锁</strong>。</p><p>Linux 系统提供了一对函数：<code>pthread_cleanup_push()、pthread_cleanup_pop()</code> 来自动释放资源，两个函数以宏定义提供，所以两个程序必须成对出现且位于同一代码段才能通过编译。</p><blockquote><p>pthread_cleanup_push()/pthread_cleanup_pop()采用先入后出的栈结构管理，void routine(void *arg)函数在调用pthread_cleanup_push()时压入清理函数栈，多次对pthread_cleanup_push()的调用将在清理函数栈中形成一个函数链，在执行该函数链时按照压栈的相反顺序弹出。execute参数表示执行到pthread_cleanup_pop()时是否在弹出清理函数的同时执行该函数，为0表示不执行，非0为执行；这个参数并不影响异常终止时清理函数的执行。</p></blockquote><blockquote><p>如果线程处于<strong>PTHREAD_CANCEL_ASYNCHRONOUS</strong>状态，上述代码段就有可能出错，因为CANCEL事件有可能在pthread_cleanup_push()和pthread_mutex_lock()之间发生，或者在pthread_mutex_unlock()和pthread_cleanup_pop()之间发生，从而导致清理函数unlock一个并没有加锁的mutex变量，造成错误。因此，在使用清理函数的时候，都应该暂时设置成<strong>PTHREAD_CANCEL_DEFERRED</strong>模式。</p><p><a href="https://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part4/index.html" target="_blank" rel="noopener">Posix线程编程指南(4)</a></p></blockquote><h4 id="等待线程的结束"><a href="#等待线程的结束" class="headerlink" title="等待线程的结束"></a>等待线程的结束</h4><p>函数pthread_join()用来等待线程的结束，其函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_join - join with a terminated thread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_join() 的调用者会被挂起睡眠，等待thread线程的结束，如果retval不为NULL，则这个值即为调用pthread_exit()的参数，如果线程是被取消的，retval的值是PTHREAD_CANCELED。测试了一下如果线程是return返回的话retval的值为0;</p><p>一个线程只允许一个线程使用pthread_join来等待他的结束，否则第一个接收到的线程成功返回，其他调用这个函数的线程返回错误代码 ESRCH.</p><p>thread 这个线程的状态必须是可join的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assisthread</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am helping to do some jobs\n"</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> assistthid;  </span><br><span class="line">    <span class="keyword">int</span>       status;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;assistthid, <span class="literal">NULL</span>, (<span class="keyword">void</span>*) assisthread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(assistthid, (<span class="keyword">void</span>* )&amp;status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"assisthread's exit is caused %d\n"</span>, status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;1-线程&quot;&gt;&lt;a href=&quot;#1-线程&quot; class=&quot;headerlink&quot; title=&quot;[1] 线程&quot;&gt;&lt;/a&gt;[1] 线程&lt;/h2
      
    
    </summary>
    
      <category term="Linux C" scheme="https://phoenixxc.github.io/categories/Linux-C/"/>
    
    
      <category term="Linux C" scheme="https://phoenixxc.github.io/tags/Linux-C/"/>
    
  </entry>
  
  <entry>
    <title>readline库的简单使用</title>
    <link href="https://phoenixxc.github.io/posts/3faf94c3/"/>
    <id>https://phoenixxc.github.io/posts/3faf94c3/</id>
    <published>2018-08-05T14:44:23.000Z</published>
    <updated>2019-07-22T12:13:48.844Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><p>&emsp;&emsp;这周要实现一个简单的 shell, 平时使用bash, zsh这些shell的时候, 如果文件名或命令太长，又或者要频繁执行几条命令的话，最常用的应该就是tab键补全和上下键切换历史命令了。</p><p>&emsp;&emsp;想要在自己的shell里面实现这两个功能很困难，但有一个Ｃ语言库集成了这些功能，只需要调用几个函数就可以实现这两个功能。</p><p>&emsp;&emsp;<a href="https://tiswww.case.edu/php/chet/readline/rltop.html" target="_blank" rel="noopener">The GNU Readline Library</a></p><p>&emsp;&emsp;可以在这里找到有关 <code>readline</code> 库的相关资料和下载地址，软件包里面也提供了很多手册和示例。</p><p><img src="/images/2019-01-26-readline-1.png" alt="upload successful"></p><p>&emsp;&emsp;实现shell用到的函数不是很多，tab键补全，上下键切换历史命令，添加历史命令等等</p><h1 id="readline"><a href="#readline" class="headerlink" title="readline()"></a>readline()</h1><p>&emsp;&emsp;在 <code>readline.h</code> 里可以找到关于他的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Readline functions. */</span></span><br><span class="line"><span class="comment">/* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">char</span> *readline <span class="title">PARAMS</span><span class="params">((<span class="keyword">const</span> <span class="keyword">char</span> *))</span></span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;readline() 的参数是一个字符串，调用函数的时候会在屏幕上输出，这个函数会读取一行输入，然后返回一个指向输入字符串的指针，readline 会为输入的字符串动态分配内存，所以使用完之后需要free掉。</p><p>&emsp;&emsp;下面举一个简单的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;readline/readline.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> * str = readline(<span class="string">"Myshell $ "</span>);</span><br><span class="line">        <span class="built_in">free</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&emsp;&emsp;由于readline是一个动态库，编译的时候需要加上　<code>-lreadline</code>，不然会找不到相关的函数<br>当我们按下tab键之后发现就可以实现bash里面的补全功能了。</p><p><img src="/images/2019-01-26-readline-2.png" alt="upload successful"></p><p>&emsp;用惯了zsh后发现黑白的提示符好难看，于是也想着给里面的参数加上颜色。C语言中输出有颜色的字符printf就可以实现，模板类似这样<code>printf(&quot;\033[47;31m string \033[0m&quot;);</code></p><p>&emsp;&emsp;47是背景色，31是字符的颜色，string 是要输出的字符串，\033[5m 是ANSI控制码，意思是关闭输出的属性，不然以后的输出都会是之前设置的颜色。相关的内容网上有很多可以自行查阅。</p><p>&emsp;&emsp;为了方便使用，加上了这些宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOSE <span class="meta-string">"\033[0m"</span>                 <span class="comment">// 关闭所有属性</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOD  <span class="meta-string">"\033[1m"</span>                 <span class="comment">// 强调、加粗、高亮</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGIN(x,y) <span class="meta-string">"\033["</span>#x<span class="meta-string">";"</span>#y<span class="meta-string">"m"</span>    <span class="comment">// x: 背景，y: 前景</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在修改一下readline()这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * str = readline(BEGIN(<span class="number">49</span>, <span class="number">34</span>)<span class="string">"Myshell $ "</span>CLOSE);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后编译运行：</p><p><img src="/images/2019-01-26-readline-3.png" alt="upload successful"><br>&emsp;&emsp;似乎一切完美，但当我们输入很长很长的字符串之后：&emsp;&emsp;</p><p><img src="/images/2019-01-26-readline-4.png" alt="upload successful"></p><p>&emsp;&emsp;emmmm……………输入太多会导致提示符被输入覆盖，写个shell出现这种状况岂不是贼尴尬</p><p>&emsp;&emsp;查资料查了很久才找到解决方法：这个bug需要在非打印字符前后加上　<code>\001</code> 和　<code>\002</code> 才能解决</p><p>&emsp;&emsp;其实头文件就有提到</p><p><img src="/images/2019-01-26-readline-5.png" alt="upload successful"></p><p>&emsp;&emsp;在之前定义的宏里面加上这两个字符之后终于解决了</p><p><img src="/images/2019-01-26-readline-6.png" alt="upload successful"></p><p>&emsp;&emsp;最后的代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;readline/readline.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOSE <span class="meta-string">"\001\033[0m\002"</span>                 <span class="comment">// 关闭所有属性</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOD  <span class="meta-string">"\001\033[1m\002"</span>                 <span class="comment">// 强调、加粗、高亮</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BEGIN(x,y) <span class="meta-string">"\001\033["</span>#x<span class="meta-string">";"</span>#y<span class="meta-string">"m\002"</span>    <span class="comment">// x: 背景，y: 前景</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> * str = readline(BEGIN(<span class="number">49</span>, <span class="number">34</span>)<span class="string">"Myshell $ "</span>CLOSE);</span><br><span class="line">        <span class="built_in">free</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;readline使用的时候默认了tab补全，但是我们平时用到的shell不但可以补全文件名，还可以补全命令。readline库当然也提供了这个功能，具体如何使用可以看这篇博客。</p><p>&emsp;&emsp;<a href="https://www.cnblogs.com/hazir/p/instruction_to_readline.html" target="_blank" rel="noopener">GNU Readline 库及编程简介</a></p><p>&emsp;&emsp;单独的使用readline()并没有上下键切换补全的功能，实现这个需要用到另一个函数 - <code>add_history()</code></p><h1 id="history-h"><a href="#history-h" class="headerlink" title="history.h"></a>history.h</h1><p>&emsp;&emsp;上下键切换需要我们把输入的字符串加入到历史命令中，需要调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Place STRING at the end of the history list.</span></span><br><span class="line"><span class="comment">   The associated data field (if any) is set to NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> add_history <span class="title">PARAMS</span><span class="params">((<span class="keyword">const</span> <span class="keyword">char</span> *))</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数接受一个字符串作为参数存入到历史文件中，函数的定义在history.h中，使用的时候需要包含头文件 &lt;readline/history.h&gt;</p><p>&emsp;&emsp;我们在代码中加入这个函数的调用就可以使用上下键切换历史命令了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * str = readline(BEGIN(<span class="number">49</span>, <span class="number">34</span>)<span class="string">"Myshell $ "</span>CLOSE);</span><br><span class="line">add_history(str);</span><br><span class="line"><span class="built_in">free</span>(str);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译后测试了一下发现功能完美运行。</p><p>&emsp;&emsp;但是关掉程序在尝试一下发现，诶？我不能切换到上一次运行程序的历史命令，只能记录本次运行中输入的命令。然后开始查看头文件的内容，发现了不少和history有关的函数。</p><p>&emsp;&emsp;其中有两个正好用的上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the contents of FILENAME to the history list, a line at a time.</span></span><br><span class="line"><span class="comment">   If FILENAME is NULL, then read from ~/.history.  Returns 0 if</span></span><br><span class="line"><span class="comment">   successful, or errno if not. */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> read_history <span class="title">PARAMS</span><span class="params">((<span class="keyword">const</span> <span class="keyword">char</span> *))</span></span>;</span><br><span class="line"><span class="comment">/* Write the current history to FILENAME.  If FILENAME is NULL,</span></span><br><span class="line"><span class="comment">   then write the history list to ~/.history.  Values returned</span></span><br><span class="line"><span class="comment">   are as in read_history ().  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> write_history <span class="title">PARAMS</span><span class="params">((<span class="keyword">const</span> <span class="keyword">char</span> *))</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>read_history()</code>和<code>write_history()</code>都接受一个字符串做参数，成功返回０，错误则把相应的错误码赋值给errno。</p><p>&emsp;&emsp;两个函数接受的参数都是一个文件名，read_history() 从指定的文件中读取历史记录，write_history() 将历史记录存入指定的文件。如果参数为NULL默认的文件是：<code>~/.history</code></p><p>&emsp;&emsp;有了这个函数，我们只要在程序最开处加上read_history(NULL), add_history(str)之后加上 write_history() 就可以了。</p><p>&emsp;&emsp;这样下次运行程序的时候我们就可以找到上次运行的历史命令了。</p><p>&emsp;&emsp;shell 的内置命令不多，cd 是一个, history也是一个shell内置的命令。</p><p><img src="/images/2019-01-26-readline-7.png" alt="upload successful"></p><p>&emsp;&emsp;readline既然可以把输入加入历史，读入和写进历史，那么自然可以读取历史文件列表，头文件中我们可以找到这样一个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return a NULL terminated array of HIST_ENTRY which is the current input history.  Element 0 of this list is the beginning of time.  If there is no history, return NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> HIST_ENTRY **history_list <span class="title">PARAMS</span><span class="params">((<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个函数可以查看存储的 history 列表，HIST_ENTRY　是一个结构体类型，存储了很多信息：&emsp;&emsp;</p><p><img src="/images/2019-01-26-readline-8.png" alt="upload successful"></p><p>&emsp;&emsp;我们要的历史内容就存储在 <code>data</code> 元素里面。</p><p>&emsp;&emsp;这个函数返回一个数组，以空指针为结束标志，我们简单封装一下就可以实现一个自己 shell 内置的 <code>history</code> 函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowHistory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    HIST_ENTRY ** his;</span><br><span class="line">    his = history_list();</span><br><span class="line">    <span class="keyword">while</span>(his[i] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, his[i]-&gt;line);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;history.h 里面提供了很多函数，我们的要实现一个简单的shell用到的函数上面都提到过，更多的函数可以在官方文档里面查看。</p><p>&emsp;&emsp;realine 这个库很强大，现在只是发现了他的冰山一角，提供的功能远远超过上述所说的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这周要实现一个简单的 shell, 平时使用bash, zsh这些shell的时候, 如果文件名或命令太长，又或者要频繁执行几
      
    
    </summary>
    
      <category term="Linux C" scheme="https://phoenixxc.github.io/categories/Linux-C/"/>
    
    
      <category term="readline" scheme="https://phoenixxc.github.io/tags/readline/"/>
    
      <category term="Linux C" scheme="https://phoenixxc.github.io/tags/Linux-C/"/>
    
  </entry>
  
  <entry>
    <title>实现简单ls命令遇到问题的总结</title>
    <link href="https://phoenixxc.github.io/posts/e262bfcf/"/>
    <id>https://phoenixxc.github.io/posts/e262bfcf/</id>
    <published>2018-07-29T07:58:44.000Z</published>
    <updated>2019-07-22T12:17:30.868Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --><p>这周要写一个小项目，利用《linux C 编程实战》第6章的内容实现一个简单的 <code>ls</code> 命令，写的时候出现很多问题，现在将问题总结一下。</p><p>要实现的ls命令需要实现 -l, -a , -A 等参数。<br>我们在终端测试一下系统的ls命令:<br><img src="https://img-blog.csdn.net/201807281506434?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1YW5jYm0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="ls -example1"><br><img src="https://img-blog.csdn.net/20180728150806193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1YW5jYm0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="ls - example2"></p><p>可以发现系统的ls可以根据终端的宽度来调整输出列数，而不至于输出的内容由于终端大小的限制显示不全。</p><p>如果想要实现类似的功能，首先需要获取终端的宽度，然后计算输出文件列表的最大列数，最后按列将文件输出到屏幕上。</p><h4 id="终端宽度的获取"><a href="#终端宽度的获取" class="headerlink" title="终端宽度的获取"></a>终端宽度的获取</h4><p>查了很多，发现书上提到的 <code>int ioctl(int fd, int cmd, ...)</code>可以实现这个功能, 先放出代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取终端宽度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ter_size</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">w</span>;</span></span><br><span class="line">    ioctl(STDOUT_FILENO, TIOCGWINSZ, &amp;w);</span><br><span class="line">    <span class="keyword">return</span> w.ws_col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ioctl</code> 可以控制特殊设备文件的属性，第一个参数是一个以及打开的文件描述符，<code>STDOUT_FILENO</code> 是标准输出的<strong>POSIX</strong> 名称，他的文件描述符是1，可以在 <code>unistd.h</code> 找到它的宏定义。使用<code>man 2 ioctl_tty</code> 可以查询到其他两个参数的信息：<br><img src="https://img-blog.csdn.net/20180728151709322?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1YW5jYm0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p><code>TIOCGWINSZ</code> 是一个获取终端大小的命令，w是一个<code>struct winsize</code> ，其中的 <code>w.ws_col</code> 就存储了我们想得到的终端宽度。</p><h4 id="计算输出列表的最大列数"><a href="#计算输出列表的最大列数" class="headerlink" title="计算输出列表的最大列数"></a>计算输出列表的最大列数</h4><p>没想出来有什么比较好的方法来通过已经给定的一系列字符串和一个限制宽度来求出在这个宽度限制内输出的最大列数。<br>所以最后决定暴力穷举，将列数从大到小一个一个的尝试。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cal_Print</span><span class="params">(<span class="keyword">char</span> b[][NAME_MAX + <span class="number">10</span>], <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span>       <span class="comment">// 暴力运算, 求出打印的列数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// b 是一个二维数组，存储了要计算宽度的文件名</span></span><br><span class="line">    <span class="keyword">int</span> t = get_ter_size();         <span class="comment">// 终端宽度</span></span><br><span class="line">    <span class="keyword">int</span> i = n &lt; MAX_C ? n : MAX_C;  <span class="comment">// 设定最大列数初始值</span></span><br><span class="line">    <span class="keyword">int</span> length;                     <span class="comment">// 计算字符串长度</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        a[j] = <span class="built_in">strlen</span>(b[j]);</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c = n % i ? (n / i + <span class="number">1</span>) : (n / i);</span><br><span class="line">        <span class="keyword">if</span> ((i - <span class="number">1</span>) * c &gt;= n)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len[MAX_C] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = j * c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; c &amp;&amp; k &lt; n; m++, k++)</span><br><span class="line">                <span class="keyword">if</span> (a[k] &gt; max_len[j])</span><br><span class="line">                    max_len[j] = a[k];</span><br><span class="line">            length += max_len[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j != i - <span class="number">1</span>)</span><br><span class="line">                length += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; t)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">if</span> (!i)</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>得到终端宽度后，在代码中我限制了最大宽度为25(MAX_C), 这个数差不多足够了，之后如果文件的总数小于最大宽度，那么就从文件的总数n开始穷举（毕竟最多也就一个文件名放一列）。<br>有了总数n和列i之后，很简单就能计算出行。</p><p>计算每一列字符串最大的长度后加起来，再算上分割列之间的 （i-1)×2 的空格，如果总长度不大于终端宽度，这个列数就是我们所需要的。</p><p>计算完行数之后还会有一个问题，我们是为了解决在终端中按行打印文件名的问题，打印出来的结果只有最后一列可以空几个文件名，也就是要保证除了最后一列其他列都要填满。所以加上一个判断条件：<code>if ((i - 1) * c &gt;= n) continue;</code></p><p>在计算 <code>max_len[j]</code> 一定要注意加上 <code>k &lt; n</code> 这个条件，不然如果在 <code>i * c &gt; n</code> 的情况下数组会越界。<br>还有一种极端情况：终端宽度太小，导致最后算出的 i 值为0, 这种情况就讲i的值设为1，默认输出一列。</p><h4 id="按列输出"><a href="#按列输出" class="headerlink" title="按列输出"></a>按列输出</h4><p>由于要以整齐的方式按列输出 需要我们之前计算过的字符串长度，为了方便我们直接在计算完列数之后就输出文件目录：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> kneed = c - i * c + n;<span class="comment">// 最后一列的行数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; c; p++)             <span class="comment">// c 行数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">0</span>; o &lt; i - <span class="number">1</span>; o++)     <span class="comment">// i 列数 先输出前 i-1 列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, b[p + o*c]);</span><br><span class="line">PrintB(max_len[o] - a[p + o*c]);</span><br><span class="line">        PrintB(<span class="number">2</span>);                      <span class="comment">// 输出空格以整齐排列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kneed)                          <span class="comment">// 如果最后一列的第p行有内容就输出</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, b[p + (i<span class="number">-1</span>) * c]);</span><br><span class="line">        kneed--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p></p><p>代码中我用了PrintB(int num)来输出空格， 也可以简单一点使用<code>printf</code> 的 <code>*</code> 修饰符来控制格式<br><code>printf(&quot;%s%*s&quot;, b[p + o*c], max_len[o] - a[p + o*c] + 2, &quot; &quot;);</code></p><p>最开始以为这么弄就应该没问题了，也测试过输出格式，但是emmmm…..<br>如果文件名里面有中文的话，strlen会把中文识别为3个字节，但是一个中文其实差不多只占两个，如果文件名有中文的话会导致很严重的排版错误。。。。</p><p>具体可以看一下这两篇博客：<br><a href="https://whoisnian.com/2018/01/24/Linux%E4%B8%8Bls%E5%91%BD%E4%BB%A4%E6%8E%92%E7%89%88/" target="_blank" rel="noopener">https://whoisnian.com/2018/01/24/Linux%E4%B8%8Bls%E5%91%BD%E4%BB%A4%E6%8E%92%E7%89%88/</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p><blockquote><p>UTF-8 的编码规则很简单，只有二条：<br>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。<br>2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自 https://whoisnian.com/2018/01/24/Linux%E4%B8%8Bls%E5%91%BD%E4%BB%A4%E6%8E%92%E7%89%88/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Str_UTF</span><span class="params">(<span class="keyword">char</span> * str)</span>     <span class="comment">// 只占两个宽度的中文字符会识别为三个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">'\0'</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str &gt; <span class="number">0</span>)       <span class="comment">// 如果是单字节符号(这里指 英文符号)，正常计算长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            str++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// n字节的符号（n &gt; 1），第一个字节的前n位都设为1</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (!((*str &gt;&gt; i) &amp; <span class="number">1</span>))  <span class="comment">// 右移运算，把第 n+1 位上的０恰好移到 这个字节的最后一位，第7 ~ i+1次,　最后一位会是１</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            num += <span class="number">2</span>;           <span class="comment">// 中文按两个字节算</span></span><br><span class="line">            str += <span class="number">7</span> - i;       <span class="comment">// 跳过这个中文符号(占用7-i个字节)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手写一个strlen之后就可以正常显示了。</p><p>在这里也吐槽下中文字符排序的问题，以前一直认为中文排序可以用strcmp来解决，这次写ls命令测试发现中文的编码比较乱，而且涉及到多音字的问题，中文的排序比较复杂，不是直接比较编码就能搞定的。</p><h4 id="写-ls-R-时关于递归的问题"><a href="#写-ls-R-时关于递归的问题" class="headerlink" title="写 ls -R 时关于递归的问题"></a>写 ls -R 时关于递归的问题</h4><p>最开始在实现 -R 参数的时候用了递归，其中解析文件属性用了 stat() 函数。<br>但是在测试递归主目录的时候发现了一个很严重的问题，平时用 stat 和 lstat 的区别就是在链接文件的识别上，一个识别链接文件指向的文件，另一个是链接文件本身。</p><p>我的主目录下有一个文件夹：<br><code>/home/username/.deepinwine/Deepin-TIM/dosdevices</code><br>查看具体属性后：<br><code>lrwxrwxrwx 1 username username 1 7月 26 19:28 z: -&gt; /</code></p><p>emm… 这个文件是指向系统根目录的，如果递归到这个文件会出现无限死循环。。。。<br>当然递归时候也需要注意跳过<code>.</code> 和 <code>..</code> 这两个特殊目录。。<br>不然也会出现无限递归死循环的问题。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Aug 18 2019 16:54:01 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;这周要写一个小项目，利用《linux C 编程实战》第6章的内容实现一个简单的 &lt;code&gt;ls&lt;/code&gt; 命令，写的时候出现很多问题，现在将问题
      
    
    </summary>
    
      <category term="Linux C" scheme="https://phoenixxc.github.io/categories/Linux-C/"/>
    
    
      <category term="Linux C" scheme="https://phoenixxc.github.io/tags/Linux-C/"/>
    
  </entry>
  
</feed>
