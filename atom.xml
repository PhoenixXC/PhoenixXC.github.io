<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pxBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://phoenixxc.github.io/"/>
  <updated>2020-06-06T01:54:34.213Z</updated>
  <id>https://phoenixxc.github.io/</id>
  
  <author>
    <name>PhoenixBM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BASE理论</title>
    <link href="https://phoenixxc.github.io/posts/d302a974/"/>
    <id>https://phoenixxc.github.io/posts/d302a974/</id>
    <published>2020-06-06T01:36:18.000Z</published>
    <updated>2020-06-06T01:54:34.213Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><p>由于分布式数据库的结构特性，根据分布式系统的 <strong>CAP定理</strong>，实现 <strong>ACID</strong> 事务需要付出很大的成本来维护可用性，所以为了保障可用性而总结出一套弱化的事务特性：</p><ul><li><strong>基本可用</strong>（<strong>B</strong>asically <strong>A</strong>vailable）：系统能够基本运行、一直提供服务。</li><li><strong>软状态</strong>（<strong>S</strong>oft-state）：系统不要求一直保持强一致状态。</li><li><strong>最终一致性</strong>（<strong>E</strong>ventual consistency）：系统需要在某一时刻后达到一致性要求。</li></ul><p>简称<strong>BASE</strong>，与ACID相对应（acid为“酸”的英文名称，base为“碱”的英文名称）。</p><h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p><ol><li><strong>响应时间上的损失</strong>：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。</li><li><strong>功能上的损失</strong>：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ol><h3 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h3><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p><p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。</p><p>而在实际工程实践中，最终一致性分为5种：</p><h4 id="因果一致性（Causal-consistency）"><a href="#因果一致性（Causal-consistency）" class="headerlink" title="因果一致性（Causal consistency）"></a>因果一致性（Causal consistency）</h4><p>因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。</p><h4 id="读己之所写（Read-your-writes）"><a href="#读己之所写（Read-your-writes）" class="headerlink" title="读己之所写（Read your writes）"></a>读己之所写（Read your writes）</h4><p>读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p><h4 id="会话一致性（Session-consistency）"><a href="#会话一致性（Session-consistency）" class="headerlink" title="会话一致性（Session consistency）"></a>会话一致性（Session consistency）</h4><p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p><h4 id="单调读一致性（Monotonic-read-consistency）"><a href="#单调读一致性（Monotonic-read-consistency）" class="headerlink" title="单调读一致性（Monotonic read consistency）"></a>单调读一致性（Monotonic read consistency）</h4><p>单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p><h4 id="单调写一致性（Monotonic-write-consistency）"><a href="#单调写一致性（Monotonic-write-consistency）" class="headerlink" title="单调写一致性（Monotonic write consistency）"></a>单调写一致性（Monotonic write consistency）</h4><p>单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p><blockquote><p>在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。</p></blockquote><p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p><p>作者：零壹技术栈<br>链接：<a href="https://juejin.im/post/5b2663fcf265da59a401e6f8" target="_blank" rel="noopener">https://juejin.im/post/5b2663fcf265da59a401e6f8</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><blockquote><p><strong>参考资料</strong>：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93#%E4%BA%8B%E5%8A%A1%E6%80%A7%E8%B4%A8" target="_blank" rel="noopener">分布式数据库</a>#事务性质</li><li><a href="https://juejin.im/post/5b2663fcf265da59a401e6f8" target="_blank" rel="noopener">分布式理论二—BASE理论</a></li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;由于分布式数据库的结构特性，根据分布式系统的 &lt;strong&gt;CAP定理&lt;/strong&gt;，实现 &lt;strong&gt;ACID&lt;/strong&gt; 事务需要
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://phoenixxc.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CAP理论</title>
    <link href="https://phoenixxc.github.io/posts/6940af88/"/>
    <id>https://phoenixxc.github.io/posts/6940af88/</id>
    <published>2020-06-06T01:04:16.000Z</published>
    <updated>2020-06-06T01:54:34.217Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/Teorema-CAP-2.png" alt="Teorema-CAP-2"></p><p><strong><em>CAP</em></strong> 定理，又被称为 <strong>布鲁尔定理</strong>，指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li><p><strong>一致性</strong>（<strong>*C**</strong>onsistency*）</p><p>所有节点都能访问同一份最新的数据副本</p><blockquote><p><strong>三种一致性策略</strong></p><ul><li><p>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。</p></li><li><p>如果能容忍后续的部分或者全部访问不到，则是弱一致性。</p></li><li><p>如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</p></li></ul><p>CAP中说，不可能同时满足的这个一致性指的是 <u>强一致性</u>。</p></blockquote></li><li><p><strong>可用性</strong>（<strong>*A**</strong>valiablity*）</p><p>每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据，服务一直可用且是正常响应时间。</p><blockquote><p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</p><p>| 可用性分类 | 可用水平（%） | 年可容忍停机时间 |<br>| :————————–: | :———–: | :————–: |<br>| 容错可用性 | 99.9999 | &lt;1 min |<br>| 极高可用性 | 99.999 | &lt;5 min |<br>| 具有故障自动恢复能力的可用性 | 99.99 | &lt;53 min |<br>| 高可用性 | 99.9 | &lt;8.8h |<br>| 商品可用性 | 99 | &lt;43.8 min |</p><p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。</p></blockquote></li><li><p><strong>分区容错性</strong>（<strong>*P**</strong>artition tolerance*）</p><p>分布式系统在某节点或网络分区故障的时候，仍然能够堆外提供满足一致性和可用性的服务</p></li></ul><p>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</p><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。</p><p>理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p><blockquote><p><strong>参考资料</strong>：</p><ul><li><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">维基百科—CAP定理</a></li><li><a href="http://www.hollischuang.com/archives/666" target="_blank" rel="noopener">分布式系统的CAP理论</a></li></ul></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/Teorema-CAP-2
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://phoenixxc.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习</title>
    <link href="https://phoenixxc.github.io/posts/5c6cd659/"/>
    <id>https://phoenixxc.github.io/posts/5c6cd659/</id>
    <published>2020-06-05T09:19:00.000Z</published>
    <updated>2020-06-05T09:25:29.857Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/av93824064?p=148&amp;t=553" target="_blank" rel="noopener">阳哥带你学spring cloud</a></p><p>代码地址：<a href="https://github.com/PhoenixXC/LearnJava/tree/master/SpringCloud/ShangGuiGu" target="_blank" rel="noopener">https://github.com/PhoenixXC/LearnJava/tree/master/SpringCloud/ShangGuiGu</a></p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h4 id="版本对应关系"><a href="#版本对应关系" class="headerlink" title="版本对应关系"></a>版本对应关系</h4><p>浏览器访问：<a href="https://start.spring.io/actuator/info" target="_blank" rel="noopener">https://start.spring.io/actuator/info</a></p><p>可以获得版本的详细对应关系</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200428101353.png" alt></p><p><strong>视频版本推荐</strong></p><table><thead><tr><th>组件</th><th>版本</th></tr></thead><tbody><tr><td><strong><em>cloud</em></strong></td><td>Hoxton.SR1</td></tr><tr><td><strong><em>boot</em></strong></td><td>2.2.2.RELEASE</td></tr><tr><td><strong><em>cloud alibaba</em></strong></td><td>2.1.0.RELEASE</td></tr><tr><td><strong><em>Java</em></strong></td><td>Java 8</td></tr><tr><td><strong><em>Maven</em></strong></td><td>3.5+</td></tr><tr><td><strong><em>MySQL</em></strong></td><td>5.7+</td></tr></tbody></table><h4 id="Cloud-停更"><a href="#Cloud-停更" class="headerlink" title="Cloud 停更"></a>Cloud 停更</h4><ul><li>被动修复 bugs</li><li>不接受合并请求</li><li>不再发布新版本</li></ul><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200428103817.png" alt></p><h4 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h4><p>查看官网文档/社区中文版。</p><h2 id="架构搭建"><a href="#架构搭建" class="headerlink" title="架构搭建"></a>架构搭建</h2><ul><li><u>约定 &gt; 配置 &gt; 编码</u></li></ul><h4 id="微服务模块的创建"><a href="#微服务模块的创建" class="headerlink" title="微服务模块的创建"></a>微服务模块的创建</h4><ol><li>建立 <em>module</em></li><li>修改 <em>pom</em></li><li>编写 <em>YML</em></li><li>主启动</li><li>业务类</li></ol><h4 id="热部署的开启"><a href="#热部署的开启" class="headerlink" title="热部署的开启"></a>热部署的开启</h4><blockquote><p>热部署在开发阶段中使用，不要在生产环境中使用</p></blockquote><ol><li><p>项目中添加 <strong><em>devtools</em></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 <em>pom.xml</em> 中添加插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>cloud-provider-payment8001<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 热部署 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启用 <strong><em>automatic build</em></strong></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200501152323.png" alt></p></li><li><p>更新值</p><ul><li><p>Idea 中 <kbd>CTRL+SHIFT+ALT+/</kbd> ：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200501152546.png" alt></p></li><li><p>点击 <kbd>Registry</kbd></p></li><li><p>将框住的选项打钩</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200501152709.png" alt></p></li></ul></li><li><p>重启 IDEA</p></li></ol><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p><strong>服务治理</strong>：</p><p>管理服务之间的依赖关系，可以实现服务调用，负载均衡、容错等，实现服发现和注册</p><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><h4 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h4><ul><li><p><strong><em>Eureka Server</em></strong></p><ul><li><p>服务注册</p><p>将服务信息注册进注册中心</p></li><li><p>服务发现</p><p>从注册中心上获取服务信息，实质：存 <code>key</code> 服务名，取 <code>value</code> 调用地址</p></li></ul></li><li><p><strong><em>Service Provider</em></strong></p><ol><li>先启动 <em>eureka</em> 注册中心</li><li>启动服务提供者</li><li>服务提供者将自身的信息注册进 eureka</li></ol></li><li><p><strong><em>Service Consumer</em></strong></p><ol><li>消费者在需要调用接口时，使用服务别名去注册中心获取实际的 RPC 远程调用地址</li><li>消费者获取调用地址后，底层利用 <code>HttpClient</code> 技术实现远程调用</li><li>消费者获取服务地址后会缓存在本地 Jvm 内存中，默认每隔 30 秒更新一次服务调用地址</li></ol></li></ul><h4 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h4><p><strong>原因</strong>：</p><ul><li>某时刻某一个微服务不可用了，Eureka 不会立刻清理，依旧会保留微服务信息</li><li>CAP 理论中的 AP 分支</li></ul><p><strong>如何关闭</strong>：</p><ul><li><code>yml</code> 中设置 <code>eureka.server.eable-self-preservation=false</code></li></ul><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul><li><p>引入 zookeeper-discovery</p></li><li><p>排除自带的 zookeeper，引入版本合适的 zookeeper</p></li><li><p>yml文件配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line">    <span class="comment"># 微服务注册名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    zookeeper:</span></span><br><span class="line"><span class="attr">      connect-string:</span> <span class="number">169.22</span><span class="number">.2</span><span class="number">.2</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure></li><li><p>SpringBoot 启动类加上注解：<code>@EnableDiscoveryClient</code></p></li></ul><p>启动服务后，在 /services 下面会有有服务名称相同的节点，里面有一个临时节点存储了服务注册的信息。</p><blockquote><p>Zookeeper 没有自我保护机制</p></blockquote><h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><p>Go 语言编写</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>服务注册</li><li>健康检查</li><li>KV存储</li><li>安全</li><li>多数据</li></ul><h3 id="三个注册中心异同"><a href="#三个注册中心异同" class="headerlink" title="三个注册中心异同"></a>三个注册中心异同</h3><table><thead><tr><th>组件</th><th>语言</th><th>CAP</th><th>服务健康检查</th><th>对外暴露端口</th><th>SpringCloud集成</th></tr></thead><tbody><tr><td>Eureka</td><td>Java</td><td>AP</td><td>可配</td><td>HTTP</td><td>集成</td></tr><tr><td>Consul</td><td>Go</td><td>CP</td><td>支持</td><td>HTTP/DNS</td><td>集成</td></tr><tr><td>Zookeeper</td><td>Java</td><td>CP</td><td>支持</td><td>客户端</td><td>集成</td></tr></tbody></table><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200503182951.png" alt></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200503183041.png" alt></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><h4 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h4><p>将用户的请求平摊的分配到多个服务上，从而达到系统的 HA （高可用）。</p><p>常见的负载均衡有软件 Nginx，LVS，硬件 F5 等</p><h4 id="本地负载均衡客户端-vs-Nginx-服务端负载均衡"><a href="#本地负载均衡客户端-vs-Nginx-服务端负载均衡" class="headerlink" title="本地负载均衡客户端 vs Nginx 服务端负载均衡"></a>本地负载均衡客户端 vs Nginx 服务端负载均衡</h4><p>Nginx 是服务器负载均衡，客户端说起有请求都会交给 Nginx，然后由 Nginx 实现请求转发。</p><p>Ribbon 本地负载均衡，在调用微服务接口的时候，会在注册中心上获取注册信息服务列表之后缓存到 JVM 本地，从而在本地实现 RPC 远程服务调用技术。</p><h4 id="集中式-vs-进程内"><a href="#集中式-vs-进程内" class="headerlink" title="集中式 vs 进程内"></a>集中式 vs 进程内</h4><ul><li><p>集中式</p><p>在服务的消费方和提供方之间使用独立的 LB 设施，由该设施负责把访问请求通过某种策略转发至服务的提供方。</p></li><li><p>进程内</p><p>将 LB 集成到消费方</p></li></ul><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><p>Ribbon 是一个软负债均衡的客户端组件，可以和其他客户端配合使用。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200504102930.png" alt></p><p>工作分为两步：</p><ol><li>先选择 EurekaServer，优先选择在同一个区域内负债较少的 server</li><li>根据用户指定的策略，在从 server 取到的服务注册列表中选择一个地址。</li></ol><blockquote><p>Ribbon 提供了多种策略，轮训、随机和根据响应时间加权等</p></blockquote><blockquote><p>引入 Eureka 的时候，默认引入了 Ribbon</p></blockquote><h4 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a>IRule</h4><p>Ribbon 内置了很多负载均衡策略：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200504104253.png" alt></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200504104403.png" alt></p><h4 id="替换负载均衡算法"><a href="#替换负载均衡算法" class="headerlink" title="替换负载均衡算法"></a>替换负载均衡算法</h4><ol><li><p>创建自定义配置</p><blockquote><p>自定义配置类不能放在 <code>@CompoentScan</code> 所扫描的包以及子包下，否则这个自定义的配置类就会被所有的 Ribbon 客户端共享，达不到特殊化定制的目的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主启动类添加 <code>@RibbonClient</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>, configuration = MySelfRule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain80</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain80.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="负载均衡算法原理"><a href="#负载均衡算法原理" class="headerlink" title="负载均衡算法原理"></a>负载均衡算法原理</h4><ul><li><p>轮训</p><p>rest 接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启后 rest 从1开始计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger nextServerCyclicCounter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> AVAILABLE_ONLY_SERVERS = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ALL_SERVERS = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(RoundRobinRule.class);</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoundRobinRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nextServerCyclicCounter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoundRobinRule</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setLoadBalancer(lb);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"no load balancer"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">        <span class="keyword">int</span> upCount = reachableServers.size();</span><br><span class="line">        <span class="keyword">int</span> serverCount = allServers.size();</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">            log.warn(<span class="string">"No up servers available from load balancer: "</span> + lb);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);</span><br><span class="line">        server = allServers.get(nextServerIndex);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"No available alive servers after 10 tries from load balancer: "</span></span><br><span class="line">                + lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inspired by the implementation of &#123;<span class="doctag">@link</span> AtomicInteger#incrementAndGet()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modulo The modulo to bound the value of the counter.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The next value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = nextServerCyclicCounter.get();</span><br><span class="line">        <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">        <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="手写负载均衡算法"><a href="#手写负载均衡算法" class="headerlink" title="手写负载均衡算法"></a>手写负载均衡算法</h4><p>原理 + <strong><em>JUC</em></strong>(CAS + 自旋锁)</p><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><h3 id="OpenFegin"><a href="#OpenFegin" class="headerlink" title="OpenFegin"></a>OpenFegin</h3><p>Fegin 是一个声明式的 WebService 客户端，使用 Fegin 可以让客户端更加简单。</p><p>使用方法：定义一个服务接口然后在上面添加注解，支持可拔插式的编码器和解码器。</p><p>SpringCloud 对 Fegin 进行了封装，使其支持 Spring MVC 标准注解和 HttpMessgaeConverts。Fegin 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡</p><hr><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200603185418.png" alt></p><h4 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      default:</span></span><br><span class="line">        <span class="comment"># 建立链接后从服务器读取到可用资源所用的时间</span></span><br><span class="line"><span class="attr">        connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 两端建立连接所用的时间</span></span><br><span class="line"><span class="attr">        readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="comment"># 设置日志类型，打印</span></span><br><span class="line"><span class="attr">        loggerLevel:</span> <span class="string">full</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line">    <span class="string">com.example.springcloud.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/3.0.0.M1/reference/html/#configuration-properties" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/3.0.0.M1/reference/html/#configuration-properties</a></p></blockquote><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>官网文档有，yml 中配置 config 或创建一个 config bean</p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><blockquote><ul><li><p><strong><em>Hystrix</em></strong></p><p>目前停更，但是用处很多，非常重要</p></li><li><p>resillience4j</p><p>国外用的多</p></li><li><p><strong>sentinel</strong></p><p>ali牛掰</p></li></ul></blockquote><p>复制分布式系统结构中的应用有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200603185448.png" alt></p><h4 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h4><p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”。</p><p>如果扇出的链路上某个微服务的调用响应时间过长或不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，导致“<strong>雪崩效应</strong>”。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200603185459.png" alt></p><h4 id="服务降级（fallback）"><a href="#服务降级（fallback）" class="headerlink" title="服务降级（fallback）"></a>服务降级（fallback）</h4><p><strong>导致服务降级的原因</strong>：</p><ul><li><p>程序运行异常</p></li><li><p>超时</p></li><li><p>服务熔断触发服务降级</p></li><li><p>线程池/信号量打满也会导致服务降级</p></li></ul><h4 id="服务熔断（break）"><a href="#服务熔断（break）" class="headerlink" title="服务熔断（break）"></a>服务熔断（break）</h4><p>达到最大服务访问后，直接决绝访问，调用服务降级的方法返回友好提示。</p><h4 id="服务限流（flowlimit）"><a href="#服务限流（flowlimit）" class="headerlink" title="服务限流（flowlimit）"></a>服务限流（flowlimit）</h4><p>秒杀高并发等操作，严禁一起来，先排队，一秒n个，有序进行</p><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200603185509.png" alt></p><h4 id="做用"><a href="#做用" class="headerlink" title="做用"></a>做用</h4><ul><li><p>服务降级</p></li><li><p>服务熔断</p></li><li><p>接近实时监控</p></li></ul><h4 id="服务降级-Pratice"><a href="#服务降级-Pratice" class="headerlink" title="服务降级 Pratice"></a>服务降级 Pratice</h4><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200515094751515.png" alt="image-20200515094751515"></p><p>使用注解 <code>@HystrixCommand</code></p><ul><li><p>8001</p><p>设置自身调用时间的峰值，峰值内可以正常运行</p><p>超过了需要有兜底的方法处理，作服务降级 fallback</p></li></ul><p><strong>服务端</strong>：</p><p>主启动类上添加：<code>@EnableCircuitBreaker</code></p><p>服务上添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentInfoTimeoutHandler"</span>, commandProperties = &#123;</span><br><span class="line">        <span class="comment">// 设置线程的超时时间为3秒</span></span><br><span class="line">        <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"3000"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfoTimeout</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> timeNumber = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// int age = 10 / 0;</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(timeNumber);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"线程池："</span> + Thread.currentThread().getName() + <span class="string">" paymentInfoTimeout"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfoTimeoutHandler</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"线程池："</span> + Thread.currentThread().getName() + <span class="string">" paymentInfoTimeoutHandler, :("</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是运行超时还是服务异常，都会使用 fallback</p><p>服务降级既可以加在客户端，也可以加载服务端，<strong>一般加载客户端</strong></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200603185518.png" alt></p><p><strong>客户端</strong>：</p><p>主启动类加上注解：<code>@EnableHystrix</code></p><p>服务上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"paymentInfoTimeoutFallbackMethod"</span>, commandProperties = &#123;</span><br><span class="line">        <span class="comment">// 设置线程的超时时间为3秒</span></span><br><span class="line">        <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"1500"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/order/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfoTimeout</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    String result = paymentHystrixService.paymentInfoTimeout(id);</span><br><span class="line">    log.info(<span class="string">"--- result: "</span> + result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfoTimeoutFallbackMethod</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Sorry, I'm consumer80, service busy, please wait some time try again"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>存在的问题</strong>：</p><ul><li>Fallback 代码与业务代码耦合</li><li>代码膨胀</li></ul><p><strong>解决方式</strong>：</p><p>大部分用通用 Fallback，类上配置注解：<code>@DefaultProperties(defaultFallback = &quot;paymentTimeoutFallbackMethod&quot;)</code></p><p>需要降级的方法上直接 <code>@HystrixCommand</code></p><p>通用 Fallback 的返回值要兼容，<strong>且不能有参数</strong></p><p>同时为了处理代码耦合，由于需要降级处理的都是来自 OpenFeign 的那个接口，所以可以让 Feign 开启 Hyxtrix，实现该接口，并在接口注解上指定实现类作为 fallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span>, fallback = PaymentFallbackService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/ok/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">paymentInfoOk</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/hystrix/timeout/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">paymentInfoTimeout</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackService</span> <span class="keyword">implements</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfoOk</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"--- PaymentFallbackService OK, :("</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfoTimeout</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"--- PaymentFallbackService Timeout, :("</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># feign 开启 hystrix</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样当失败时，会调用指定的接口实现类中对应的方法，而且不会处理htstrixCommand指定的的fallback。</p><h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200603185525.png" alt></p><p>三种状态：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200515152956331.png" alt="image-20200515152956331"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200515155510923.png" alt="image-20200515155510923"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200515163840134.png" alt="image-20200515163840134"></p><p><strong>断路器起作用的条件</strong>：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200515163939132.png" alt="image-20200515163939132"></p><p>如果断路器开启：</p><p><img src="../../../%25E6%25A1%258C%25E9%259D%25A2/SpringCloud/image-20200515164145277.png" alt="image-20200515164145277"></p><p>进入半开启：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200515164118122.png" alt="image-20200515164118122"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200515164215423.png" alt="image-20200515164215423"></p><h4 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h4><ul><li><p>都要添加 actutor 依赖</p></li><li><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200515170200727.png" alt="image-20200515170200727"></p></li><li><p>被监控服务注入一个bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 配置服务器监控默认路径</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">     ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">     registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">     registrationBean.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">     registrationBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">     <span class="keyword">return</span> registrationBean;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>打开监控页面，输入服务url:hystrix.stream</p></li></ul><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200515171249066.png" alt="image-20200515171249066"></p><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><p>zuul 停更，计划 zuul2，3名作者被挖走，大佬撕逼，导致 zuul2 夭折，Spring 社区受不了自己弄了 <em>gateway</em>。</p><h3 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h3><p><img src="../../../%25E6%25A1%258C%25E9%259D%25A2/SpringCloud/image-20200516101744716.png" alt="image-20200516101744716"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516101811035.png" alt="image-20200516101811035"></p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li>反向代理</li><li>鉴权</li><li>流量控制</li><li>熔断</li><li>日志监控</li></ul><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516102122254.png" alt="image-20200516102122254"></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>Neflix 一直跳票，Gateway 由 SpringCloud 研发，集成度更好。</p><p>Gateway 基于异步非阻塞模型开发，性能优秀。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516102413660.png" alt="image-20200516102413660"></p><hr><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516102444142.png" alt="image-20200516102444142"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516102613937.png" alt="image-20200516102613937"></p><h4 id="Zuul-模型"><a href="#Zuul-模型" class="headerlink" title="Zuul 模型"></a>Zuul 模型</h4><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516102658309.png" alt="image-20200516102658309"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516102745956.png" alt="image-20200516102745956"></p><h4 id="Gateway-1"><a href="#Gateway-1" class="headerlink" title="Gateway"></a>Gateway</h4><p>使用了 WebFlux ：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516102851959.png" alt="image-20200516102851959"></p><h4 id="路由-Route"><a href="#路由-Route" class="headerlink" title="路由(Route)"></a>路由(Route)</h4><p>是构建网关的基本模块，由 ID、目标 URI、一系列的断言和过滤器组成，如果断言为 true 则匹配该路由。</p><h4 id="断言-Predicate"><a href="#断言-Predicate" class="headerlink" title="断言(Predicate)"></a>断言(Predicate)</h4><p>参考 Java8 的 <em>java.util.function.Predicate</em></p><p>开发人员可以匹配 HTTP 请求中的所有内容（如请求参数和请求头），如果请求与断言相匹配则进行路由</p><h4 id="过滤-Filter"><a href="#过滤-Filter" class="headerlink" title="过滤(Filter)"></a>过滤(Filter)</h4><p>指的是 Spring 框架中 <em>GateFilter</em> 的实例，使用过滤器，可以在请求被路由前或路由后进行修改。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516103449631.png" alt="image-20200516103449631"></p><h4 id="Gateway-工作流程"><a href="#Gateway-工作流程" class="headerlink" title="Gateway 工作流程"></a>Gateway 工作流程</h4><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516103538800.png" alt="image-20200516103538800"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516103620470.png" alt="image-20200516103620470"><strong>核心逻辑</strong>：路由转发 ＋执行过滤器链</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li><p>导入 Gateway</p></li><li><p>移除 starter-web 这个包，如果需要 web 支持，可以导入 starter-webflux</p></li><li><p>配置（静态）</p><ul><li><p><em>yaml</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">payment_routh</span>  <span class="comment"># 路由ID，要求唯一，建议配合服务名</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://localhost:8001</span> <span class="comment"># 匹配后提供的路由地址</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/payment/get/**</span>   <span class="comment"># 断言</span></span><br><span class="line"></span><br><span class="line"><span class="attr">        - id:</span>  <span class="string">payment_routh</span>  <span class="comment"># 路由ID，要求唯一，建议配合服务名</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">http://localhost:8001</span> <span class="comment"># 匹配后提供的路由地址</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/payment/lb/**</span></span><br></pre></td></tr></table></figure></li><li><p>创建Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder routeLocatorBuilder)</span> </span>&#123;</span><br><span class="line">    RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes();</span><br><span class="line"></span><br><span class="line">    routes.route(<span class="string">"path_route_xcphoenix"</span>,</span><br><span class="line">                 r -&gt; r.path(<span class="string">"/guonei"</span>)</span><br><span class="line">                 .uri(<span class="string">"https://news.baidu.com/"</span>));</span><br><span class="line">    <span class="keyword">return</span> routes.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置（动态）</p><blockquote><p>静态路由会写死 url，但是多数情况下是要部署集群的，这就需要通过微服务名实现动态路由</p></blockquote><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516115113746.png" alt="image-20200516115113746"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">cloud-gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        locator:</span></span><br><span class="line">          <span class="comment"># 开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line"><span class="attr">          enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      routes:</span></span><br><span class="line"><span class="attr">        - id:</span> <span class="string">payment_routh</span>  <span class="comment"># 路由ID，要求唯一，建议配合服务名</span></span><br><span class="line"><span class="comment">#          uri: http://localhost:8001 # 匹配后提供的路由地址</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">lb://CLOUD-PAYMENT-SERVICE</span> <span class="comment"># 匹配后提供微服务的路由地址</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/payment/get/**</span>   <span class="comment"># 断言</span></span><br><span class="line">          </span><br><span class="line"><span class="attr">        - id:</span>  <span class="string">payment_routh2</span>  <span class="comment"># 路由ID，要求唯一，建议配合服务名</span></span><br><span class="line"><span class="comment">#          uri: http://localhost:8001 # 匹配后提供的路由地址</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">lb://CLOUD-PAYMENT-SERVICE</span></span><br><span class="line"><span class="attr">          predicates:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">Path=/payment/lb/**</span>   <span class="comment"># 断言</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p>官方提供了很多 Predicate：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516150541277.png" alt="image-20200516150541277"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516150737648.png" alt="image-20200516150737648"></p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516152508447.png" alt="image-20200516152508447"></p><p>自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGatewayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"---------- come in myLogGatewayFilter"</span>);</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">"uname"</span>);</span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"----- 非法用户"</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级，值越小优先级越高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务配置"><a href="#服务配置" class="headerlink" title="服务配置"></a>服务配置</h2><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516160221957.png" alt="image-20200516160221957"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516160250739.png" alt="image-20200516160250739"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516160520534.png" alt="image-20200516160520534"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516160531750.png" alt="image-20200516160531750"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516160555219.png" alt="image-20200516160555219"></p><p>The HTTP service has resources in the following form:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure><p>where <code>application</code> is injected as the <code>spring.config.name</code> in the <code>SpringApplication</code> (what is normally <code>application</code> in a regular Spring Boot app), <code>profile</code> is an active profile (or comma-separated list of properties), and <code>label</code> is an optional git label (defaults to <code>master</code>.)</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516200826226.png" alt="image-20200516200826226"></p><blockquote><p>不管是 <code>.yml</code> 还是 <code>.properties</code> 都可以通过 <u>xxxx.yml</u> 或 <u>xxxx.properties</u>。</p><p>其中 <code>/{application}/{profile}[/{label}]</code> 这种格式返回的是一个 <code>json</code> 字符串</p><p>其他四种返回的都是对应的文件内容</p><blockquote><p>如果访问一个不存在的配置，那么返回一个表示错误的 <code>json</code> 字符串</p></blockquote></blockquote><h4 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h4><ul><li><p><strong><em>maven</em></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><em>yml</em></strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">cloud-config-center</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="string">/home/xuanc/桌面/LearnJava/SpringCloud/ShangGuiGu/springcloud-config</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>可以使用 git 或者文件路径，git 可以需要配置用户名和密码，git 地址，仓库名等</p></li></ul><h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><ul><li><p><strong><em>maven</em></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 写错就是一个坑 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 <code>bootstrap.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">3355</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config-client</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">config</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">http://config3344:3344</span></span><br><span class="line">      </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    server-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://eureka7001:7001/eureka</span></span><br></pre></td></tr></table></figure></li><li><p>code</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;config.info&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String configInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/configInfo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>config.info</code> 来自 <em>config</em>-<em>server</em> 中配置的信息（git或文件中的数据），客户端通过配置向服务端发送请求，获取到：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;"name":"config","profiles":["dev"],"label":"master","version":"e7b77b33bada2e2812236072305022642242c58b","state":null,"propertySources":[&#123;"name":"/home/xuanc/桌面/LearnJava/SpringCloud/ShangGuiGu/springcloud-config/config-dev.yml","source":&#123;"config.info":"master branch,springcloud-config/config-dev.yml version=1"&#125;&#125;]&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>并取出其中的 propertySources 与添加到客户端的环境属性中，这样客户端可以直接通过 <code>config.info</code> 去访问配置信息</p></blockquote></li></ul><h4 id="boostrap-yml"><a href="#boostrap-yml" class="headerlink" title="boostrap.yml"></a>boostrap.yml</h4><p><code>application.yml</code> 是用户级</p><p><code>bootstrap.yml</code> 是系统级的，优先级更高</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200516202814953.png" alt="image-20200516202814953"></p><h4 id="配置刷新"><a href="#配置刷新" class="headerlink" title="配置刷新"></a>配置刷新</h4><p>当文件发生变化后（git 需要 commit 才行），服务端可以感知到变化并更新配置，客户端不能立马感知。</p><p><strong>设置动态刷新</strong>：</p><ol><li><p>引入 <code>actuator</code> 模块</p></li><li><p>暴露监控端点</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure></li><li><p>控制类加上 <code>@RefreshScope</code></p></li><li><p>发送 POST 刷新 <code>http://localhost:3355/actuator/refresh</code></p></li></ol><blockquote><p>缺点：</p><ul><li>不能广播，批量刷新，同时保证精确刷新</li></ul></blockquote><h2 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h2><h3 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h3><p>为了解决上面的动态刷新的问题，引入了 SpringCloud Bus</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200517173045025.png" alt="image-20200517173045025"></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/image-20200517201055956.png" alt="image-20200517201055956"></p><p>第二种架构更加合适，第一种：</p><ul><li>破坏了微服务的职责单一性，微服务本身是业务模块，不应该承担配置刷新的职责</li><li>破坏了微服务各节点的对等性</li><li>有一定的局限性，比如当微服务迁移时，网络地址和常常会发生变化</li></ul><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605161303.png" alt></p><p>Bus 支持两种 MQ：RabbitMQ、Kafka</p><h4 id="Config自动刷新步骤"><a href="#Config自动刷新步骤" class="headerlink" title="Config自动刷新步骤"></a>Config自动刷新步骤</h4><blockquote><p>基于上面的手动刷新</p></blockquote><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Bus: RabbitMQ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要amqp以及actuator依赖</p></li><li><p>yaml 配置 RabbitMQ</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置rabbitmq</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">  host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">  password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>前两部分服务端和客户端都要配置</p><ol start="3"><li><p>服务端暴露端点</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbitmq相关配置，暴露bus刷新配置的端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure></li><li><p><kbd>POST</kbd> 请求：<code>http://ip:port/actuator/bus-refresh</code></p><p>这样就可以自动刷新客户端的配置（控制器要有 <code>@RefreshScope</code>）</p></li></ol><h4 id="定点通知"><a href="#定点通知" class="headerlink" title="定点通知"></a>定点通知</h4><p>在上面配置完成后，如果需要定点刷新，可以发送 POST <code>/actuator/bus-refresh/{destination}</code></p><p>服务端收到请求后，会通过参数来指定需要更新配置的服务或实例</p><h2 id="Cloud-Stream"><a href="#Cloud-Stream" class="headerlink" title="Cloud Stream"></a>Cloud Stream</h2><blockquote><p>常用的 MQ（消息中间件）</p><ul><li><em>ActiveMQ</em></li><li><em>RabbitMQ</em></li><li><em>RocketMQ</em></li><li><em>Kafka</em></li></ul><hr><p>MQ 太多，如果服务用到多个 MQ，那么切换、维护、开发都会带来困难</p><p>所以需要一种适配绑定的方式，自动的在各种 MQ 切换</p><p>那么 <strong><em>springcloud stream</em></strong> 就可以屏蔽 MQ 的细节</p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型。</p><p>Spring Cloud Stream 是一个构建消息驱动微服务的框架。</p><p>应用程序通过 inputs 和 outputs 来与 Spring Cloud Stream 中 binder 对象交互</p><p>所以，只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。</p><p>通过使用 Spring Integration 来连接消息代理中间件以实现消息事件驱动。</p><p>Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引发了发布-订阅、消费组、分区的三个核心概念。</p><p>目前仅支持：RabbitMQ、Kafka</p><blockquote><p>Binder 绑定器是屏蔽 MQ 的核心</p></blockquote><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><h4 id="标准MQ"><a href="#标准MQ" class="headerlink" title="标准MQ"></a>标准MQ</h4><p>生产者/消费者之间靠消息媒介传递消息内容：<strong><em>Message</em></strong></p><p>消息必须走特定的通道：<strong><em>消息通道MessageChannel</em></strong></p><p>消息通道里的消息如何被消费，谁负责收发消息：<strong><em>消息通道的子接口 SubscribableChannel，由 MessageHandler 消息处理器所订阅</em></strong></p><h4 id="为什么用Cloud-Stream"><a href="#为什么用Cloud-Stream" class="headerlink" title="为什么用Cloud Stream"></a>为什么用Cloud Stream</h4><p>如果用到了多个 MQ，多个 MQ 的架构不同，直接使用会导致代码耦合，切换和适配就十分困难。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605161241.png" alt></p><p>通过定义绑定器 Binder 作为中间层，实现了应用程序和消息中间件细节之间的隔离</p><h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><ul><li><p>INPUT</p><p>消费者</p></li><li><p>OUTPUT</p><p>生产者</p></li></ul><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605161229.png" alt></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605161103.png" alt></p><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><p>发布——订阅模式，使用 Topic 主题广播（RabbitMQ -&gt; Exchange，Kafka -&gt; Topic）</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li><p>Binder</p><p>连接中间件，屏蔽差异</p></li><li><p>Channel</p><p>通道，是队列 Queue 的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过 Channel 对队列进行配置</p></li><li><p>可以理解为参照对象是 Spring Cloud Stream 自身，从 Stream 发布消息就是输出，接受消息就是输入</p></li></ul><h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605161023.png" alt></p><h4 id="USE"><a href="#USE" class="headerlink" title="USE"></a>USE</h4><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MQ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Yaml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    stream:</span></span><br><span class="line">      <span class="comment"># 配置需要绑定的 rabbitmq 的服务信息</span></span><br><span class="line"><span class="attr">      binders:</span></span><br><span class="line">        <span class="comment"># 表示定义的名称，用于 binding 整合</span></span><br><span class="line"><span class="attr">        defaultRabbit:</span></span><br><span class="line">          <span class="comment"># 消息组件类型</span></span><br><span class="line"><span class="attr">          type:</span> <span class="string">rabbit</span></span><br><span class="line">          <span class="comment"># mq 环境配置</span></span><br><span class="line"><span class="attr">          enviroment:</span></span><br><span class="line"><span class="attr">            spring:</span></span><br><span class="line"><span class="attr">              rabbitmq:</span></span><br><span class="line"><span class="attr">                host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">                port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">                username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">                password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="comment"># 服务资源整合</span></span><br><span class="line"><span class="attr">      bindings:</span></span><br><span class="line">        <span class="comment"># 通道名，消费端为input</span></span><br><span class="line"><span class="attr">        output:</span></span><br><span class="line">          <span class="comment"># 要使用的 Exchange 名称</span></span><br><span class="line"><span class="attr">          destination:</span> <span class="string">studyExchange</span></span><br><span class="line">          <span class="comment"># 消息类型</span></span><br><span class="line"><span class="attr">          content-type:</span> <span class="string">application/json</span></span><br><span class="line">          <span class="comment"># 设置绑定的消息服务的具体设置</span></span><br><span class="line"><span class="attr">          binder:</span> <span class="string">defaultRabbit</span></span><br></pre></td></tr></table></figure></li><li><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义消息的推送管道</span></span><br><span class="line"><span class="meta">@EnableBinding</span>(Source.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProviderImpl</span> <span class="keyword">implements</span> <span class="title">IMessageProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息发送管道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageChannel output;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String serial = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 发送</span></span><br><span class="line">        output.send(MessageBuilder.withPayload(serial)</span><br><span class="line">                .build());</span><br><span class="line">        log.info(<span class="string">"----&gt; serial: "</span> + serial);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding</span>(Sink.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener</span>(Sink.INPUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">(Message&lt;String&gt; message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"receive: "</span> + message.getPayload() + <span class="string">"\t port: "</span> + serverPort);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>泛型和生产者类型要匹配</p></blockquote></li></ol><h4 id="分组消费和持久化"><a href="#分组消费和持久化" class="headerlink" title="分组消费和持久化"></a>分组消费和持久化</h4><p><strong>重复消费</strong></p><p>如果有多个消费端，会出现消息被重复消费的问题；</p><p>这种就需要用到 <strong>消息分组</strong> 才解决，在 Stream 中，处于同一个 group 的多个消费者是竞争关系，能够保证消息只会被其中一个应用消费一次。</p><p>==不同组是可以重复消费的，同一个组存在竞争关系。==</p><blockquote><p>不配置的话，默认情况下 group 是不同的</p></blockquote><p>设置分组的方法：</p><ul><li><p>修改 yaml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    stream:</span></span><br><span class="line">      <span class="comment"># 配置需要绑定的 rabbitmq 的服务信息</span></span><br><span class="line"><span class="attr">      binders:</span></span><br><span class="line">        <span class="comment"># 表示定义的名称，用于 binding 整合</span></span><br><span class="line"><span class="attr">        defaultRabbit:</span></span><br><span class="line">          <span class="comment"># 消息组件类型</span></span><br><span class="line"><span class="attr">          type:</span> <span class="string">rabbit</span></span><br><span class="line">          <span class="comment"># mq 环境配置</span></span><br><span class="line"><span class="attr">          enviroment:</span></span><br><span class="line"><span class="attr">            spring:</span></span><br><span class="line"><span class="attr">              rabbitmq:</span></span><br><span class="line"><span class="attr">                host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">                port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">                username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">                password:</span> <span class="string">guest</span></span><br><span class="line">      <span class="comment"># 服务资源整合</span></span><br><span class="line"><span class="attr">      bindings:</span></span><br><span class="line">        <span class="comment"># 通道名</span></span><br><span class="line"><span class="attr">        input:</span></span><br><span class="line">          <span class="comment"># 要使用的 Exchange 名称</span></span><br><span class="line"><span class="attr">          destination:</span> <span class="string">studyExchange</span></span><br><span class="line">          <span class="comment"># 消息类型</span></span><br><span class="line"><span class="attr">          content-type:</span> <span class="string">application/json</span></span><br><span class="line">          <span class="comment"># 设置绑定的消息服务的具体设置</span></span><br><span class="line"><span class="attr">          binder:</span> <span class="string">defaultRabbit</span></span><br><span class="line">          <span class="string">＃设置分组</span></span><br><span class="line"><span class="attr">          group:</span> <span class="string">groupA</span></span><br></pre></td></tr></table></figure><p>这样只需要将同一应用的不同实例设置为同一个组就可避免单独消费</p></li></ul><hr><p><strong>持久化</strong>：</p><ul><li>没有配置 group，会导致错过消息</li></ul><h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的结果请求，每一个前端请求都会形成一条复杂的分布式服务调用链路，链路中任何一环出现高延时或错误都会引起请求最后的失败。</p><p>所以需要一套跟踪的框架去追踪。</p><h3 id="Sleuth-amp-Zipkin"><a href="#Sleuth-amp-Zipkin" class="headerlink" title="Sleuth &amp; Zipkin"></a>Sleuth &amp; Zipkin</h3><p>Sleuth 复制搜集，zipkin 图像化呈现</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160938.png" alt></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160918.png" alt></p><h4 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fL -o 'zipkin.jar' 'https://repo1.maven.org/maven2/io/zipkin/zipkin-server/2.21.1/zipkin-server-2.21.1-exec.jar'</span><br><span class="line">java -jar zipkin.jar</span><br></pre></td></tr></table></figure><p>浏览器打开 <u><em>localhost:9411/zipkin</em></u></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Sleuth &amp; zipkin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  zipkin:</span></span><br><span class="line"><span class="attr">    base-url:</span> <span class="attr">http://localhost:9411</span></span><br><span class="line"><span class="attr">  sleuth:</span></span><br><span class="line"><span class="attr">    sampler:</span></span><br><span class="line">      <span class="comment"># 采样率值介于 0 ~ 1，1表示全部收集</span></span><br><span class="line"><span class="attr">      probability:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><p><strong><em>Nacos</em></strong>（<strong><em>Na</em></strong>ming, <strong><em>Co</em></strong>nfiguration，<strong><em>S</em></strong>ervice）</p><p>网址：<em><a href="https://nacos.io/zh-cn/" target="_blank" rel="noopener">https://nacos.io/zh-cn/</a></em></p><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>注册中心＋配置中心 &lt;==&gt; <em>Eureka</em> + <em>Config</em> + <em>Bus</em>（注册+配置+总线）</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul><li>服务注册中心</li><li>服务配置中心</li></ul><h4 id="注册中心比较"><a href="#注册中心比较" class="headerlink" title="注册中心比较"></a>注册中心比较</h4><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160852.png" alt></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160841.png" alt></p><p>Nacos 支持 CP 和 AP 的切换</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160903.png" alt></p><h4 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h4><p>环境：Java8 + Maven</p><p>从 <a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">最新稳定版本</a> 下载 <code>nacos-server-$version.zip</code> 包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip nacos-server-<span class="variable">$version</span>.zip 或者 tar -xvf nacos-server-<span class="variable">$version</span>.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nacos/bin</span><br></pre></td></tr></table></figure><p><strong>Linux/Unix/Mac</strong></p><p>启动命令(standalone代表着单机模式运行，非集群模式):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><p>如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash startup.sh -m standalone</span><br></pre></td></tr></table></figure><p>浏览器打开：<a href="http://localhost:8848/nacos/" target="_blank" rel="noopener">http://localhost:8848/nacos/</a></p><blockquote><p>用户名和密码都是：nacos</p></blockquote><h4 id="服务注册-amp-发现和配置管理"><a href="#服务注册-amp-发现和配置管理" class="headerlink" title="服务注册&amp;发现和配置管理"></a>服务注册&amp;发现和配置管理</h4><p><strong>服务注册</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST 'http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080'</span><br></pre></td></tr></table></figure><p><strong>服务发现</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET 'http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName'</span><br></pre></td></tr></table></figure><p><strong>发布配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld"</span><br></pre></td></tr></table></figure><p><strong>获取配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test</span><br></pre></td></tr></table></figure><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p><strong><em>Nacos</em></strong> 默认支持<u>负载均衡</u></p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>启动服务</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ol start="0"><li><p>父项目添加依赖管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring cloud alibaba 2.1.0.RELEASE --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">nacos-payment-provider</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    nacos:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure></li><li><p>启用服务发现</p><p>主启动类加上注解：<code>@EnableDiscoveryClient</code></p></li><li><p>服务调用</p><p>创建 RestTemplate bean，还需要加上 <code>@LoadBalance</code> 注解添加负载均衡，使用服务名来调用服务</p><hr><blockquote><p>Consumer 的应用可能还没像启动一个 Provider 应用那么简单。因为在 Consumer 端需要去调用 Provider 端提供的REST 服务。例子中我们使用最原始的一种方式， 即显示的使用 LoadBalanceClient 和 RestTemolate 结合的方式来访问。 pom.xml 和 application.properties 的配置可以参考 1.2 小结。启动一个 Consumer应用的示例代码如下所示：</p><p><kbd>Note</kbd> <strong>通过带有负载均衡的RestTemplate 和 FeignClient 也是可以访问的。</strong></p></blockquote></li></ol><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Nacos Config --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Nacos 服务发现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 YAML 配置</p><p>Nacos 与 springcloud-config 一样，在项目初始化时，要先保证从配置中心进行配置拉取</p><p>拉取配置后，才能保证项目的正常启动。</p><p>springboot 配置文件的加载存在优先级，bootstrap 优先级高于 application</p><ul><li><p><em>bootstrap.yml</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">nacos-config-client</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    nacos:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line">        <span class="comment"># Nacos 作为配置中心地址</span></span><br><span class="line"><span class="attr">        server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line">        <span class="comment"># 指定为 yaml 格式</span></span><br><span class="line"><span class="attr">        file-extension:</span> <span class="string">yaml</span></span><br></pre></td></tr></table></figure></li><li><p><em>application.yml</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动类</p><p>与服务注册相同，使用 springcloud 原生注解</p></li><li><p>动态刷新</p><p><code>@Controller</code> 上添加 <code>@RefreshScope</code></p><p>在 Nacos 管理界面更新配置信息后，客户端可以直接感知到配置文件的变化</p></li></ol><blockquote><p><strong>Data ID 命名</strong>：</p><p>在 Nacos Spring Cloud 中，<code>dataId</code> 的完整格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li><code>prefix</code> 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code>来配置。</li><li><code>spring.profile.active</code> 即为当前环境对应的 profile，详情可以参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles" target="_blank" rel="noopener">Spring Boot文档</a>。 <strong>注意：当 <code>spring.profile.active</code> 为空时，对应的连接符 <code>-</code> 也将不存在，dataId 的拼接格式变成 <code>${prefix}.${file-extension}</code></strong></li><li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</li></ul></blockquote><h3 id="分类配置"><a href="#分类配置" class="headerlink" title="分类配置"></a>分类配置</h3><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160823.png" alt></p><p><em>Nacos</em> 类似与 Java 里面的 package 和 类名，最外层的 <em>namespace</em> 可以区分部署环境，Group 和 DataID 逻辑上区分两个目标对象。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160224.png" alt></p><p>默认情况：Namespace=public，Group=DEFAULT_GROUP，Cluster=DEFAULT</p><ul><li><em>Namspace</em> 主要用来实现隔离，比如有开发、测试、生产环境，就可以创建三个 Namespace，不同的 Namespace 之间是隔离的；</li><li><em>Group</em> 可以把不同的微服务划分到同一个分组里面去；</li><li><em>Service</em> 就是微服务，一个 Service 可以包含多个 Cluster，Cluster 是对指定微服务的一个虚拟划分</li></ul><p><kbd style="font-size:1em">Nacos概念</kbd> <em><a href="https://nacos.io/zh-cn/docs/concepts.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/concepts.html</a></em></p><p><strong>命名空间</strong></p><p>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是<strong>不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等</strong>。</p><p><strong>配置集 ID</strong></p><p>Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于<strong>组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识</strong>。Data ID 通常采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名规则保证全局唯一性。此命名规则非强制。</p><p><strong>配置分组</strong></p><p>Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。配置分组的常见场景：<strong>不同的应用或组件使用了相同的配置类型，如 database_url 配置和 MQ_topic 配置。</strong></p><h4 id="DataID"><a href="#DataID" class="headerlink" title="DataID"></a>DataID</h4><p>指定<code>spring.profile.active</code> 和配置文件的 DataID 来使不同环境下读取不同的配置</p><h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>在配置文件中可以指定 group</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">nacos-config-client</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    nacos:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line">        <span class="comment"># Nacos 作为配置中心地址</span></span><br><span class="line"><span class="attr">        server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line">        <span class="comment"># 指定为 yaml 格式</span></span><br><span class="line"><span class="attr">        file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="comment"># group</span></span><br><span class="line"><span class="attr">        group:</span> <span class="string">TEST_GROUP</span></span><br></pre></td></tr></table></figure><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">nacos-config-client</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    nacos:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line">        <span class="comment"># Nacos 作为配置中心地址</span></span><br><span class="line"><span class="attr">        server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line">        <span class="comment"># 指定为 yaml 格式</span></span><br><span class="line"><span class="attr">        file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="comment"># group</span></span><br><span class="line"><span class="attr">        group:</span> <span class="string">DEV_GROUP</span></span><br><span class="line">        <span class="comment"># 命名空间 ID</span></span><br><span class="line"><span class="attr">        namespace:</span> <span class="number">78</span><span class="string">df1403-40c7-4c0a-9647-63a1583d2336</span></span><br></pre></td></tr></table></figure><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="集群模式部署"><a href="#集群模式部署" class="headerlink" title="集群模式部署"></a>集群模式部署</h4><p>这个快速开始手册是帮忙您快速在你的电脑上，下载安装并使用Nacos，部署生产使用的集群模式。</p><h4 id="集群部署架构图"><a href="#集群部署架构图" class="headerlink" title="集群部署架构图"></a>集群部署架构图</h4><p>因此开源的时候推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面</p><blockquote><p>VIP：虚拟IP，例如 Nginx 集群</p></blockquote><p><a href="http://ip1/" target="_blank" rel="noopener">http://ip1</a>:port/openAPI 直连ip模式，机器挂则需要修改ip才可以使用。</p><p><a href="http://vip/" target="_blank" rel="noopener">http://VIP</a>:port/openAPI 挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。</p><p><a href="http://nacos.com/" target="_blank" rel="noopener">http://nacos.com</a>:port/openAPI 域名 + VIP模式，可读性好，而且换ip方便，推荐模式</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/338441/1561258986171-4ddec33c-a632-4ec3-bfff-7ef4ffc33fb9.jpeg" alt="deployDnsVipMode.jpg"></p><blockquote><p><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html" target="_blank" rel="noopener">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p></blockquote><p>Nacos 默认使用嵌入式数据库（derby）保存数据，如果启动多个默认配置的 Nacos 节点，数据存储存在一致性问题，为了解决这个问题，Nacos 采用了集中式存储的放啊是来支持集群化部署，目前只支持 MySQL 的存储。</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ul><li><p>部署 Nacos 集群</p><ul><li><p>Clone 项目，进入根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/paderlol/nacos-docker.git</span><br><span class="line">cd nacos-docker</span><br></pre></td></tr></table></figure></li><li><p>修改配置</p><p><em>example/cluster-ip.yaml</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  nacos1:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nacos/nacos-server:latest</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">nacos1</span></span><br><span class="line">    <span class="comment"># 指定网络名和ip</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      Utils:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">169.1</span><span class="number">.0</span><span class="number">.6</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./cluster-logs/nacos1:/home/nacos/logs</span> </span><br><span class="line"><span class="attr">    env_file:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../env/nacos-ip.env</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">on-failure</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">  nacos2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nacos/nacos-server:latest</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">nacos2</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      Utils:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">169.1</span><span class="number">.0</span><span class="number">.7</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./cluster-logs/nacos2:/home/nacos/logs</span> </span><br><span class="line"><span class="attr">    env_file:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../env/nacos-ip.env</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  nacos_netcos3:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nacos/nacos-server:latest</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">nacos3</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="attr">      Utils:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">169.1</span><span class="number">.0</span><span class="number">.8</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./cluster-logs/nacos2:/home/nacos/logs</span></span><br><span class="line"><span class="attr">    env_file:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">../env/nacos-ip.env</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  Utils:</span></span><br><span class="line">    <span class="comment"># 引入外部网络，默认是创建了一个新的网络</span></span><br><span class="line"><span class="attr">    external:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">Utils</span></span><br></pre></td></tr></table></figure><p><em>env/nacos-ip.env</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#nacos dev env</span><br><span class="line">#配置集群ip、mysql信息</span><br><span class="line">NACOS_SERVERS=169.1.0.6:8848 169.1.0.7:8848 169.1.0.8:8848</span><br><span class="line">MYSQL_SERVICE_HOST=172.17.0.1</span><br><span class="line">MYSQL_SERVICE_DB_NAME=nacos_config</span><br><span class="line">MYSQL_SERVICE_PORT=3306</span><br><span class="line">MYSQL_SERVICE_USER=root</span><br><span class="line">MYSQL_SERVICE_PASSWORD=mysqlpass</span><br></pre></td></tr></table></figure></li><li><p>拉取进行生成容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f example/cluster-ip.yaml up</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置 Nginx</p><ul><li><p>使用 docker 创建镜像，并设置容器的网络ip</p></li><li><p>配置 nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># 设置nacos集群ip</span><br><span class="line">upstream cluster &#123;</span><br><span class="line">    server 169.1.0.6:8848;</span><br><span class="line">    server 169.1.0.7:8848;</span><br><span class="line">    server 169.1.0.8:8848;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root    /usr/share/nginx/html;</span><br><span class="line">        index   index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"># 匹配路径，设置代理到集群上</span><br><span class="line">    location /nacos &#123;</span><br><span class="line">        #root   /usr/share/nginx/html;</span><br><span class="line">        #index  index.html index.htm;</span><br><span class="line">        proxy_pass http://cluster/nacos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">    # concurs with nginx&apos;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>最后nacos的yaml配置中直接填nginx ip就可以</p></li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Hystrix：</p><ul><li>需要手动搭建平台</li><li>没有 Web 界面可以细粒度化配置</li></ul><p>Sentinel:</p><ul><li>单独的一个组件</li><li>web 界面配置</li></ul></blockquote><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>Sentinel 具有以下特征:</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开gaishu箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><p>Sentinel 的主要特性：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160107.png" alt></p><p>简单来说，Sentinel 的功能：</p><ul><li>服务雪崩</li><li>服务降级</li><li>服务熔断</li><li>服务限流</li></ul><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li>核心库（Java客户端），不依赖于任何框架/库，能够运行于所有的 Java 环境</li><li>控制体（Dashboard），基于 Spring Boot 开发，可以直接运行</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><em>jar</em> 包地址：<u><a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/releases</a></u>，下载 dashboard</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><p>运行 jar 包</p><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 后续做持久化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>yaml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    nacos:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line"><span class="attr">    sentinel:</span></span><br><span class="line"><span class="attr">      transport:</span></span><br><span class="line"><span class="attr">        dashboard:</span> <span class="attr">localhost:12345</span></span><br><span class="line">        <span class="comment"># 默认8719，如果被占用会自动从8719开始+1扫描</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure></li><li><p>编写 controller 并访问，就可以看到 sentinel 控制台显示的信息</p><blockquote><p>sentinel 是懒加载，只有当访问了之后才会显示出来</p></blockquote></li></ol><h3 id="流量控制（流控，flow-control）"><a href="#流量控制（流控，flow-control）" class="headerlink" title="流量控制（流控，flow control）"></a>流量控制（流控，<em>flow</em> <em>control</em>）</h3><blockquote><p><em>Doc</em>: <a href="https://github.com/alibaba/Sentinel/wiki/流量控制" target="_blank" rel="noopener">流量控制</a></p></blockquote><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p><strong>流量控制</strong>（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象</li><li><code>count</code>：限流阈值</li><li><code>grade</code>： 限流阈值类型（QPS 或并发线程数）</li><li><code>limitApp</code>： 流控针对的调用来源，若为 <code>default</code> 则不区分调用来源</li><li><code>strategy</code>： 调用关系限流策略</li><li><code>controlBehavior</code>： 流量控制效果（直接拒绝、Warm Up、匀速排队）</li></ul><h4 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h4><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><ul><li><p>资源名</p><p>唯一资源，默认请求路径</p></li><li><p>针对来源</p><p>Sentinel 可以针对调用者进行限流，填写服务名，默认 default（不区分来源）</p></li><li><p>阈值类型/单机阈值</p><ul><li><p>QPS（每秒的请求数量）</p><p>当调用该 api 的 QPS 达到阈值的时候，进行限流</p></li><li><p>线程数</p><p>当调用该 api 的线程数达到阈值的时候，进行限流</p><blockquote><p>处理该 api 请求的线程数达到阈值，再来请求就会直接拒绝；</p><p>而 QPS 是每秒并发请求数的限制；这个是最大并发请求线程树的限制。</p><p>当选择 <u>线程数</u> 时，【流控效果】只能是 <u>快速失败</u>。</p></blockquote></li></ul></li><li><p>流控模式</p><ul><li><p>直接</p><p>当 api 达到限流条件时，直接限流</p></li><li><p>关联</p><p>当关联的资源达到阈值时，限流</p><blockquote><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢</p></blockquote></li><li><p>链路</p><p>只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流），api 级别的针对来源</p></li></ul></li><li><p>流控效果（只有是 QPS 时才可以设置）</p><ul><li><p>快速失败</p><p><strong>直接拒绝</strong>（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。</p></li><li><p>Warm Up</p><p>当流量突然增大的时候，我们常常会希望系统从空闲状态到繁忙状态的切换的时间长一些。即如果系统在此之前长期处于空闲的状态，我们希望处理请求的数量是缓步的增多，经过预期的时间以后，到达系统处理请求个数的最大值。Warm Up（冷启动，预热）模式就是为了实现这个目的的。</p><p>默认 <code>coldFactor</code> 为 3，即请求 QPS 从 <code>threshold / 3</code> 开始，经预热时长逐渐升至设定的 QPS 阈值。</p><blockquote><p>限流－冷启动：<a href="https://github.com/alibaba/Sentinel/wiki/限流---冷启动" target="_blank" rel="noopener">冷启动</a></p><blockquote><p>设置界面单位是 5</p></blockquote><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160022.png" alt></p><p>可以看到，最开始的阈值是 100/3，慢慢的再一段时间内才开始上升到设置的 100</p></blockquote></li><li><p>排队等待</p><p>匀速排队（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。</p><p><a href="https://en.wikipedia.org/wiki/Leaky_bucket" target="_blank" rel="noopener">Leaky Bucket</a> 对应 <a href="https://github.com/alibaba/Sentinel/wiki/流量控制" target="_blank" rel="noopener">流量整形</a> 中的<strong>匀速器</strong>。它的中心思想是，以固定的间隔时间让请求通过。当请求到来的时候，如果当前请求距离上个通过的请求通过的时间间隔不小于预设值，则让当前请求通过；否则，计算当前请求的预期通过时间，如果该请求的预期通过时间小于规则预设的 timeout 时间，则该请求会等待直到预设时间到来通过（排队等待处理）；若预期的通过时间超出最大排队时长，则直接拒接这个请求。</p><blockquote><p><a href="https://github.com/alibaba/Sentinel/wiki/流量控制-匀速排队模式" target="_blank" rel="noopener">流量控制 - 匀速器模式</a></p><blockquote><p>设置界面单位是 ms</p></blockquote><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605160010.png" alt></p><p>设置 QPS = 10，每秒匀速 10 个，间隔时间：1000ms / 10 = 100ms</p><p>超时时间 20 * 1000ms = 20s</p><p>如果请求等待时间超过 20s，就会失败：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605155957.png" alt></p><blockquote><p>Jmeter 绝对并发：</p><p><img src="../../../%25E6%25A1%258C%25E9%259D%25A2/SpringCloud/image-20200523181903368.png" alt="image-20200523181903368"></p></blockquote></blockquote></li></ul></li></ul><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>除了流量控制以外，<u>对调用链路中不稳定的资源进行熔断降级</u>也是保障高可用的重要措施之一。由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积。Sentinel <strong>熔断降级</strong>会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p><p>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 <code>DegradeException</code>）。</p><p>==❈ Setinel 的断路器没有半开状态：半开状态时系统会自动检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常就继续打开断路器不可用（Hystrix）。==</p><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><blockquote><p>源码：com.alibaba.csp.sentinel.slots.block.degrade.<strong><em>DegradeRule</em></strong></p></blockquote><p>我们通常用以下几种方式来衡量资源是否处于稳定的状态：</p><ul><li><p>平均响应时间 (<code>DEGRADE_GRADE_RT</code>)：当资源的平均响应时间超过阈值（<code>DegradeRule</code> 中的 <code>count</code>，以 ms 为单位）之后，资源进入<u>准降级状态</u>。接下来如果持续进入 <strong><em>5</em></strong> 个请求，它们的 RT 都持续超过这个阈值，那么在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地返回（抛出 <code>DegradeException</code>）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，<strong>超出此阈值的都会算作 4900 ms</strong>，若需要变更此上限可以通过启动配置项 <code>-Dcsp.sentinel.statistic.max.rt=xxx</code> 来配置。</p><blockquote><p>Github Wiki 没有强调 5 个请求</p></blockquote></li><li><p>异常比例 (<code>DEGRADE_GRADE_EXCEPTION_RATIO</code>)：当资源的每秒请求量 &gt;= N（可配置），并且每秒异常总数占通过量的比值超过阈值（<code>DegradeRule</code> 中的 <code>count</code>）之后，资源进入降级状态，即在接下的时间窗口（<code>DegradeRule</code> 中的 <code>timeWindow</code>，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</p><blockquote><p>N 默认是5，目前没有找到配置 N 的地方</p></blockquote></li><li><p>异常数 (<code>DEGRADE_GRADE_EXCEPTION_COUNT</code>)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 <code>timeWindow</code> 小于 60s，则结束熔断状态后仍可能再进入熔断状态。</p></li></ul><p>注意：异常降级仅针对业务异常，对 Sentinel 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Entry entry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  entry = SphU.entry(key, EntryType.IN, key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write your biz code here.</span></span><br><span class="line">  <span class="comment">// &lt;&lt;BIZ CODE&gt;&gt;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!BlockException.isBlockException(t)) &#123;</span><br><span class="line">    Tracer.trace(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开源整合模块，如 Sentinel Dubbo Adapter, Sentinel Web Servlet Filter 或 <code>@SentinelResource</code> 注解会自动统计业务异常，无需手动调用。</p><h3 id="热点key"><a href="#热点key" class="headerlink" title="热点key"></a>热点key</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p><ul><li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li><li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li></ul><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。<strong>热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效</strong>。</p><p>Sentinel 利用 <strong><em>LRU</em></strong> 策略统计最近最常访问的热点参数，结合<strong>令牌桶算法</strong>来进行参数级别的流控。热点参数限流<u>支持集群模式</u>。</p><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>用 <code>@SentineResource</code> 注解，设置参数，同时在控制台设置参数索引、阈值、时间窗口等参数进行热点key限流；</p><blockquote><p>不使用注解无效</p></blockquote><h4 id="参数例外项"><a href="#参数例外项" class="headerlink" title="参数例外项"></a>参数例外项</h4><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605155942.png" alt></p><p>偶尔期望参数是某个特殊值时，限流值要特殊设置。</p><blockquote><p>仅支持基本类型和<em>String</em></p></blockquote><h3 id="系统规则（系统自适应限流）"><a href="#系统规则（系统自适应限流）" class="headerlink" title="系统规则（系统自适应限流）"></a>系统规则（系统自适应限流）</h3><p>Sentinel 系统自适应限流从<strong>整体维度</strong>对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p><u>系统保护规则是应用整体维度的，而不是资源维度的</u>，并且<strong>仅对入口流量生效</strong>。入口流量指的是进入应用的流量（<code>EntryType.IN</code>），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p><p>系统规则支持以下的模式：</p><ul><li><p><strong>Load 自适应</strong>（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</p></li><li><p><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</p></li><li><p><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</p></li><li><p><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</p></li><li><p><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</p></li></ul><h3 id="SentinelResource"><a href="#SentinelResource" class="headerlink" title="@SentinelResource"></a>@SentinelResource</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>Sentinel 提供了 <code>@SentinelResource</code> 注解用于定义资源，并提供了 AspectJ 的扩展用于自动定义资源、处理 <code>BlockException</code> 等。使用 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-annotation-aspectj" target="_blank" rel="noopener">Sentinel Annotation AspectJ Extension</a> 的时候需要引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.y.z<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：注解方式埋点不支持 private 方法。</p></blockquote><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p><code>@SentinelResource</code> 用于定义资源，并提供可选的异常处理和 fallback 配置项。 <code>@SentinelResource</code> 注解包含以下属性：</p><ul><li><p><code>value</code>：资源名称，必需项（不能为空）</p></li><li><p><code>entryType</code>：entry 类型，可选项（默认为 <code>EntryType.OUT</code>）</p></li><li><p><code>blockHandler</code> / <code>blockHandlerClass</code>: <code>blockHandler</code> 对应处理 <code>BlockException</code> 的函数名称，可选项。blockHandler 函数访问范围需要是 <code>public</code>，返回类型需要与原方法相匹配，<u>参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 <code>BlockException</code></u>。blockHandler 函数默认需要和原方法<u>在同一个类</u>中。</p><hr><p>若希望使用其他类的函数，则可以指定 <code>blockHandlerClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数==必需为 <strong><em>static</em></strong> 函数==，否则无法解析。</p><blockquote><p>如果被热点限流，且没有设置这个参数，就会直接返回异常错误页面</p><hr><p><strong>仅被限流时会处理</strong>，运行时异常不会处理</p></blockquote></li><li><p><code>fallback</code>/<code>fallbackClass</code>：fallback 函数名称，可选项，用于在<u>抛出异常</u>的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了<code>exceptionsToIgnore</code> 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：</p><ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要和原函数一致，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li><li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li><p><code>defaultFallback</code>（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 <code>exceptionsToIgnore</code> 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：</p><ul><li><u>返回值类型必须与原函数返回值类型一致；</u></li><li><u>方法参数列表需要为空，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常</u>。</li><li>defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li><p><code>exceptionsToIgnore</code>（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</p></li></ul><blockquote><p>注：1.6.0 之前的版本 fallback 函数只针对降级异常（<code>DegradeException</code>）进行处理，<strong>不能针对业务异常进行处理</strong>。</p></blockquote><p>特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 <code>BlockException</code> 时只会进入 <code>blockHandler</code> 处理逻辑。若未配置 <code>blockHandler</code>、<code>fallback</code> 和 <code>defaultFallback</code>，则被限流降级时会将 <code>BlockException</code> <strong>直接抛出</strong>（若方法本身未定义 throws BlockException 则会被 JVM 包装一层 <code>UndeclaredThrowableException</code>）。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应的 `handleException` 函数需要位于 `ExceptionUtil` 类中，并且必须为 static 函数.</span></span><br><span class="line">    <span class="meta">@SentinelResource</span>(value = <span class="string">"test"</span>, blockHandler = <span class="string">"handleException"</span>, blockHandlerClass = &#123;ExceptionUtil.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数</span></span><br><span class="line">    <span class="meta">@SentinelResource</span>(value = <span class="string">"hello"</span>, blockHandler = <span class="string">"exceptionHandler"</span>, fallback = <span class="string">"helloFallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Hello at %d"</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fallback 函数，函数签名与原函数一致或加一个 Throwable 类型的参数.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloFallback</span><span class="params">(<span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"Halooooo %d"</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block 异常处理函数，参数最后多一个 BlockException，其余与原函数一致.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">exceptionHandler</span><span class="params">(<span class="keyword">long</span> s, BlockException ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do some log here.</span></span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Oops, error occurred at "</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 1.4.0 版本开始，注解方式定义资源支持自动统计业务异常，无需手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常。Sentinel 1.4.0 以前的版本需要自行调用 <code>Tracer.trace(ex)</code> 来记录业务异常。</p><blockquote><p>SpringCloud 不需要额外配置就可以使用注解，基于 AOP （SpringMVC、SpringBoot）都需要额外配置。</p></blockquote><h4 id="自定义限流处理"><a href="#自定义限流处理" class="headerlink" title="自定义限流处理"></a>自定义限流处理</h4><p>通过设置属性 <code>blockHandlerClass</code> 来将兜底方法与业务代码分开</p><hr><h5 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h5><p>需要在配置文件中开启 sentinel 对 feign 的支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feign.sentinel.enabled=true</span><br></pre></td></tr></table></figure><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>微服务重启或 Sentinel 重启都会丢失配置规则；</p><p>可以将 sentinel 的配置保存在 Nacos 上或 Redis 中；</p><blockquote><p>参考：<a href="https://github.com/alibaba/Sentinel/wiki/在生产环境中使用-Sentinel" target="_blank" rel="noopener">生产环境中使用-Sentinel</a></p><p>一般来说，规则的推送有下面三种模式:</p><table><thead><tr><th>推送模式</th><th>说明</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><a href="https://github.com/alibaba/Sentinel/wiki/在生产环境中使用-Sentinel#原始模式" target="_blank" rel="noopener">原始模式</a></td><td>API 将规则推送至客户端并直接更新到内存中，扩展写数据源（<a href="https://github.com/alibaba/Sentinel/wiki/动态规则扩展" target="_blank" rel="noopener"><code>WritableDataSource</code></a>）</td><td>简单，无任何依赖</td><td>不保证一致性；规则保存在内存中，重启即消失。严重不建议用于生产环境</td></tr><tr><td><a href="https://github.com/alibaba/Sentinel/wiki/在生产环境中使用-Sentinel#Pull模式" target="_blank" rel="noopener">Pull 模式</a></td><td>扩展写数据源（<a href="https://github.com/alibaba/Sentinel/wiki/动态规则扩展" target="_blank" rel="noopener"><code>WritableDataSource</code></a>）， 客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 RDBMS、文件 等</td><td>简单，无任何依赖；规则持久化</td><td>不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题。</td></tr><tr><td><strong><a href="https://github.com/alibaba/Sentinel/wiki/在生产环境中使用-Sentinel#Push模式" target="_blank" rel="noopener">Push 模式</a></strong></td><td>扩展读数据源（<a href="https://github.com/alibaba/Sentinel/wiki/动态规则扩展" target="_blank" rel="noopener"><code>ReadableDataSource</code></a>），规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用 Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证。<strong>生产环境下一般采用 push 模式的数据源。</strong></td><td>规则持久化；一致性；快速</td><td>引入第三方依赖</td></tr></tbody></table></blockquote><h5 id="持久化到-Nacos"><a href="#持久化到-Nacos" class="headerlink" title="持久化到 Nacos"></a>持久化到 Nacos</h5><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 后续做持久化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改 yaml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    nacos:</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line"><span class="attr">    sentinel:</span></span><br><span class="line"><span class="attr">      transport:</span></span><br><span class="line"><span class="attr">        dashboard:</span> <span class="attr">localhost:12345</span></span><br><span class="line">        <span class="comment"># 默认8719，如果被占用会自动从8719开始+1扫描</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8719</span></span><br><span class="line">      <span class="comment"># 配置datasource</span></span><br><span class="line"><span class="attr">      datasource:</span></span><br><span class="line">        <span class="comment"># 数据源名</span></span><br><span class="line"><span class="attr">        ds1:</span></span><br><span class="line">          <span class="comment"># 使用nacos</span></span><br><span class="line"><span class="attr">          nacos:</span></span><br><span class="line"><span class="attr">            server-addr:</span> <span class="attr">localhost:8848</span></span><br><span class="line"><span class="attr">            dataId:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line"><span class="attr">            groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="attr">            data-type:</span> <span class="string">json</span></span><br><span class="line"><span class="attr">            rule-type:</span> <span class="string">flow</span></span><br></pre></td></tr></table></figure><p>可以看到，可以使用多种数据源来持久化</p><p><img src="../../../%25E6%25A1%258C%25E9%259D%25A2/SpringCloud/image-20200524175848893.png" alt="image-20200524175848893"></p></li><li><p>添加 Nacos 配置，在上一步设定的配置信息中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"resource"</span>: <span class="string">"bbyResource"</span>,</span><br><span class="line">        <span class="attr">"limitApp"</span>: <span class="string">"default"</span>,</span><br><span class="line">        <span class="attr">"grade"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"count"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"strategy"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"controlBehavior"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"clusterMode"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>这样重启会后也可以持久化</p></li></ol><blockquote><p>然而控制台添加的规则还是在内存里面，不会从存储到 nacos 中</p><p>当新建配置时，会发送一个 post 请求：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200605155918.png" alt></p><p>直接复制请求的 json 到 nacos 中就可以（nacos 中的配置是一个数组，将 json 对象添加到数组中）</p><p>如果想在控制台修改的数据自动同步到 Nacos 中，可以参考：<a href="https://www.sonake.com/2019/12/16/Sentinel-Nacos实现规则持久化/#第一步-Sentinel客户端配置" target="_blank" rel="noopener">Sentinel-Nacos实现规则持久化</a></p><p>参考：</p><ul><li><a href="https://github.com/alibaba/Sentinel/wiki/如何使用#查询更改规则" target="_blank" rel="noopener">查询更改规则</a></li><li><a href="[https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%88%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%E7%AE%A1%E7%90%86%EF%BC%89#%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE](https://github.com/alibaba/Sentinel/wiki/Sentinel-控制台（集群流控管理）#规则配置">Sentinel-控制台（集群流控管理）#规则配置</a>)</li></ul></blockquote><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p>单体应用被拆分成微服务，每个服务内部的数据一致性由本地事务保证，但是全局的数据一致性没办法保证。</p><p>一次业务操作需要跨多个数据源或多个系统进行远程调用，就会产生分布式事务问题。</p><blockquote><p><kbd><a href="https://cloud.tencent.com/developer/article/1446247" target="_blank" rel="noopener">分布式事务</a></kbd></p><p><strong>2.分布式事务产生原因</strong></p><p>当架构由单体向多服务演进时，整个系统的可靠性变得难以控制，在单体服务中，一个请求的整个周期，从请求到响应结果，都是在一台服务器上，本地事务就可以保证一组数据操作的一致性。</p><p>在微服务中，从请求到响应，之间可能跨越多台服务器，多个数据库，如下图，假设有个金融系统，拆分为了多个微服务，每个微服务有自己的数据库，我们现在发起借款这个操作，需要用到以下几个微服务：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200525100417.png" alt></p><p>这个借款操作，可以抽象概括为以下几个步骤：</p><p>1.用户发起借款，调用借款服务的借款接口；</p><p>2.借款同时，在授信服务里 减少授信额度；</p><p>3.借款同时，在资金服务里 增加账户余额；</p><p>4.借款同时，在日志服务里 增加流水记录；</p><p>……</p><p>这里只是假设，实际金融项目中的借款这个动作发生的事情远比上图复杂。</p><p>由于每个服务都是单独部署的，在理想状态下，上述的操作，可以顺利得以执行。</p><p>如果中间有服务发生故障了呢？</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200525100438.png" alt></p><p>假设一个常见的场景，资金服务由于没有合理使用线程池和连接池，现在内存爆掉，无法正常处理请求，那么，这个链路成为了如下的样子：</p><p>1.用户发起借款，调用借款服务的借款接口；</p><p>2.借款同时，在授信服务里 减少授信额度；</p><p>3.借款同时，在资金服务里 增加账户余额；x</p><p>4.借款同时，在日志服务里 增加流水记录；</p><p>……</p><p>此时，由于是在多个服务中，本地的Transaction已经无法应对这个情况了，现在系列操作导致了上述的情况，用户的授信额度减少了，流水也记录了，但是用户没有收到钱。</p></blockquote><blockquote><p><kbd>SOURCE</kbd> <a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b#heading-9" target="_blank" rel="noopener">再有人问你分布式事务，把这篇扔给他</a></p></blockquote><h4 id="分布式事务过程（一ID-三组件）"><a href="#分布式事务过程（一ID-三组件）" class="headerlink" title="分布式事务过程（一ID + 三组件）"></a>分布式事务过程（一ID + 三组件）</h4><ul><li><p><strong><em>Transaction ID XID</em></strong> 全局唯一的事务 ID</p></li><li><p>三组件</p><ul><li><p><strong><em>Transaction Coordinator(TC)</em></strong></p><p>事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或混滚；</p></li><li><p><strong><em>Transaction Manager(TM)</em></strong></p><p>控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议；</p></li><li><p><strong><em>Resource Manager(RM)</em></strong></p><p>控制分支事务，负责分支注册、状态汇报、并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚</p></li></ul></li></ul><p>一个典型的分布式事务过程：</p><ol><li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。</li><li>XID 在微服务调用链路的上下文中传播。</li><li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖。</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议。</li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li></ol><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200525102501.png" alt></p><h3 id="Seata-1"><a href="#Seata-1" class="headerlink" title="Seata"></a>Seata</h3><h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p>Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p><p>官网：<a href="http://seata.io/zh-cn/" target="_blank" rel="noopener">http://seata.io/zh-cn/</a></p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><ol><li><p>下载相应的版本：<a href="http://seata.io/zh-cn/blog/download.html" target="_blank" rel="noopener">http://seata.io/zh-cn/blog/download.html</a></p></li><li><p>新建数据库，导入 sql</p><p>sql 地址：<a href="https://github.com/seata/seata/blob/1.2.0/script/server/db/mysql.sql" target="_blank" rel="noopener">https://github.com/seata/seata/blob/1.2.0/script/server/db/mysql.sql</a></p></li><li><p>修改 file.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">## transaction log store, only used in seata-server</span><br><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、db</span><br><span class="line">  # 设置为db</span><br><span class="line">  mode = &quot;db&quot;</span><br><span class="line"></span><br><span class="line">  ## file store property</span><br><span class="line">  file &#123;</span><br><span class="line">  ## ....</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store property</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span><br><span class="line">    datasource = &quot;druid&quot;</span><br><span class="line">    ## mysql/oracle/postgresql/h2/oceanbase etc.</span><br><span class="line">    dbType = &quot;mysql&quot;</span><br><span class="line">    driverClassName = &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    # 数据库配置</span><br><span class="line">    url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span><br><span class="line">    user = &quot;root&quot;</span><br><span class="line">    password = &quot;mysqlpass&quot;</span><br><span class="line">    minConn = 5</span><br><span class="line">    maxConn = 30</span><br><span class="line">    globalTable = &quot;global_table&quot;</span><br><span class="line">    branchTable = &quot;branch_table&quot;</span><br><span class="line">    lockTable = &quot;lock_table&quot;</span><br><span class="line">    queryLimit = 100</span><br><span class="line">    maxWait = 5000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 register.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type = &quot;nacos&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    application = &quot;seata-server&quot;</span><br><span class="line">    serverAddr = &quot;localhost:8848&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    username = &quot;&quot;</span><br><span class="line">    password = &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  ## ....</span><br></pre></td></tr></table></figure></li><li><p>启动 Nacos</p></li><li><p>运行脚本：</p><p>| -h | –host | 指定在注册中心注册的 IP | 不指定时获取当前的 IP，外部访问部署在云环境和容器中的 server 建议指定 |<br>| —- | ———— | ————————– | ———————————————————— |<br>| -p | –port | 指定 server 启动的端口 | 默认为 8091 |<br>| -m | –storeMode | 事务日志存储方式 | 支持<code>file</code>和<code>db</code>，默认为 <code>file</code> |<br>| -n | –serverNode | 用于指定seata-server节点ID | ,如 <code>1</code>,<code>2</code>,<code>3</code>…, 默认为 <code>1</code> |<br>| -e | –seataEnv | 指定 seata-server 运行环境 | 如 <code>dev</code>, <code>test</code> 等, 服务启动时会使用 <code>registry-dev.conf</code> 这样的配置 |</p><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh ./bin/seata-server.sh -p 8091 -h 127.0.0.1</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><blockquote><p>用例来自官网文档</p></blockquote><p>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</p><ul><li>仓储服务：对给定的商品扣除仓储数量。</li><li>订单服务：根据采购需求创建订单。</li><li>帐户服务：从用户帐户中扣除余额。</li></ul><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>官网 WIKI 莫得配置说明就很难受 emmm</p><p>参考：</p><ul><li><a href="https://seata.io/zh-cn/blog/seata-quick-start.html" target="_blank" rel="noopener">Seata极简入门</a></li><li><a href="https://www.jianshu.com/p/c517d488ab67" target="_blank" rel="noopener">Seata 配置文件说明</a></li></ul><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="http://seata.io/img/architecture.png" alt="Architecture"></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>在 MySQL 中分别创建三个数据库</p></li><li><p>每个数据库中创建 undo_log 回滚日志表</p><p>在业务相关的数据库中添加 undo_log 表，用于保存需要回滚的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`undo_log`</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span>            <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`branch_id`</span>     <span class="built_in">BIGINT</span>(<span class="number">20</span>)   <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`xid`</span>           <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`context`</span>       <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`rollback_info`</span> LONGBLOB     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`log_status`</span>    <span class="built_in">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`log_created`</span>   DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`log_modified`</span>  DATETIME     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`ext`</span>           <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>, <span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  AUTO_INCREMENT = <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8</span><br></pre></td></tr></table></figure><blockquote><p>地址：<a href="https://github.com/seata/seata/blob/develop/script/client/at/db/mysql.sql" target="_blank" rel="noopener">https://github.com/seata/seata/blob/develop/script/client/at/db/mysql.sql</a></p></blockquote></li><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- seata 1.2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>==导入Maven包时，一定要注意，seato-all的版本和本地服务的版本是否一致！！！不然即使配置OK，也可能会出现运行错误！！==</p><p><code>exclude</code> 排除包之后，引入与服务端版本匹配的 jar 包</p></blockquote></li><li><p>添加Seata 配置文件</p><ul><li><p><strong><em>registry.conf</em></strong></p><p>该配置用于指定 TC 的注册中心和配置文件，默认都是 <em>file</em>; <u>如果使用其他的注册中心，要求 Seata-Server 也注册到该配置中心上</u></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># 注册中心(要与服务端注册中心相同)</span><br><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type = &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;localhost&quot;</span><br><span class="line">    namespace = &quot;public&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl = &quot;http://localhost:8761/eureka&quot;</span><br><span class="line">    application = &quot;default&quot;</span><br><span class="line">    weight = &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  redis &#123;</span><br><span class="line">    serverAddr = &quot;localhost:6379&quot;</span><br><span class="line">    db = &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:2181&quot;</span><br><span class="line">    session.timeout = 6000</span><br><span class="line">    connect.timeout = 2000</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    serverAddr = &quot;http://localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  sofa &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:9603&quot;</span><br><span class="line">    application = &quot;default&quot;</span><br><span class="line">    region = &quot;DEFAULT_ZONE&quot;</span><br><span class="line">    datacenter = &quot;DefaultDataCenter&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">    group = &quot;SEATA_GROUP&quot;</span><br><span class="line">    addressWaitTime = &quot;3000&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置中心，只有为&apos;file&apos;时，file.conf才会生效，需要配置</span><br><span class="line">config &#123;</span><br><span class="line">  # file、nacos 、apollo、zk、consul、etcd3</span><br><span class="line">  type = &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;localhost&quot;</span><br><span class="line">    namespace = &quot;public&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  consul &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:8500&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  apollo &#123;</span><br><span class="line">    app.id = &quot;seata-server&quot;</span><br><span class="line">    apollo.meta = &quot;http://192.168.1.204:8801&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  zk &#123;</span><br><span class="line">    serverAddr = &quot;127.0.0.1:2181&quot;</span><br><span class="line">    session.timeout = 6000</span><br><span class="line">    connect.timeout = 2000</span><br><span class="line">  &#125;</span><br><span class="line">  etcd3 &#123;</span><br><span class="line">    serverAddr = &quot;http://localhost:2379&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  file &#123;</span><br><span class="line">    name = &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p><strong><em>file.conf</em></strong></p><p>该配置用于指定TC的相关属性；如果使用注册中心也可以将配置添加到配置中心</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type = &quot;TCP&quot;</span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server = &quot;NIO&quot;</span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat = true</span><br><span class="line">  #thread factory for netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix = &quot;NettyBoss&quot;</span><br><span class="line">    worker-thread-prefix = &quot;NettyServerNIOWorker&quot;</span><br><span class="line">    server-executor-thread-prefix = &quot;NettyServerBizHandler&quot;</span><br><span class="line">    share-boss-worker = false</span><br><span class="line">    client-selector-thread-prefix = &quot;NettyClientSelector&quot;</span><br><span class="line">    client-selector-thread-size = 1</span><br><span class="line">    client-worker-thread-prefix = &quot;NettyClientWorkerThread&quot;</span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    boss-thread-size = 1</span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    worker-thread-size = 8</span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait = 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization = &quot;seata&quot;</span><br><span class="line">  compressor = &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  vgroup_mapping.my_test_tx_group = &quot;default&quot;</span><br><span class="line">  #only support single node</span><br><span class="line">  default.grouplist = &quot;127.0.0.1:8091&quot;</span><br><span class="line">  #degrade current not support</span><br><span class="line">  enableDegrade = false</span><br><span class="line">  #disable</span><br><span class="line">  disable = false</span><br><span class="line">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span><br><span class="line">  max.commit.retry.timeout = &quot;-1&quot;</span><br><span class="line">  max.rollback.retry.timeout = &quot;-1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  async.commit.buffer.limit = 10000</span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.internal = 10</span><br><span class="line">    retry.times = 30</span><br><span class="line">  &#125;</span><br><span class="line">  report.retry.count = 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## transaction log store</span><br><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、db</span><br><span class="line">  mode = &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  ## file store</span><br><span class="line">  file &#123;</span><br><span class="line">    dir = &quot;sessionStore&quot;</span><br><span class="line"></span><br><span class="line">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br><span class="line">    max-branch-session-size = 16384</span><br><span class="line">    # globe session size , if exceeded throws exceptions</span><br><span class="line">    max-global-session-size = 512</span><br><span class="line">    # file buffer size , if exceeded allocate new buffer</span><br><span class="line">    file-write-buffer-cache-size = 16384</span><br><span class="line">    # when recover batch read size</span><br><span class="line">    session.reload.read_size = 100</span><br><span class="line">    # async, sync</span><br><span class="line">    flush-disk-mode = async</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span><br><span class="line">    datasource = &quot;dbcp&quot;</span><br><span class="line">    ## mysql/oracle/h2/oceanbase etc.</span><br><span class="line">    db-type = &quot;mysql&quot;</span><br><span class="line">    url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span><br><span class="line">    user = &quot;mysql&quot;</span><br><span class="line">    password = &quot;mysql&quot;</span><br><span class="line">    min-conn = 1</span><br><span class="line">    max-conn = 3</span><br><span class="line">    global.table = &quot;global_table&quot;</span><br><span class="line">    branch.table = &quot;branch_table&quot;</span><br><span class="line">    lock-table = &quot;lock_table&quot;</span><br><span class="line">    query-limit = 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">lock &#123;</span><br><span class="line">  ## the lock store mode: local、remote</span><br><span class="line">  mode = &quot;remote&quot;</span><br><span class="line"></span><br><span class="line">  local &#123;</span><br><span class="line">    ## store locks in user&apos;s database</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remote &#123;</span><br><span class="line">    ## store locks in the seata&apos;s server</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">recovery &#123;</span><br><span class="line">  committing-retry-delay = 30</span><br><span class="line">  asyn-committing-retry-delay = 30</span><br><span class="line">  rollbacking-retry-delay = 30</span><br><span class="line">  timeout-retry-delay = 30</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.data.validation = true</span><br><span class="line">  undo.log.serialization = &quot;jackson&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## metrics settings</span><br><span class="line">metrics &#123;</span><br><span class="line">  enabled = false</span><br><span class="line">  registry-type = &quot;compact&quot;</span><br><span class="line">  # multi exporters use comma divided</span><br><span class="line">  exporter-list = &quot;prometheus&quot;</span><br><span class="line">  exporter-prometheus-port = 9898</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://seata.io/zh-cn/docs/user/configurations.html" target="_blank" rel="noopener">参数配置</a></p></blockquote><p>需要注意的是 <code>service.vgroup_mapping</code> 这个配置，在 Spring Cloud 中默认是<code>${spring.application.name}-fescar-service-group</code>，可以通过指定<code>application.properties</code>的 <code>spring.cloud.alibaba.seata.tx-service-group</code>这个属性覆盖，但是必须要和 <code>file.conf</code>中的一致，否则会提示 <code>no available server to connect</code>。（jar包与服务端版本号不一致有时也会出现这个问题）</p></li></ul><ol start="5"><li><p>注入数据源</p><p>Seata 通过代理数据源的方式实现分支事务；MyBatis 和 JPA 都需要注入 <code>io.seata.rm.datasource.DataSourceProxy</code>, 不同的是，MyBatis 还需要额外注入 <code>org.apache.ibatis.session.SqlSessionFactory</code></p><ul><li><p><strong><em>Mybatis</em></strong></p><blockquote><p>需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">&gt;  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>官网示例引入了 <em>Druid</em></p></blockquote><p>配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProxyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProxy <span class="title">dataSourceProxy</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactoryBean</span><span class="params">(DataSourceProxy dataSourceProxy)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSourceProxy);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式由于手动创建了 <code>SqlSessionFactory</code>，所以 <em>application.yml/properties</em> 中的配置需要手动注入并设置才会生效</p></blockquote><p>启动类也要添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span>(exclude = DataSourceAutoConfiguration.class)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动必要的服务：包括 Seata-server 以及依赖的注册或配置中心</p></li><li><p>使用 <code>@GlobalTransactional</code> 开启事务</p><p>在业务的发起方的方法上使用 <code>@GlobalTransactional</code> 开启全局事务，Seata 会将事务的 xid 通过拦截器添加到调用其他服务的请求中，实现分布式事务</p></li></ol><blockquote><p>参考：</p><ul><li><p><a href="https://www.cnblogs.com/victorbu/p/12738556.html" target="_blank" rel="noopener">https://www.cnblogs.com/victorbu/p/12738556.html</a></p></li><li><p><a href="https://blog.funkye.icu/2020/02/19/seata-quick/" target="_blank" rel="noopener">https://blog.funkye.icu/2020/02/19/seata-quick/</a></p></li><li><a href="http://seata.io/zh-cn/docs/user/configurations.html" target="_blank" rel="noopener">参数配置</a></li></ul><p><em>2.2.0.RELEASE+</em> 不需要手动配置数据源代理，直接创建一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Bean</span></span><br><span class="line">&gt; <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>即可，如果不是 2.2.0 及以上但 Seata 版本高于 1.1.0，可以参考：（貌似0.8以上的支持参数配置，1.1.0 使用注解代替）</p><blockquote><p>seata1.1.0版本新加入以下注解,用于开启数据源自动代理功能 <code>@EnableAutoDataSourceProxy</code></p><ol><li><p>对于使用seata-spring-boot-starter的方式，默认已开启数据源自动代理,如需关闭，请配置seata.enableAutoDataSourceProxy=false，该项配置默认为true。 如需切换代理实现方式，请通过seata.useJdkProxy=false进行配置,默认为false，采用CGLIB作为数据源自动代理的实现方式。</p></li><li><p>对于使用seata-all的方式，请使用@EnableAutoDataSourceProxy来显式开启数据源自动代理功能。如有需要，可通过该注解的useJdkProxy属性进行代理实现方式 的切换。默认为false,采用CGLIB作为数据源自动代理的实现方式。</p></li></ol></blockquote></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;参考视频：&lt;a href=&quot;https://www.bilibili.com/video/av93824064?p=148&amp;a
      
    
    </summary>
    
    
      <category term="springcloud" scheme="https://phoenixxc.github.io/tags/springcloud/"/>
    
      <category term="微服务" scheme="https://phoenixxc.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>源码分析之 —— ArrayList</title>
    <link href="https://phoenixxc.github.io/posts/e7896c93/"/>
    <id>https://phoenixxc.github.io/posts/e7896c93/</id>
    <published>2020-02-19T03:30:39.000Z</published>
    <updated>2020-02-19T03:31:48.819Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>List</code>接口的可调整大小的数组实现。实现所有可选的 <code>List</code> 操作，并允许包括 <code>null</code> 的所有元素。除了实现 <code>List</code> 接口之外，此类还提供一些方法来操纵内部用于存储列表的数组的大小。（此类与<code>Vector</code>大致等效 ，但它是不同步的。）</p><p><code>size</code>, <code>isEmpty</code>, <code>get</code>, <code>set</code>, <code>iterator</code>, 和 <code>listIterator</code> 在 <code>O(1)</code> 时间内运行。<code>add</code>操作运行<em>摊销恒定时间</em>，添加N元素需要<code>O(n)</code>的时间。其他操作均以线性时间运行（大致而言）。</p><p>每个<code>ArrayList</code>实例都有一个<em>容量</em>。容量是用于在列表中存储元素的数组的大小。它总是至少与列表大小一样大。随着元素添加到ArrayList中，其容量会自动增长。除了添加元素具有固定的摊销时间成本外，没有指定增长策略的详细信息。</p><p>应用程序可以使用<code>ensureCapacity</code> 操作在添加大量元素之前增加<code>ArrayList</code>实例的容量。这可以减少增量重新分配的数量。</p><p><strong>请注意，ArrayList是线程不安全的。</strong> 如果多个线程同时访问<code>ArrayList</code>实例，并且至少有一个线程在做是修改操作，则 <em>必须</em>在外部进行同步。（<u>修改是添加或删除一个或多个元素，或显式调整后备数组的大小的任何操作；仅设置元素的值不是修改。</u>）通常通过在自然封装了对象的某个对象上进行同步来实现。清单。如果不存在这样的对象，则应使用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedList-java.util.List-" target="_blank" rel="noopener"><code>Collections.synchronizedList</code></a> 方法“包装”列表 。最好在创建时完成此操作，以防止意外的不同步访问列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList（new ArrayList（...））;</span><br></pre></td></tr></table></figure><p>此类<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#iterator--" target="_blank" rel="noopener"><code>iterator</code></a>和 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#listIterator-int-" target="_blank" rel="noopener"><code>listIterator</code></a>方法返回的迭代器是<u>快速失败的</u>：如果在创建迭代器之后的任何时间对列表进行结构修改，则除了通过迭代器自己的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html#remove--" target="_blank" rel="noopener"><code>remove</code></a>或 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html#add-E-" target="_blank" rel="noopener"><code>add</code></a>方法外，迭代器都将抛出 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ConcurrentModificationException.html" target="_blank" rel="noopener"><code>ConcurrentModificationException</code></a>。因此，面对并发修改，迭代器将快速而干净地失败，而不是在未来的不确定时间内冒任意，不确定的行为的风险。</p><p>注意，迭代器的快速失败行为无法得到保证，因为通常来说，在存在不同步的并发修改的情况下，不可能做出任何严格的保证。快速失败的迭代器会<code>ConcurrentModificationException</code>尽力而为。因此，编写依赖于此异常的程序的正确性是错误的： <em>迭代器的快速失败行为应仅用于检测错误。</em></p><h3 id="源码细节"><a href="#源码细节" class="headerlink" title="源码细节"></a>源码细节</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 序列化id */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量：10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定容量为０或Collection为０的时候 &lt;code&gt;elementData&lt;/code&gt; 的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与 EMPTY_ELEMENTDATA的区别在于默认不指定容量大小的时候</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList存储的数据，不可序列化，ArrayList的容量就是这个数组buffer的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的实际大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定容量</span></span><br><span class="line"><span class="comment"> * - 大于0：创建对应大小的数组</span></span><br><span class="line"><span class="comment"> * - 等于0：使用空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认的空数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从集合中获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><blockquote><p>初始容量为 10</p><p>若数组长度小于<u>要扩容的最小值</u>：</p><ul><li><p>默认扩容 1/2</p></li><li><p>如果还不够就扩容到 <u>最小扩容值</u></p></li><li><p>若扩容后的大小超出设置的数组最大容量（<em>Integer.MAX_VALUE - 8</em>）</p><ul><li><p>如果 <u>要扩容的最小值</u> 溢出，抛出异常</p></li><li><p>如果 <u>要扩容的最小值</u> 小于最大容量值，就使用最大容量值作为扩容后的大小</p></li><li><p>如果大于，使用 <code>Interger.MAX_VALUE</code> 作为扩容后的大小</p></li></ul></li></ul></blockquote><h5 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize"></a><strong><em>trimToSize</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修建当前容量为实际大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">                ? EMPTY_ELEMENTDATA</span><br><span class="line">                : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get"><a href="#get" class="headerlink" title="get"></a><strong><em>get</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取下标所在的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 范围检查，index无效会抛出异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="set"><a href="#set" class="headerlink" title="set"></a><strong><em>set</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 范围检查+1</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"><span class="comment">// 获取旧值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">// 设置新值，返回旧值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add"><a href="#add" class="headerlink" title="add"></a><strong><em>add</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确认容量，进行扩容策略处理</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// calculateCapacity 计算最小容量＝minCapacity，若 elementData 为默认的空数组，返回最小容量和初始大小的最大值</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果最小容量大于当前数组的大小，扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组分配的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 扩容的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为原来的 3/2，扩容 1/2</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果还不够，设置为最小容量的值</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果新容量超出规定的最大值（Integer.MAX_VALUE - 8）</span></span><br><span class="line">        <span class="comment">// 若最小容量也大于规定的最大值，就扩容到 Integer.MAX_VALUE</span></span><br><span class="line">        <span class="comment">// 否则就扩容到规定的最大值</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 溢出，超出可分配的范围</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a><strong><em>add(int index, E element)</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查下标是否合理</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 容量操作</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// index - size 区域后移</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a><strong><em>remove</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 范围检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 获取旧值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算需要移动的元素数量</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 前移</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    <span class="comment">// 容量-1</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除遇到的第一个元素 返回是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 和普通的remove区别只在于没有进行范围检查和旧值获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于-modCount"><a href="#关于-modCount" class="headerlink" title="关于 modCount"></a>关于 modCount</h4><p>上面的源码中我们可以看到 <code>modCount++</code> 出现了多次。</p><p>源码的doc文档是这样描述的：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200219111409.png" alt></p><p><code>modCount</code> 是结构修改的次数（结构修改参考描述中的说明），这个字段用于 <code>iterator</code>、<code>listIterator</code> 方法所返回的 <code>iterator</code> 实现中：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200219111839.png" alt></p><p>在 <code>next</code>、<code>remove</code>、<code>previous</code>、<code>set</code>、<code>add</code> 操作中，如果值得改变不是所预期的，意味着多个线程同时修改了 List，这样就会抛出异常：<code>ConcurrentModificationException</code> 。这也是所说的快速失败机制。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Collection" scheme="https://phoenixxc.github.io/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="https://phoenixxc.github.io/posts/69e7b86f/"/>
    <id>https://phoenixxc.github.io/posts/69e7b86f/</id>
    <published>2020-02-17T07:14:56.000Z</published>
    <updated>2020-02-17T11:55:48.315Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个类只能构建一个对象的设计模式。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能通过一个私有的构造方法去创建对象，而创建对象的前提是此对象不存在。</p><p>一开始 <code>instance</code> 为空，当需要时才会创建对象，称之为：<strong>懒汉模式</strong></p><p>那么如果一开始就创建 <code>instance</code> ，不在进行判空操作，我们称之为：<strong>饿汉模式</strong></p><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton singleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉模式升级版-——双重加锁"><a href="#懒汉模式升级版-——双重加锁" class="headerlink" title="懒汉模式升级版 ——双重加锁"></a>懒汉模式升级版 ——双重加锁</h4><p><strong>上面的懒汉模式存在线程安全的问题</strong>：</p><ul><li>当 <code>instance == null</code> 的情况下，假设目前有两个线程A、B。两个线程同时调用 <code>getInstance</code> 方法，由于 <code>instance == null</code> 满足，两个线程同时通过了条件判断，执行 <code>new</code> 创建对象。显然这样就会使得本来只想有一个实例的对象出现了多次。</li></ul><p>基于此，我们可以更新代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonCheckTwice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingletonCheckTwice</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingletonCheckTwice instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingletonCheckTwice <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一重判断</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用锁机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingletonCheckTwice.class) &#123;</span><br><span class="line">                <span class="comment">// 第二重判断</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingletonCheckTwice();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用同步锁的原因：</strong></p><ul><li>防止 <code>new</code> 多次，在 <code>new</code> 操作前加上同步锁，锁住整个类</li></ul><p><strong>第二次判断的原因：</strong></p><ul><li>两个线程会存在同时通过第一重检测的情况，当第一个线程创建对象后，若不进行再一次判空检测，还会再创建一个对象。</li></ul><p><strong>不在第一次检测加锁：</strong></p><ul><li>使用同步锁比两次 <code>if</code> 更加消耗性能，由于单例的缘故，绝大多数情况下访问方法时已经有了单例对象，再第一重加上同步锁反而会带来性能消耗，远不如第一判断获取对象要快。</li></ul><h4 id="懒汉模式-——线程安全终极版"><a href="#懒汉模式-——线程安全终极版" class="headerlink" title="懒汉模式 ——线程安全终极版"></a>懒汉模式 ——线程安全终极版</h4><p>上述的操作过程中，我们实现了相对安全的单例模式的代码。这是并没有做到绝对的线程安全。</p><p>真正的原因涉及到 <em>JVM</em> 的 <strong>指令重排</strong>：</p><blockquote><p>在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列，一般而言，这个指令序列是会输出确定的结果；以确保每一次的执行都有确定的结果。但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化，在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序，在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。<br>————————————————<br>版权声明：本文为CSDN博主「bladestone」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/blueheart20/article/details/52117761" target="_blank" rel="noopener">https://blog.csdn.net/blueheart20/article/details/52117761</a></p></blockquote><p>比如，创建对象：<code>instance = new LazySingletonCheckTwice()</code> 会被编译为：</p><ol><li><code>memory = allocate()</code> 分配内存空间</li><li><code>ctorInstance(memory)</code> 初始化对象</li><li><code>instance = memory</code> 设置 instance 指向分配的内存地址</li></ol><p>然而这些指令可能会经过 <em>JVM</em> 和 <em>CPU</em> 的优化后，重排为：1、3、2 这样的顺序。</p><p>我们还是假设有两个线程A、B，当 A 线程创建对象时执行了 1、3，instance 已经不在指向 <code>null</code>，此刻若<u>线程 B 获得了CPU，将不会通过第一重检测，直接返回一个未完全初始化的对象</u>。</p><p>为了防止指令重排所带来的问题，我们可以使用 <code>volatile</code> 关键字：</p><blockquote><ol start="6"><li><p>如何防止指令重排</p><p>volatile 关键字可以<strong>保证变量的可见性</strong>，因为对 volatile 的操作都在Main Memory中，而Main Memory 是被所有线程所共享的，这里的代价就是牺牲了性能，无法利用寄存器或Cache，因为它们都不是全局的，无法保证可见性，可能产生脏读。<br>volatile 还有一个作用就是<strong>局部阻止重排序的发生，对volatile变量的操作指令都不会被重排序，因为如果重排序，又可能产生可见性问题。</strong><br>在保证可见性方面，锁（包括显式锁、对象锁）以及对原子变量的读写都可以确保变量的可见性。但是实现方式略有不同，例如同步锁保证得到锁时从内存里重新读入数据刷新缓存，释放锁时将数据写回内存以保数据可见，而volatile变量干脆都是读写内存。</p></li><li><p>可见性</p><p>这里提到的<u>可见性是指前一条程序指令的执行结果，可以被后一条指令读到或者看到，称之为可见性</u>。反之为不可见性。这里主要描述的是在多线程环境下，指令语句之间对于结果信息的读取即时性。<br>————————————————<br>版权声明：本文为CSDN博主「bladestone」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/blueheart20/article/details/52117761" target="_blank" rel="noopener">https://blog.csdn.net/blueheart20/article/details/52117761</a></p></li></ol></blockquote><h3 id="静态内部类实现单例模式"><a href="#静态内部类实现单例模式" class="headerlink" title="静态内部类实现单例模式"></a>静态内部类实现单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton INSTANCE = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部无法访问静态内部类，只有通过 <code>getInstance()</code> 来获取实例，再调用方法的时候，静态内部类才会加载（利用 <code>classloader</code> 的加载机制实现<strong>懒加载</strong>），同时这种方式也保证了线程安全。</p><h3 id="上面的Bug"><a href="#上面的Bug" class="headerlink" title="上面的Bug"></a>上面的Bug</h3><p>上面的方法说到底还是使用私有构造器去创建对象，那么 <em>Java</em> 中反射可以打破上面单例的约束，只要设置构造器为可访问，便可以任意调用构造器去创建足够多的对象。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200217181224.png" alt></p><p>那么如何防止这个逆天Bug呢：</p><ul><li><p>使用枚举</p><p><em>JVM</em> 会阻止反射获取枚举类的私有构造方法</p></li><li><p>在构造方法中可以这样操作：当已有实例时，抛出异常；没有则创建对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (StaticInnerClassSingleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            first = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例对象已存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200217182218.png" alt></p><p>这里还是用了同步锁，防止两个操作反射的线程在通过 <code>if</code> 判断后，同时通过构造器去创建对象。</p><p>这样，在标记变量没有 <code>setter</code> 方法且为私有基本类型的变量的情况下，就算使用反射也无法通过强行更改标记变量的值来创建第二个对象。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
    
      <category term="DesignPattern" scheme="https://phoenixxc.github.io/tags/DesignPattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="https://phoenixxc.github.io/posts/e3d6aa41/"/>
    <id>https://phoenixxc.github.io/posts/e3d6aa41/</id>
    <published>2020-02-15T11:52:44.000Z</published>
    <updated>2020-02-17T11:55:48.315Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>代理模式是对象的结构模式。代理模式给某一个对象提供代理对象，并有代理对象控制对源对象的应用。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><blockquote><p>我们在写一个功能函数时，经常需要在其中写入与功能不是直接相关但很有必要的代 码，如日志记录，信息发送，安全和事务支持等，这些枝节性代码虽然是必要的，但它会带来以下麻烦：</p><ol><li>枝节性代码游离在功能性代码之外，它不是函数的目的，这是对OO是一种破坏</li><li>枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合，可重用性降低</li><li>从法理上说，枝节性代码应该 <code>监视着功能性代码，然后采取行动，而不是功能性代码</code> 通知枝节性代码采取行动，这好比吟游诗人应该是主动记录骑士的功绩而不是骑士主动要求诗人记录自己的功绩</li></ol></blockquote><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>角色</strong></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200214163156.png" style="zoom:67%"></p><ul><li>抽象对象角色：声明了目标对象和代理对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象</li><li>目标对象角色：定义了代理对象所代表的目标对象</li><li>代理对象角色：代理对象内部包含目标对象的引用，从而可以在任何时候操作目标对象。代理对象提供与目标对象相同的接口，可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作。而非单纯的把调用传递给目标对象。</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理在使用时，要定义好接口或者父类，被代理对象和真实对象继承相同的接口或父类。</p><p>静态代理中，一个目标对象对应一个代理对象，彼此的关系和类型都需要在编译前约定好。</p><p>缺点：存在代码重复、不利于代码的后续维护、灵活性不高</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200214165512.png" alt></p><p><strong><em>Movie</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 播放影片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>TwelveMonkeysMovie</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwelveMonkeysMovie</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"playing... [12 Monkeys]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Cinema</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Movie realMovie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(Movie realMovie)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realMovie = realMovie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doSome(<span class="keyword">true</span>);</span><br><span class="line">        realMovie.play();</span><br><span class="line">        doSome(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">(<span class="keyword">boolean</span> isStart)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isStart) &#123;</span><br><span class="line">            System.out.println(<span class="string">"电影马上开始，请各位就坐，为了电影的播放效果，请将手机关机或调至静音。"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"请大家有序立场，携带好自己的随身物品，照顾好自己的小孩。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TwelveMonkeysMovie monkeysMovie = <span class="keyword">new</span> TwelveMonkeysMovie();</span><br><span class="line">    Movie movie = <span class="keyword">new</span> Cinema(monkeysMovie);</span><br><span class="line">    movie.play();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20200214165852.png" style="zoom:80%"></p><h3 id="动态代理（JDK代理）"><a href="#动态代理（JDK代理）" class="headerlink" title="动态代理（JDK代理）"></a>动态代理（JDK代理）</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol><li><p>运行期间，通过 <strong>反射机制</strong> 创建实现了一组给定接口的类</p></li><li><p>在运行时生成的 <code>class</code> 要实现给定的一组 <code>interface</code>，因此 <code>class</code> 的实例可以当做 <code>interface</code> 的任何一个来使用。</p><p>同时要提供一个 <code>handler</code>，接管实际的工作。</p></li><li><p>接口中声明的方法被转移到调用处理器的 <code>InvocationHandler.invoke</code> 集中处理，在接口方法数量多的回收可以灵活处理，使类职责更加单一，复用性更强。</p></li></ol><p>使用<code>JDK</code>反射动态生成类，不需要第三方库就可以代理，使用条件：</p><ol><li><p>必须实现<code>InvocationHandler</code>接口；</p></li><li><p>使用<code>Proxy.newProxyInstance</code>产生代理对象；</p></li><li><p><strong>被代理的对象必须要实现接口</strong>；</p></li></ol><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>代理类所在的包：<code>java.lang.reflect.Proxy</code></p><p>使用其静态方法：<code>static Object newProxyInstance(ClassLoader loader, Class [] interfaces, InvocationHandler handler)</code> 实现代理。</p><ul><li><code>ClassLoader loader</code>: 指定当前目标对象使用类加载器,用null表示默认类加载器</li><li><code>Class [] interfaces</code>: 需要实现的接口数组</li><li><code>InvocationHandler handler</code>: 调用处理器,执行目标对象的方法时,会触发调用处理器的方法,从而把当前执行目标对象的方法作为参数传入</li></ul><p><code>java.lang.reflect.InvocationHandler</code>：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象</span><br><span class="line">// 第三个方法是调用参数。</span><br><span class="line">Object invoke(Object proxy, Method method, Object[] args);</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><strong><em>DemoInterface</em></strong>（目标类实现的接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>ProxyFactory</em></strong>（代理类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为目标对象生成代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="comment">// InvocationHandler.invoke(proxy, method, args) 方法</span></span><br><span class="line">                (proxy, method, args) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"proxy: "</span> + proxy.getClass());</span><br><span class="line">                    System.out.println(<span class="string">"method: "</span> + method.getDeclaringClass() + <span class="string">" -&gt; "</span> + method.getName());</span><br><span class="line">                    System.out.println(<span class="string">"args: "</span> + Arrays.toString(args));</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"开始事务2"</span>);</span><br><span class="line">                    Object returnValue = method.invoke(target, args);</span><br><span class="line">                    System.out.println(<span class="string">"提交事务2"</span>);</span><br><span class="line">                    <span class="keyword">return</span> returnValue;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Main</em></strong>（测试）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DemoInterface demoInterface = <span class="keyword">new</span> DemoInterfaceImpl(<span class="string">"demo"</span>);</span><br><span class="line">    DemoInterface demoInterfaceProxy = </span><br><span class="line">        (DemoInterface) <span class="keyword">new</span> ProxyFactory(demoInterface).getProxyInstance();</span><br><span class="line">    demoInterfaceProxy.echo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cglib-代理（子类代理）"><a href="#Cglib-代理（子类代理）" class="headerlink" title="Cglib 代理（子类代理）"></a>Cglib 代理（子类代理）</h3><p>静态代理和Jdk动态代理都要求目标对象实现一个接口或多个接口（静态代理代理对象也需要实现接口）。</p><p><strong>当目标对象未实现任何接口</strong>，可以使用构建目标对象之类的方法实现动态代理，即 <code>Cglib</code>。</p><p><strong>底层实现</strong>：使用字节码处理框架 <code>ASM</code> 转换字节码并生成新的子类。</p><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><ol><li><p>自定义 <code>MethodInterceptor</code> 实现类，实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * sub：cglib生成的代理对象</span></span><br><span class="line"><span class="comment">  * method：被代理对象方法</span></span><br><span class="line"><span class="comment">  * objects：方法入参</span></span><br><span class="line"><span class="comment">  * methodProxy: 代理方法</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="function">Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span></span></span><br></pre></td></tr></table></figure></li><li><p>生成 <code>CGLIB</code> 代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为目标对象创建代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 增强器</span></span><br><span class="line">    Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="comment">// 设置父类</span></span><br><span class="line">    en.setSuperclass(target.getClass());</span><br><span class="line">    <span class="comment">// 设置回调对象, 即 MethodInterceptor</span></span><br><span class="line">    <span class="comment">// 方法上是 Callback&lt;T&gt; 即可</span></span><br><span class="line">    en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建类</span></span><br><span class="line">    <span class="keyword">return</span> en.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用目标代理对象方法</p></li></ol><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p><strong><em>ProxyFactory</em></strong>（代理工厂）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        System.out.println(<span class="string">"target: "</span> + target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为目标对象创建代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增强器</span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 设置回调对象</span></span><br><span class="line">        en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建类</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"obj: "</span> + obj.getClass());</span><br><span class="line">        System.out.println(<span class="string">"method: "</span> + method.getDeclaringClass() + <span class="string">" -&gt; "</span> + method.getName());</span><br><span class="line">        System.out.println(<span class="string">"args: "</span> + Arrays.toString(args));</span><br><span class="line">        System.out.println(<span class="string">"methodProxy: "</span> + proxy.getClass());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\nbegin"</span>);</span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Main</em></strong>（测试）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> Demo());</span><br><span class="line">    Demo demo = (Demo) proxyFactory.getProxyInstance();</span><br><span class="line">    demo.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
    
      <category term="DesignPattern" scheme="https://phoenixxc.github.io/tags/DesignPattern/"/>
    
  </entry>
  
  <entry>
    <title>Markdown测试</title>
    <link href="https://phoenixxc.github.io/posts/45babedb/"/>
    <id>https://phoenixxc.github.io/posts/45babedb/</id>
    <published>2020-01-10T07:39:30.000Z</published>
    <updated>2020-01-11T09:31:59.635Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h1 id="欢迎使用-Markdown在线编辑器-MdEditor"><a href="#欢迎使用-Markdown在线编辑器-MdEditor" class="headerlink" title="欢迎使用 Markdown在线编辑器 MdEditor"></a>欢迎使用 Markdown在线编辑器 MdEditor</h1><p><strong>Markdown是一种轻量级的「标记语言」</strong></p><p><img src="https://www.mdeditor.com/images/logos/markdown.png" alt="markdown" title="markdown"></p><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”</p><h2 id="MdEditor是一个在线编辑Markdown文档的编辑器"><a href="#MdEditor是一个在线编辑Markdown文档的编辑器" class="headerlink" title="MdEditor是一个在线编辑Markdown文档的编辑器"></a>MdEditor是一个在线编辑Markdown文档的编辑器</h2><p><em>MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。</em></p><blockquote><p>Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如<del>Pandoc</del>，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p></blockquote><p>MdEditor源于Pandao的JavaScript开源项目，开源地址<a href="https://github.com/pandao/editor.md" title="Editor.md" target="_blank" rel="noopener">Editor.md</a>，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。</p><p><img src="https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png" alt="Pandao editor.md" title="Pandao editor.md"></p><h2 id="MdEditor的功能列表演示"><a href="#MdEditor的功能列表演示" class="headerlink" title="MdEditor的功能列表演示"></a>MdEditor的功能列表演示</h2><h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H5-1"><a href="#标题H5-1" class="headerlink" title="标题H5"></a>标题H5</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr><p><del>删除线</del> <s>删除线（开启识别HTML标签时）</s></p><p><em>斜体字</em> <em>斜体字</em></p><p><strong>粗体</strong> <strong>粗体</strong></p><p><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p><p>上标：X<sub>2</sub>，下标：O<sup>2</sup></p><p><strong>缩写(同HTML的abbr标签)</strong></p><blockquote><p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p></blockquote><p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p><h3 id="引用-Blockquotes"><a href="#引用-Blockquotes" class="headerlink" title="引用 Blockquotes"></a>引用 Blockquotes</h3><blockquote><p>引用文本 Blockquotes</p></blockquote><p>引用的行内混合 Blockquotes</p><blockquote><p>引用：如果想要插入空白换行<code>即&lt;br /&gt;标签</code>，在插入处先键入两个以上的空格然后回车即可，<a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a>。</p></blockquote><h3 id="锚点与链接-Links"><a href="#锚点与链接-Links" class="headerlink" title="锚点与链接 Links"></a>锚点与链接 Links</h3><p><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a><br><a href="https://www.mdeditor.com/" title="普通链接带标题" target="_blank" rel="noopener">普通链接带标题</a><br>直接链接：<a href="https://www.mdeditor.com" target="_blank" rel="noopener">https://www.mdeditor.com</a><br>[锚点链接][anchor-id]<br>[anchor-id]: <a href="https://www.mdeditor.com/" target="_blank" rel="noopener">https://www.mdeditor.com/</a><br><a href="mailto:test.test@gmail.com" target="_blank" rel="noopener">mailto:test.test@gmail.com</a><br>GFM a-tail link @pandao<br>邮箱地址自动链接 <a href="mailto:test.test@gmail.com" target="_blank" rel="noopener">test.test@gmail.com</a> <a href="mailto:www@vip.qq.com" target="_blank" rel="noopener">www@vip.qq.com</a></p><blockquote><p>@pandao</p></blockquote><h3 id="多语言代码高亮-Codes"><a href="#多语言代码高亮-Codes" class="headerlink" title="多语言代码高亮 Codes"></a>多语言代码高亮 Codes</h3><h4 id="行内代码-Inline-code"><a href="#行内代码-Inline-code" class="headerlink" title="行内代码 Inline code"></a>行内代码 Inline code</h4><p>执行命令：<code>npm install marked</code></p><h4 id="缩进风格"><a href="#缩进风格" class="headerlink" title="缩进风格"></a>缩进风格</h4><p>即缩进四个空格，也做为实现类似 <code>&lt;pre&gt;</code> 预格式化文本 ( Preformatted Text ) 的功能。</p><pre><code>&lt;?php    echo &quot;Hello world!&quot;;?&gt;</code></pre><p>预格式化文本：</p><pre><code>| First Header  | Second Header || ------------- | ------------- || Content Cell  | Content Cell  || Content Cell  | Content Cell  |</code></pre><h4 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HTML-代码-HTML-codes"><a href="#HTML-代码-HTML-codes" class="headerlink" title="HTML 代码 HTML codes"></a>HTML 代码 HTML codes</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mate</span> <span class="attr">charest</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"Editor.md, Markdown, Editor"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">            body&#123;font-size:14px;color:#444;font-family: "Microsoft Yahei", Tahoma, "Hiragino Sans GB", Arial;background:#fff;&#125;</span><br><span class="line">            ul&#123;list-style: none;&#125;</span><br><span class="line">            img&#123;border:none;vertical-align: middle;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"text-xxl"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-green"</span>&gt;</span>Plain text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片-Images"><a href="#图片-Images" class="headerlink" title="图片 Images"></a>图片 Images</h3><p>图片加链接 (Image + Link)：</p><p><a href="https://www.mdeditor.com/images/logos/markdown.png" title="markdown" target="_blank" rel="noopener"><img src="https://www.mdeditor.com/images/logos/markdown.png" alt></a></p><blockquote><p>Follow your heart.</p></blockquote><hr><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 Lists"></a>列表 Lists</h3><h4 id="无序列表（减号）Unordered-Lists"><a href="#无序列表（减号）Unordered-Lists" class="headerlink" title="无序列表（减号）Unordered Lists (-)"></a>无序列表（减号）Unordered Lists (-)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（星号）Unordered-Lists"><a href="#无序列表（星号）Unordered-Lists" class="headerlink" title="无序列表（星号）Unordered Lists (*)"></a>无序列表（星号）Unordered Lists (*)</h4><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h4 id="无序列表（加号和嵌套）Unordered-Lists"><a href="#无序列表（加号和嵌套）Unordered-Lists" class="headerlink" title="无序列表（加号和嵌套）Unordered Lists (+)"></a>无序列表（加号和嵌套）Unordered Lists (+)</h4><ul><li>列表一</li><li>列表二<ul><li>列表二-1</li><li>列表二-2</li><li>列表二-3</li></ul></li><li>列表三<ul><li>列表一</li><li>列表二</li><li>列表三</li></ul></li></ul><h4 id="有序列表-Ordered-Lists"><a href="#有序列表-Ordered-Lists" class="headerlink" title="有序列表 Ordered Lists (-)"></a>有序列表 Ordered Lists (-)</h4><ol><li>第一行</li><li>第二行</li><li>第三行</li></ol><h4 id="GFM-task-list"><a href="#GFM-task-list" class="headerlink" title="GFM task list"></a>GFM task list</h4><ul><li style="list-style:none"><input type="checkbox" checked>GFM task list 1</li><li style="list-style:none"><input type="checkbox" checked>GFM task list 2</li><li style="list-style:none"><input type="checkbox">GFM task list 3<ul><li style="list-style:none"><input type="checkbox">GFM task list 3-1</li><li style="list-style:none"><input type="checkbox">GFM task list 3-2</li><li style="list-style:none"><input type="checkbox">GFM task list 3-3</li></ul></li><li style="list-style:none"><input type="checkbox">GFM task list 4<ul><li style="list-style:none"><input type="checkbox">GFM task list 4-1</li><li style="list-style:none"><input type="checkbox">GFM task list 4-2</li></ul></li></ul><hr><h3 id="绘制表格-Tables"><a href="#绘制表格-Tables" class="headerlink" title="绘制表格 Tables"></a>绘制表格 Tables</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">$1</td><td style="text-align:center">234</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><table><thead><tr><th>Function name</th><th>Description</th></tr></thead><tbody><tr><td><code>help()</code></td><td>Display the help window.</td></tr><tr><td><code>destroy()</code></td><td><strong>Destroy your computer!</strong></td></tr></tbody></table><table><thead><tr><th style="text-align:left">Left-Aligned</th><th style="text-align:center">Center Aligned</th><th style="text-align:right">Right Aligned</th></tr></thead><tbody><tr><td style="text-align:left">col 3 is</td><td style="text-align:center">some wordy text</td><td style="text-align:right">$1600</td></tr><tr><td style="text-align:left">col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td style="text-align:left">zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><table><thead><tr><th>Item</th><th style="text-align:right">Value</th></tr></thead><tbody><tr><td>Computer</td><td style="text-align:right">$1600</td></tr><tr><td>Phone</td><td style="text-align:right">$12</td></tr><tr><td>Pipe</td><td style="text-align:right">$1</td></tr></tbody></table><hr><h4 id="特殊符号-HTML-Entities-Codes"><a href="#特殊符号-HTML-Entities-Codes" class="headerlink" title="特殊符号 HTML Entities Codes"></a>特殊符号 HTML Entities Codes</h4><p>&copy; &amp; &uml; &trade; &iexcl; &pound;<br>&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;</p><p>X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo;</p><p>18&ordm;C &quot; &apos;</p><p>[========]</p><h3 id="Emoji表情-smiley"><a href="#Emoji表情-smiley" class="headerlink" title="Emoji表情 :smiley:"></a>Emoji表情 :smiley:</h3><blockquote><p>Blockquotes :star:</p></blockquote><h4 id="GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x"><a href="#GFM-task-lists-amp-Emoji-amp-fontAwesome-icon-emoji-amp-editormd-logo-emoji-editormd-logo-5x" class="headerlink" title="GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:"></a>GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x:</h4><ul><li style="list-style:none"><input type="checkbox" checked>:smiley: @mentions, :smiley: #refs, <a href>links</a>, <strong>formatting</strong>, and <del>tags</del> supported :editormd-logo:;</li><li style="list-style:none"><input type="checkbox" checked>list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;</li><li style="list-style:none"><input type="checkbox" checked>[ ] :smiley: this is a complete item :smiley:;</li><li style="list-style:none"><input type="checkbox">[]this is an incomplete item <a href="#">test link</a> :fa-star: @pandao;</li><li style="list-style:none"><input type="checkbox">[ ]this is an incomplete item :fa-star: :fa-gear:;<ul><li style="list-style:none"><input type="checkbox">:smiley: this is an incomplete item <a href="#">test link</a> :fa-star: :fa-gear:;</li><li style="list-style:none"><input type="checkbox">:smiley: this is :fa-star: :fa-gear: an incomplete item <a href="#">test link</a>;</li></ul></li></ul><h4 id="反斜杠-Escape"><a href="#反斜杠-Escape" class="headerlink" title="反斜杠 Escape"></a>反斜杠 Escape</h4><p>*literal asterisks*</p><p>[========]</p><h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><p>$$E=mc^2$$</p><p>行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。</p><p>$$x &gt; y$$</p><p>$$(\sqrt{3x-1}+(1+x)^2)$$</p><p>$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$</p><p>多行公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2</span><br><span class="line">\leq</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)</span><br><span class="line">\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\displaystyle</span><br><span class="line">    \frac&#123;1&#125;&#123;</span><br><span class="line">        \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;</span><br><span class="line">        \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;</span><br><span class="line">        1+\frac&#123;e^&#123;-6\pi&#125;&#125;</span><br><span class="line">        &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125;</span><br><span class="line">         &#123;1+\cdots&#125; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = \int_&#123;-\infty&#125;^\infty</span><br><span class="line">    \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125;</span><br><span class="line">    \,d\xi</span><br></pre></td></tr></table></figure><h3 id="分页符-Page-break"><a href="#分页符-Page-break" class="headerlink" title="分页符 Page break"></a>分页符 Page break</h3><blockquote><p>Print Test: Ctrl + P</p></blockquote><p>[========]</p><h3 id="绘制流程图-Flowchart"><a href="#绘制流程图-Flowchart" class="headerlink" title="绘制流程图 Flowchart"></a>绘制流程图 Flowchart</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 用户登陆</span><br><span class="line">op=&gt;operation: 登陆操作</span><br><span class="line">cond=&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e=&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>[========]</p><h3 id="绘制序列图-Sequence-Diagram"><a href="#绘制序列图-Sequence-Diagram" class="headerlink" title="绘制序列图 Sequence Diagram"></a>绘制序列图 Sequence Diagram</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;欢迎使用-Markdown在线编辑器-MdEditor&quot;&gt;&lt;a href=&quot;#欢迎使用-Markdown在线编辑器-MdEditor&quot; cl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MyBatis的解析和运行原理</title>
    <link href="https://phoenixxc.github.io/posts/d90473f8/"/>
    <id>https://phoenixxc.github.io/posts/d90473f8/</id>
    <published>2019-09-05T13:58:28.000Z</published>
    <updated>2019-09-07T13:41:36.833Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="构建-SqlSessionFactory-过程"><a href="#构建-SqlSessionFactory-过程" class="headerlink" title="构建 SqlSessionFactory 过程"></a>构建 SqlSessionFactory 过程</h2><h3 id="重要类的说明"><a href="#重要类的说明" class="headerlink" title="重要类的说明"></a>重要类的说明</h3><p><code>SqlSessionFactory</code></p><ul><li>描述：MyBatis 核心类之一</li><li>作用：【最重要】提供创建 MyBatis 的核心接口 <code>SqlSession</code></li><li><p>创建：</p><ul><li><p>使用 Builder 模式创建，实际中可以通过 <code>SqlSessionFactoryBuilder</code> 去构建</p><ol><li><p>通过 <code>org.apache.ibatis.builder.xml.XMLConfigBuilder</code> 解析 XML 配置文件，将读取的参数存入 <code>org.apache.ibatis.session.Configuration</code> 类对象中</p><blockquote><p><code>Configuration</code> 采用单例模式，几乎所有的配置内容都存放在这个单例对象中</p></blockquote></li><li><p>使用 <code>Configuration</code> 对象创建 <code>SqlSessionFactory</code>，<code>SqlSessionFactory</code> 是一个接口，MyBatis 提供了默认的实现类 <code>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory</code></p></li></ol></li><li>需要提供配置文件和相关参数</li></ul></li></ul><p><code>Configuration</code></p><ul><li>描述：存储了 MyBatis 的几乎所有的配置信息</li><li>作用：在构建 <code>SqlSessionFactory</code> 的过程中起重要作用：<ul><li>读入配置文件，包括基础的 XML 和映射器 XML（或注解）</li><li>初始化基础配置</li><li>提供单例，为创建 <code>SessionFactory</code> 服务提供配置的参数</li><li>执行一些重要对象的初始化方法</li></ul></li></ul><blockquote><p>在读取并解析配置文件后，将其保存在 <code>Configuration</code> 对象中后，会做一些初始化操作：</p><ul><li><code>properties</code> 全局参数</li><li><code>typeAliases</code> 别名</li><li><code>Plugins</code> 插件</li><li><code>objectFactory</code> 对象工厂</li><li><code>objectWrapperFactory</code> 对象包装工厂</li><li><code>reflectionFactory</code> 反射工厂</li><li><code>settings</code> 环境参数</li><li><code>environments</code> 数据库环境</li><li><code>databaseIdProvider</code> 数据库标识</li><li><code>typeHandlers</code> 类型转换器</li><li><strong><code>Mappers</code> 映射器</strong></li></ul><blockquote><p><strong><code>Mappers</code> 映射器</strong> 是最重要的内容，在插件中需要频繁的访问，也是 MyBatis 底层运行原理的基础</p></blockquote></blockquote><h3 id="※-构建映射器的内部组成"><a href="#※-构建映射器的内部组成" class="headerlink" title="※ 构建映射器的内部组成"></a>※ 构建映射器的内部组成</h3><p>当 XMLConfigBuilder 解析 XML 的时候，会将每一个 SQL 与其配置的内容保存起来。在 MyBatis 中一条 SQL 和相关的配置信息由三个部分组成：<code>MapperStatement</code>、<code>SqlSource</code>、<code>BoundSql</code></p><ul><li><p><code>MapperStatement</code></p><p>保存一个映射器节点（select | insert | …）的内容。是一个类，包括了很多配置的 SQL、SQL 的 id、缓存信息、resultMap、parameterType、resultType、resultMap 等重要配置信息。</p><p>有一个重要的属性：<em><code>sqlSource</code></em>（MyBatis 可以通过它来获取 SQL 配置的所有信息）</p></li><li><p><code>SqlSource</code></p><p>它是一个接口，是 <code>MapperStatement</code>的一个属性,其实现类有：<code>DynamicSqlSource</code>、<code>ProviderSqlSource</code>、<code>RawSqlSource</code>、<code>StaticSqlSource</code>。</p><p>作用：根据上下文和参数解析生成需要的 SQL，接口只定义了一个接口方法 —— <code>getBoundSql(parameterObject)</code>，用于提供 <code>BoundSql</code> 对象。</p></li><li><p><code>BoundSql</code></p><p>是一个结果对象，是建立 SQL 和参数的地方，有三个常用的属性：<code>sql</code>、<code>parameterObject</code>、<code>parameterMappings</code></p></li></ul><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907174942.png" alt="映射器的内部组成"></p><p>最终的参数和 SQL 都反映在 <code>BoundSql</code> 类对象上，在插件中往往拿到它就可以获得当前运行的 SQL 和参数，从而修改运行过程以满足需求。</p><p>下面分别介绍 <code>BoundSql</code> 提供的三个主要的属性：<code>sql</code>、<code>parameterObject</code>、<code>parameterMappings</code></p><ul><li><p><code>parameterObject</code></p><p>为参数本身，可以传递简单对象、POJO、或者 Map、<code>@Param</code> 注解的参数</p><p>关于它的一些规则：</p><ul><li>传递简单对象时：　会将基本类型参数装箱为对应的对象来传递</li><li>传递 POJO 或 Map： 　<code>parameterObject</code> 就是对应的对象</li><li>传递多个对象：　如果没有 <code>@Param</code> 注解，会把 <code>parameterObject</code> 变为一个 <code>Map&lt;String, Object&gt;</code> 对象，键值关系按顺序规划，其对应的键为：1, 2, 3 … 或是 param1, param2, param3 …</li><li>使用 <code>@Param</code> 注解：　类似与 [传递多个对象] 的规则，只是把数字的键值换成了注解的键值</li></ul></li><li><p><code>parameterMappings</code></p><p>是一个 <code>List</code>，每一个元素都是 <code>ParameterMapping</code> 对象，描述了参数的属性：属性名、表达式、javaType、jdbcType等重要信息。通过它就可以实现参数和 SQL 的结合，使得 <code>PreparedStatement</code> 可以通过它找到 <code>parameterObject</code> 对象的属性设置参数，使得程序正常运行。</p></li><li><p><code>sql</code></p><p>书写在映射器中被 <code>SqlSource</code> 解析后的 SQL，大部分情况下不需要修改它，在使用插件的时候可以根据情况来进行改写。</p></li></ul><h2 id="SqlSession-的执行过程"><a href="#SqlSession-的执行过程" class="headerlink" title="SqlSession 的执行过程"></a>SqlSession 的执行过程</h2><p><code>SqlSession</code> 是 MyBatis 底层运行的<strong>核心</strong>，是一个接口，给出了查询、插入、更新、删除的方法（MyBatis 目前建议使用 <code>Mapper</code>）。</p><h3 id="映射器的动态代理"><a href="#映射器的动态代理" class="headerlink" title="映射器的动态代理"></a>映射器的动态代理</h3><p><code>SqlSession</code> 默认的实现类 <code>DefaultSqlSession</code> 中的 <code>getMapper</code> 方法：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907181612.png" alt></p><p>可以看到，方法调用了 <code>configuration</code> 的 <code>getMapper</code> 方法。</p><p>我们可以继续追踪到对应的方法：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907181900.png" alt></p><p>这里使用了映射器的注册器 <code>mapperRegistry</code> 来获取对应的接口对象。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907182054.png" alt></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907183253.png" alt></p><p><code>knowMappers</code> 是一个 HashMap，存储了注册的 mapper 接口完全限定名和对应的代理工厂。如果没有注册就会抛出异常，如果有，就会启用 <code>MapperProxyFactory</code> 工厂来生成一个代理实例。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907183920.png" alt></p><p>我们深入 <code>MapperProxy</code> 源码中会发现：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907184120.png" alt></p><p>类中 <code>invoke</code> 方法的逻辑为：</p><p>如果 Mapper 是一个 JDK 动态代理对象，就会运行到 <code>invoke</code> 方法里面。否则，就会通过 <code>cachedMapperMethod</code> 方法生成 <code>MapperMethod</code> 对象，最后执行 <code>execute</code> 方法。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907185315.png" alt></p><p>深入 execute 方法中，会发现代码非常复杂，调用了很多其他的方法，从中我们可以看到一些细节，那就是最终都是通过 <code>SqlSession</code> 对象来运行 SQL的。MyBatis 根据 XML 中的全限定名和 SQL id 指向的方法，将其和代理对象绑定起来，通过动态代理，让接口运行起来，最后使用 SqlSession 接口的方法使得它可以执行对应的 SQL。</p><h3 id="SqlSession-下的四大对象"><a href="#SqlSession-下的四大对象" class="headerlink" title="SqlSession 下的四大对象"></a>SqlSession 下的四大对象</h3><p>映射器就是一个动态代理对进入到了 <code>MapperMethod</code> 的 <code>execute</code> 方法，经过简单的判断进入了 <code>SqlSession</code> 的 <code>delete</code>、<code>update</code>、<code>insert</code>、<code>select</code> 等方法，而这些方法的如何执行就是正确编写插件的根本。</p><p><code>SqlSession</code> 的执行过程是通过 <code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code> 和 <code>ResultSetHandler</code> 来完成数据库操作和结果返回的。</p><ul><li><p><code>Executor</code></p><p>执行器，它来调度 <code>StatementHandler</code>、<code>ParameterHandler</code> 和 <code>ResultSetHandler</code> 等来执行对应的 SQL，其中 <code>c</code> 是最重要的。</p></li><li><p><code>StatementHandler</code></p><p>使用数据库的 <code>Statement(PreparedStatement)</code> 执行操作，是这四个对象的<strong>核心</strong>，很多重要的插件都是通过拦截它来实现的。</p></li><li><p><code>ParameterHandler</code></p><p>处理 SQL 参数</p></li><li><p><code>ResultSetHandler</code></p><p>对数据集（ResultSet）进行封装返回处理的，比较复杂，我们也不太常用它。</p></li></ul><h4 id="Executor-——-执行器"><a href="#Executor-——-执行器" class="headerlink" title="Executor —— 执行器"></a>Executor —— 执行器</h4><p><code>SqlSession</code> 是一个门面，真正干活的是执行器，它是真正执行 Java 和数据库交互的对象，非常重要。</p><p>MyBatis 有三种执行器：</p><ul><li>SIMPLE —— 简易执行器（默认的执行器）</li><li>REUSE —— 执行<u>重用预处理语句</u>的执行器</li><li>BATCH —— 执行器<u>重用语句</u>、<u>批量更新，批量专用</u>的执行器</li></ul><p><code>Executor</code> 是在 <code>Configuration</code> 中创建的：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907202649.png" alt></p><p>会根据配置的类型来创建对应的 <code>Executor</code> ，在创建对象之后，会执行 <code>executor = (Executor) interceptorChain.pluginAll(executor);</code> 这样一句代码来配置插件，这也正是插件的原理。</p><p>在 <code>SqlSession</code> 中，执行数据库的操作为：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907203536.png" alt></p><p>我们会发现实际上执行的正是 <code>executor</code> 的 <code>query</code> 方法，以 <code>SimpleExecutor</code> 为例，它的 <code>query</code> 方法中调用了 <code>doQuery</code> 方法，在这个方法里，才轮到 <code>StatementHandler</code> 来执行。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907211044.png" alt></p><p>MyBatis 先根据 <code>Configuration</code> 来构建 <code>StatementHandler</code>，然后使用 <code>prepareStatement</code> 方法，对 SQL 编译和参数进行初始化。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907211355.png" alt></p><p>先调用 <code>prepare()</code> 进行预编译和基础的设置，之后使用 <code>StatemantHandler</code> 的 <code>parameterize()</code> 来设置参数，在最后执行 <code>StatemantHandler</code> 的 <code>query()</code> 方法。</p><p>我们将焦点移至 <code>StatementHandler</code> 对象上。</p><h4 id="SatementHandler-——-数据库会话"><a href="#SatementHandler-——-数据库会话" class="headerlink" title="SatementHandler —— 数据库会话"></a>SatementHandler —— 数据库会话</h4><p>在 <code>Configuration</code> 类中创建 <code>StatementHandler</code> 的方法为：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907211949.png" alt></p><p>创建的真实对象为 <code>RoutingStatementHandler</code>，它实现了接口 <code>StatementHandler</code>。</p><p>而 <code>RoutingStatementHandler</code> 也是通过适配模式来找到对应的 <code>StatementHandler</code> 来执行的：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907212246.png" alt></p><p>从代码中可以看到，它也分三种：<code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code>、<code>CallableStatementHandler</code>，分别对应 JDBC 的 <code>Statement</code>、<code>PreparedStatement</code>（预处理编译）、<code>CallableStatement</code>（存储过程处理）。</p><p>根据上述的代码追溯过程，我们可以看到一条查询 SQL 的执行过程： <code>Executor</code> 先调用 <code>StatementHandler</code> 的 <code>prepare()</code> 方法预编译 SQL，并设置一些基本运行的参数。之后调用 <code>parameterize()</code> 方法启用 <code>ParameterHandler</code> 设置参数，完成预编译，执行查询，<code>update()</code> 也是同样的流程，如果是查询，MyBatis 会使用 <code>ResultSetHandler</code> 封装结果返回给调用者。</p><h4 id="ParameterHandler-——-参数处理器"><a href="#ParameterHandler-——-参数处理器" class="headerlink" title="ParameterHandler —— 参数处理器"></a>ParameterHandler —— 参数处理器</h4><p>参数处理器的接口非常简单，接口定义为：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907213501.png" alt></p><ul><li><code>getParameterObject()</code> 返回参数的对象</li><li><code>setParameters()</code> 设置预编译 SQL 语句的参数</li></ul><h4 id="ResultSetHandler-——-结果处理器"><a href="#ResultSetHandler-——-结果处理器" class="headerlink" title="ResultSetHandler —— 结果处理器"></a>ResultSetHandler —— 结果处理器</h4><p>接口定义为：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190907213811.png" alt></p><p><code>handleOutputParameters()</code> 方法是处理存储过程输出参数的</p><p><code>handleResultSets()</code> 方法则用来包装结果集。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;构建-SqlSessionFactory-过程&quot;&gt;&lt;a href=&quot;#构建-SqlSessionFactory-过程&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="JavaEE 互联网轻量级框架整合开发" scheme="https://phoenixxc.github.io/categories/JavaEE-%E4%BA%92%E8%81%94%E7%BD%91%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="mybatis" scheme="https://phoenixxc.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之Web开发</title>
    <link href="https://phoenixxc.github.io/posts/d16715c9/"/>
    <id>https://phoenixxc.github.io/posts/d16715c9/</id>
    <published>2019-07-21T14:58:19.000Z</published>
    <updated>2019-08-18T08:59:36.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><p>使用 SpringBoot：</p><ol><li><p>创建 SpringBoot 应用，选中需要的模块</p></li><li><p>SpringBoot 默认将这些场景自动配置好，只需要在配置文件中指定少量配置</p></li><li><p>自己编写业务逻辑代码</p></li></ol><h2 id="SpringBoot-对静态资源的映射规则"><a href="#SpringBoot-对静态资源的映射规则" class="headerlink" title="SpringBoot 对静态资源的映射规则"></a>SpringBoot 对静态资源的映射规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/springframework/boot/autoconfigure/web/ResourceProperties.java</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以设置与静态资源有关的设置，例如缓冲时间等</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">    CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">                                             .addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">    String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">                                             .addResourceLocations(getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置首页</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(<span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext),</span><br><span class="line">                                         applicationContext, getWelcomePage(), <span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置喜欢的图标</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">        mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">// 在静态文件夹中寻找</span></span><br><span class="line">        mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>, faviconRequestHandler()));</span><br><span class="line">        <span class="keyword">return</span> mapping;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">        requestHandler.setLocations(resolveFaviconLocations());</span><br><span class="line">        <span class="keyword">return</span> requestHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Resource&gt; <span class="title">resolveFaviconLocations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] staticLocations = getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">        List&lt;Resource&gt; locations = <span class="keyword">new</span> ArrayList&lt;&gt;(staticLocations.length + <span class="number">1</span>);</span><br><span class="line">        Arrays.stream(staticLocations).map(<span class="keyword">this</span>.resourceLoader::getResource).forEach(locations::add);</span><br><span class="line">        locations.add(<span class="keyword">new</span> ClassPathResource(<span class="string">"/"</span>));</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(locations);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>所有 /webjars/**，都去 classpath:/META-INF/resources/webjars/ 找资源；</p><p><a href="https://www.webjars.org/" target="_blank" rel="noopener">webjars</a>：以 jar 包的方式引入静态资源；</p><p>在 <strong><em>webjars</em></strong> 这个网站上可以使用 maven 导入常用 js 库的 webjar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190721132241.png" alt></p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190721131900.png" alt></p></li><li><p>“/**” 访问当前项目的任何资源，对应</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public/</li><li>/：当前项目根路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">"classpath:/META-INF/resources/"</span>,</span><br><span class="line">                                                                  <span class="string">"classpath:/resources/"</span>, <span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Locations of static resources. Defaults to classpath:[/META-INF/resources/,</span></span><br><span class="line"><span class="comment"> * /resources/, /static/, /public/].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br></pre></td></tr></table></figure></li><li><p>欢迎页面的映射</p></li><li><p>页面图标映射（可能需要清除浏览器缓存 - <a href="https://chrome.google.com/webstore/detail/classic-cache-killer/kkmknnnjliniefekpicbaaobdnjjikfp" target="_blank" rel="noopener">Chrome 插件</a>或者 <kbd>Shift+F5</kbd>）</p><p>需要放在映射路径的根目录下才可以。</p></li></ol><blockquote><p>By default, resources are mapped on <code>/**</code>, but you can tune that with the <code>spring.mvc.static-path-pattern</code> property. For instance, relocating all resources to <code>/resources/**</code> can be achieved as follows:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.static-path-pattern=/resources/**</span><br></pre></td></tr></table></figure><blockquote><p>You can also customize the static resource locations by using the <code>spring.resources.static-locations</code> property (replacing the default values with a list of directory locations). The root Servlet context path, <code>&quot;/&quot;</code>, is automatically added as a location as well.</p><p>In addition to the “standard” static resource locations mentioned earlier, a special case is made for <a href="https://www.webjars.org/" target="_blank" rel="noopener">Webjars content</a>. Any resources with a path in<code>/webjars/**</code> are served from jar files if they are packaged in the Webjars format.</p><table><thead><tr><th><img src="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/images/tip.png" alt="[Tip]"></th></tr></thead><tbody><tr><td>Do not use the <code>src/main/webapp</code> directory if your application is packaged as a jar. Although this directory is a common standard, it works <strong>only</strong> with war packaging, and it is silently ignored by most build tools if you generate a jar.</td></tr></tbody></table></blockquote><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>Jsp、Thymeleaf、Velocity、Freemarker …</p><p>SpringBoot 如果以 jar 的形式打包，而且由于 SpringBoot 使用的是内嵌的 Tomcat ，所以 SpringBoot 推荐使用 <strong><em>Thymeleaf</em></strong>.</p><h3 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h3><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Thymeleaf-语法"><a href="#Thymeleaf-语法" class="headerlink" title="Thymeleaf 语法"></a>Thymeleaf 语法</h3><p>自动配置的默认规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br></pre></td></tr></table></figure><p>只要把 html 放在 classpath:/templates/ 后，Thymeleaf 就会自动渲染。</p><p>使用：</p><ol><li><p>导入 thymeleaf 名称空间：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>SUCCESS<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将 div 的内容设置为... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这是显示欢迎数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><ul><li><p><code>th:text</code> 改变当前元素里面的文本内容</p><p><code>th:</code> 任意 html 属性，来替换原生属性的值</p><p>对应的行内写法：</p><ul><li><code>th:text</code> =&gt; <code>[[]]</code></li><li><code>th:utext</code> =&gt; <code>[()]</code></li></ul><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190721160559.png" alt></p></li></ul><ul><li><p>表达式</p><p><strong>Simple expressions:</strong>（表达式语法）</p><ul><li><p>Variable Expressions: <code>${...}</code></p><ul><li><p>获取对象的属性，调用方法</p></li><li><p>使用内置的基本对象</p><ul><li>#ctx : the context object.</li><li>#vars: the context variables.</li><li>#locale : the context locale.</li><li>#request : (only in Web Contexts) the HttpServletRequest object.</li><li>#response : (only in Web Contexts) the HttpServletResponse object.</li><li>#session : (only in Web Contexts) the HttpSession object.</li><li>#servletContext : (only in Web Contexts) the ServletContext object.</li></ul></li><li><p>使用内置的工具对象</p><ul><li>#execInfo : information about the template being processed.</li><li>#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.</li><li>#uris : methods for escaping parts of URLs/URIs</li><li>#conversions : methods for executing the configured conversion service (if any).</li><li>#dates : methods for java.util.Date objects: formatting, component extraction, etc.</li><li>#calendars : analogous to #dates , but for java.util.Calendar objects.</li><li>#numbers : methods for formatting numeric objects.</li><li>#strings : methods for String objects: contains, startsWith, prepending/appending, etc.</li><li>#objects : methods for objects in general.</li><li>#bools : methods for boolean evaluation.</li><li>#arrays : methods for arrays.</li><li>#lists : methods for lists.</li><li>#sets : methods for sets.</li><li>#maps : methods for maps.</li><li>#aggregates : methods for creating aggregates on arrays or collections.</li><li>#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</li></ul></li></ul></li></ul></li></ul><ul><li><p>Selection Variable Expressions:</p><p><code>*{...}</code>（选择表达式）和<code>#{}</code> 功能相同，补充使用：配置 <code>th:object</code> 使用，可以直接引用 <code>th:object</code> 的属性</p></li><li><p>Message Expressions: <code>#{...}</code></p><p>获取国际化内容</p></li><li><p>Link URL Expressions: <code>@{...}</code></p><p>定义 url，里面可以使用变量等值</p></li><li><p>Fragment Expressions: <code>~{...}</code></p><p>片段引用表达式</p></li></ul><p><strong>Literals</strong>（字面量）</p><ul><li><p>Text literals: ‘one text’ , ‘Another one!’ ,…</p></li><li><p>Number literals: 0 , 34 , 3.0 , 12.3 ,…</p></li><li><p>Boolean literals: true , false</p></li><li><p>Null literal: null</p></li><li><p>Literal tokens: one , sometext , main ,…</p></li></ul><p><strong>Text operations:</strong>（文本操作）</p><ul><li><p>String concatenation: +</p></li><li><p>Literal substitutions: |The name is ${name}|</p></li></ul><p><strong>Arithmetic operations:</strong>（数学运算）</p><ul><li><p>Binary operators: + , - , * , / , %</p></li><li><p>Minus sign (unary operator): -</p></li></ul><p><strong>Boolean operations:</strong>（布尔运算）</p><ul><li><p>Binary operators: and , or</p></li><li><p>Boolean negation (unary operator): ! , not</p></li></ul><p><strong>Comparisons and equality:</strong>（比较运算）</p><ul><li><p>Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</p></li><li><p>Equality operators: == , != ( eq , ne )</p></li></ul><p><strong>Conditional operators:</strong>（条件运算）</p><ul><li><p>If-then: (if) ? (then)</p></li><li><p>If-then-else: (if) ? (then) : (else)</p></li><li><p>Default: (value) ?: (defaultvalue)</p></li></ul><p><strong>Special tokens:</strong></p><ul><li>Page 17 of 104</li><li>No-Operation: _</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;使用 SpringBoot：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;创建 SpringBoot 应用，选中需要的模块&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Spring
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/categories/SpringBoot/"/>
    
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之日志</title>
    <link href="https://phoenixxc.github.io/posts/18e9d6ab/"/>
    <id>https://phoenixxc.github.io/posts/18e9d6ab/</id>
    <published>2019-07-21T14:57:13.000Z</published>
    <updated>2019-08-18T08:59:39.611Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><p>日志门面：日志的一个抽象层</p><p>市面上的日志框架：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…<em>**</em></p><table><thead><tr><th>日志门面</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（久不更新）</del>、SLF4j、<del>jboss-logging（不适用于普通人群）</del></td><td>Log4j、JUL（Java 自带）、log4j2（框架好但是有些尚未适配）、Logback（与Log4j是同一个作者）</td></tr></tbody></table><p>左边选一个门面（抽象层），右边选一个实现；</p><p><strong>SpringBoot</strong> ：底层为 Spring框架默认选择 JCL、而 SpringBoot 选择 SLF4j、logback</p><h2 id="SLF4j-的使用"><a href="#SLF4j-的使用" class="headerlink" title="SLF4j 的使用"></a>SLF4j 的使用</h2><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在开发时，不应直接调用日志的实现类，而是应该调用日志的抽象层的方法。</p><p>导入 SLF4j 的 jar 和 logback 的 jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190720143617.png" alt></p><p>每一个日志的实现框架都有自己的配置文件，使用 SLF4j后，<strong>配置还是做成日志实现框架的自己的配置文件</strong>。</p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>A（SLF4j + logback）：Spring 、Hibernate、MyBatis、….. A 系统的依赖使用了其他的日志框架</p><p>统一日志记录，即使是别的框架也统一使用 SLF4j 输出</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190720144123.png" alt></p><p><strong>如何让系统中所有的日志都统一到slf4j：</strong></p><ol><li>将系统中其他日志框架先排除出去</li><li>用中间包来替换原有的日志框架</li><li>导入 slf4j 其他的实现</li></ol><h3 id="SpringBoot-与日志的关系"><a href="#SpringBoot-与日志的关系" class="headerlink" title="SpringBoot 与日志的关系"></a>SpringBoot 与日志的关系</h3><p>SpringBoot 使用日志功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>底层依赖关系：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190720145802.png" alt></p><p>总结：</p><ol><li>SpringBoot 底层也是使用 slf4j + logback 的方式进行日志记录的</li><li>SpringBoot 把其他的日志都替换为了 slf4j</li></ol><p>Maven 排除 jar 包的方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectB<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  <span class="comment">&lt;!-- declare the exclusion here --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sample.ProjectC<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Project-C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以在 idea 的 maven 依赖树里面选中不需要的依赖，右键选择 删除</p><h2 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h2><p><a href="https://segmentfault.com/a/1190000004693427" target="_blank" rel="noopener">LogBack入门实践</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录器</span></span><br><span class="line">   <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 日志的级别，由低到高 -------------------</span></span><br><span class="line">       <span class="comment">// 可以调整输出的日志的级别；日志就只会在这个级别的以后的高级别生效</span></span><br><span class="line">       <span class="comment">// 跟踪轨迹</span></span><br><span class="line">       logger.trace(<span class="string">"这是 trace 日志..."</span>);</span><br><span class="line">       <span class="comment">// 调试信息</span></span><br><span class="line">       logger.debug(<span class="string">"这是 debug 日志..."</span>);</span><br><span class="line">       <span class="comment">// SpringBoot 默认只会输出 info 级别：root 级别</span></span><br><span class="line">       <span class="comment">// info</span></span><br><span class="line">       logger.info(<span class="string">"这是 info 日志..."</span>);</span><br><span class="line">       <span class="comment">// warning</span></span><br><span class="line">       logger.warn(<span class="string">"这是 warning 日志..."</span>);</span><br><span class="line">       <span class="comment">// error</span></span><br><span class="line">       logger.error(<span class="string">"这是 error 日志..."</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logging.level.com.xuanc=trace</span><br><span class="line"># =========== logging.path 与 logging.file 冲突 ===========</span><br><span class="line"># 指定目录，创建路径的文件夹，日志输出文件名默认使用 spring.log</span><br><span class="line">logging.path=/tmp/spring/log</span><br><span class="line"># 如果不指定路径则在当前项目下生成日志，也可以指定路径</span><br><span class="line">#logging.file=springboot.log</span><br><span class="line"></span><br><span class="line"># 在控制台输出的日志的格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line"># 指定文件中输出的日志的格式</span><br><span class="line">#logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br></pre></td></tr></table></figure><p>日志输出格式：</p><ul><li><code>%d</code> 表示时间日期</li><li><code>%thread</code> 表示线程名</li><li><code>%-5level</code>级别从左显示5个字符宽度</li><li><code>%logger{50}</code> 表示 logger 名字最长为50个字符，否则按照据点分隔</li><li><code>%msg</code> 日志消息</li><li><code>%n</code> 换行符</li></ul><p>具体的可以在 SpringBoot 的 logging 下面的文件中查看：</p><p><img src="../../../IdeaProjects/SpringBoot-ShangGuiG/images/1563610047818.png" alt="1563610047818"></p><p>也可以<a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/content/IV.%20Spring%20Boot%20features/26.5.%20Custom%20log%20configuration.html" target="_blank" rel="noopener">自定义日志配置</a>，在类路径下放上每个日志框架自己的配置文件后，SpringBoot 就不使用默认的配置了。</p><p>以下文件会根据你选择的日志系统进行加载：</p><table><thead><tr><th>日志系统</th><th style="text-align:center">定制配置</th></tr></thead><tbody><tr><td>Logback</td><td style="text-align:center"><code>logback-spring.xml</code>,<code>logback-spring.groovy</code>,<code>logback.xml</code>或<code>logback.groovy</code></td></tr><tr><td>Log4j</td><td style="text-align:center"><code>log4j.properties</code>或<code>log4j.xml</code></td></tr><tr><td>Log4j2</td><td style="text-align:center"><code>log4j2-spring.xml</code>或<code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td style="text-align:center"><code>logging.properties</code></td></tr></tbody></table><p><strong>注</strong> 如果可能的话，建议你使用<code>-spring</code>变种形式定义日志配置（例如，使用<code>logback-spring.xml</code>（由 SpringBoot 完全控制）而不是<code>logback.xml</code>（日志框架会读取，跳过 SpringBoot））。如果你使用标准的配置路径，Spring可能不能够完全控制日志初始化。</p><p>使用 <code>-spring</code> 还有一个优点：由 SpringBoot 来解析日志配置，可以使用 SpringBoot 的高级 <strong><em>Profile</em></strong> 功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;springProfile&gt;</code>标签可用于根据激活的Spring profiles，选择性的包含或排除配置片段。Profile片段可以放在<code>&lt;configuration&gt;</code>元素内的任何地方，使用<code>name</code>属性定义哪些profile接受该配置，多个profiles以逗号分隔。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">&gt;  <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev, staging"</span>&gt;</span></span><br><span class="line">&gt;  <span class="comment">&lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!production"</span>&gt;</span></span><br><span class="line">&gt;  <span class="comment">&lt;!-- configuration to be enabled when the "production" profile is not active --&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h2><p>按照 SLF4j 的日志适配图，进行响应的转换。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;日志框架&quot;&gt;&lt;a href=&quot;#日志框架&quot; class=&quot;headerlink&quot; title=&quot;日志框架&quot;&gt;&lt;/a&gt;日志框架&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/categories/SpringBoot/"/>
    
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之属性配置</title>
    <link href="https://phoenixxc.github.io/posts/a29f8391/"/>
    <id>https://phoenixxc.github.io/posts/a29f8391/</id>
    <published>2019-07-21T14:55:00.000Z</published>
    <updated>2019-08-18T08:59:36.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SpringBoot 使用一个全局的配置文件：</p><ul><li>application.properties</li><li>application.yml</li></ul><p>配置文件的作用：修改 SpringBoot 自动配置的默认值。</p><p>以前的配置文件：使用的大多是 xml 文件。</p><p>yml 是YAML（YAML Ain’t Markup Language）语言的文件，<u>以数据为中心</u>，更适合做配置文件</p><h2 id="YAML-语法"><a href="#YAML-语法" class="headerlink" title="YAML 语法"></a>YAML 语法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>key: value ==&gt; 表示一对键值对（空格不能省略），且对大小写敏感。</p><p>以空格的缩进来控制层级关系；只要是左对齐的一列数据都是同一层级的数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/hello</span></span><br><span class="line"><span class="comment"># 这是注释..</span></span><br></pre></td></tr></table></figure><h3 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h3><ul><li><p><strong>字面量：普通的值（数字、字符串、布尔）</strong></p><p>字面量直接写，字符串默认不用加上单引号或者双引号；</p><p>“”: 不会转义字符串的特殊字符，特殊字符作为本身要表示的意思</p><p>‘’：会转义特殊字符，特殊字符只是一个普通的字符串数据</p></li><li><p><strong>对象、Map（属性和值）</strong></p><p>Key: Value 对象还是键值对的形式，在下一行写对象的KV，但需要注意缩进</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangshan,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>数组（List、Set）</strong></p><p>用 <code>- 值</code> 表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,</span> <span class="string">dog,</span> <span class="string">pig]</span></span><br></pre></td></tr></table></figure></li></ul><p>上面三种格式可以互相嵌套。</p><h2 id="获取配置文件值"><a href="#获取配置文件值" class="headerlink" title="获取配置文件值"></a>获取配置文件值</h2><h3 id="一、使用-ConfigurationProperties"><a href="#一、使用-ConfigurationProperties" class="headerlink" title="一、使用 @ConfigurationProperties"></a>一、使用 @ConfigurationProperties</h3><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="comment"># 驼峰命名可以转化为横杠：last-name</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">  maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,</span> <span class="attr">k2:</span> <span class="string">v2&#125;</span></span><br><span class="line"><span class="attr">  lists:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">zhaoliu</span></span><br><span class="line"><span class="attr">  dog:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">小狗</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>Java Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>还需要导入配置文件处理器，在 pom.xml 中加入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样，在 properties文件中也可以配置，但是在里面输入<strong>中文会出现乱码</strong>（Spring Boot 是以 iso-8859 的编码方式读取 application.properties 配置文件）。</p><p>解决方法：</p><blockquote><ol><li>在 .properties 中加入:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; spring.http.encoding.force=true</span><br><span class="line">&gt; spring.http.encoding.charset=UTF-8</span><br><span class="line">&gt; spring.http.encoding.enabled=true</span><br><span class="line">&gt; server.tomcat.uri-encoding=UTF-8</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><ol start="2"><li>将 IDEA 设置中的 File Encodings 的 Transparent native-to-ascii conversion 打钩。</li></ol></blockquote><p><strong>属性名匹配规则</strong>：</p><ul><li>person.firstName：使用标准方式</li><li>person.first-name：大写用 -</li><li>person.first_name：大写用_</li><li>PERSON_FIRST_NAME：<ul><li>推荐系统属性使用这种写法</li></ul></li></ul><h3 id="二、使用-Value"><a href="#二、使用-Value" class="headerlink" title="二、使用 @Value"></a>二、使用 @Value</h3><p>使用 Spring 底层注解 <code>@Value</code> 来实现，获取配置文件或环境变量的值，或使用 SpEL</p><h3 id="ConfigurationProperties-和-Value-区别"><a href="#ConfigurationProperties-和-Value-区别" class="headerlink" title="@ConfigurationProperties 和 @Value 区别"></a><code>@ConfigurationProperties</code> 和 <code>@Value</code> 区别</h3><table><thead><tr><th>Feature</th><th><code>@ConfigurationProperties</code></th><th><code>@Value</code></th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（属性名匹配规则）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持（注入时校验数据）</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持（只支持基本类型）</td></tr></tbody></table><p>数据校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br></pre></td></tr></table></figure><p>这样，如果 lastName 不是一个有效的 email 的话会抛出异常。</p><h3 id="加载指定的配置文件"><a href="#加载指定的配置文件" class="headerlink" title="加载指定的配置文件"></a>加载指定的配置文件</h3><p>使用 <code>@PropertySource</code> 和 <code>@ImportResource</code> 可以记载指定的配置文件。</p><p>使用 <code>@ConfigurationProperties</code> 默认是从全局配置文件中获取值。</p><p><strong><code>@PropertySource</code></strong>： 加载指定的配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">// @Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><strong><code>@ImportResource</code></strong>：导入 Spring 的配置文件，让配置文件里面的内容生效</p><p>SpringBoot 里面没有 Spring 的配置文件，自己编写的配置文件也不能自动识别，想让 Spring 的配置文件生效，加载进来，需要把 <code>@ImportResource</code> 标注在配置类上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBoot02ConfigApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>SpringBoot 推荐的给容器添加组件的方式：</p><ol><li><p>编写配置类</p></li><li><p>使用 <code>@Bean</code> 给容器中添加组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bean 的 id 与方法名相同</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><ul><li><p>RandomValuePropertySource：配置文件中可以使用随机数</p><p><code>${random.value}、${random.int}、${random.long}、${random.int(10)、${random.int[1024,65536]}</code></p></li><li><p>属性配置占位符</p><p>可以在配置文件中引用前面配置过的属性（优先级前面配置过得这里都能用）</p><p><code>${app.name: 默认值}</code>来指定找不到属性的默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#person.last-name=张三$&#123;random.uuid&#125;</span><br><span class="line">person.age=$&#123;random.int&#125;</span><br><span class="line">person.birth=2017/12/12</span><br><span class="line">person.boss=false</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=14</span><br><span class="line">person.lists=a,b,c,d</span><br><span class="line">person.dog.name=$&#123;person.last-name&#125;_dog</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure><p>如果属性不存在，则会将占位符当做字符串处理</p></li></ul><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>Profile 是 Spring 对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境</p><h3 id="多-profile-文件形式"><a href="#多-profile-文件形式" class="headerlink" title="多 profile 文件形式"></a>多 profile 文件形式</h3><p>格式：<code>application-{profile}.properties</code></p><p>默认使用 application.properties 配置文件。</p><h3 id="YAML-文档块模式"><a href="#YAML-文档块模式" class="headerlink" title="YAML 文档块模式"></a>YAML 文档块模式</h3><p>YAML 中如果使用 <code>---</code> 可以将文件划分为不同的文档块，多个 profile 可以写在同一个文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Document1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">  maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,</span> <span class="attr">k2:</span> <span class="string">v2&#125;</span></span><br><span class="line"><span class="attr">  lists:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">zhaoliu</span></span><br><span class="line"><span class="attr">  dog:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">小狗</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev</span> <span class="comment"># 指定激活哪一个 profile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Document2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span> <span class="comment"># 指定文档块属于哪个 profile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># Document3</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8022</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure><h3 id="使用其他环境的配置文件的方式："><a href="#使用其他环境的配置文件的方式：" class="headerlink" title="使用其他环境的配置文件的方式："></a>使用其他环境的配置文件的方式：</h3><ul><li><p>application.properties 或 application.yml 指定</p><blockquote><p>YAML 的优先级比 .properties 要低</p></blockquote><p><code>spring.profiles.active={profile}</code></p><p>`spring:<br>profiles:</p><pre><code>active: {profile}`</code></pre></li><li><p>命令行方式（优先级较高）：</p><p>idea 的 <em>program arguments</em> 设置 <code>-- spring.profiles.active={profile}</code></p><p>maven 打包后，在命令行执行并加上参数</p></li><li><p>虚拟机参数</p><p>idea 的 <em>VM options</em>: <code>-Dspring.profiles.active={profile}</code></p></li></ul><h2 id="配置文件的加载位置"><a href="#配置文件的加载位置" class="headerlink" title="配置文件的加载位置"></a>配置文件的加载位置</h2><p>SpringBoot 启动会扫描以下位置的 application.properties或者 application.yml 文件作为 SpringBoot 的默认配置文件：（Idea 中类路径即 <em>classpath:</em>对应 <strong>resources</strong> 目录）</p><ul><li>file:/config/</li><li>file:/</li><li>classpath:/config</li><li>classpath:/</li></ul><p>以上按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置的内容会覆盖低优先级配置的内容，也可以通过配置 <code>spring.config.location</code> 来改变默认内容。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190720084452.png" alt></p><p>SpringBoot 会加载上述的所有文件，只是如果配置冲突，高优先级的配置文件中的设置会覆盖低优先级配置文件的设置，低优先级的其他配置依然会生效。</p><p>例如在上述四个配置文件中分别定义不同的端口号，在 /resource/application.properties 文件中定义项目的访问路径，那么运行后低优先级配置的项目访问路径仍然有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br><span class="line"></span><br><span class="line"># 配置项目的访问路径</span><br><span class="line">server.servlet.context-path=/springboot-demo</span><br><span class="line"># 新版本的配置改为：server.servlet.context-path，而不是　server.context-path</span><br></pre></td></tr></table></figure><p><img src="../../../IdeaProjects/SpringBoot-ShangGuiG/images/1563584399179.png" alt="1563584399179"></p><h3 id="指定配置文件路径"><a href="#指定配置文件路径" class="headerlink" title="指定配置文件路径"></a>指定配置文件路径</h3><p>项目打包好后，可以使用<strong>命令行参数</strong>的形式，在启动项目时指定配置文件的新位置，指定的配置文件和默认加载的配置文件会共同启动作用，形成互补配置。</p><p>直接在上述的四个配置文件中指定 <code>spring.config.location</code> 并不会生效。</p><h2 id="外部配置的加载顺序"><a href="#外部配置的加载顺序" class="headerlink" title="外部配置的加载顺序"></a>外部配置的加载顺序</h2><p><a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/content/IV.%20Spring%20Boot%20features/24.%20Externalized%20Configuration.html" target="_blank" rel="noopener">官网文档中文手册</a>上提到的外部配置的加载顺序：</p><blockquote><p>Spring Boot允许将配置外部化（externalize），这样你就能够在不同的环境下使用相同的代码。你可以使用properties文件，YAML文件，环境变量和命令行参数来外部化配置。使用@Value注解，可以直接将属性值注入到beans中，然后通过Spring的<code>Environment</code>抽象或通过<code>@ConfigurationProperties</code><a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/reference/htmlsingle/#boot-features-external-config-typesafe-configuration-properties" target="_blank" rel="noopener">绑定到结构化对象</a>来访问。</p><p>Spring Boot设计了一个非常特别的<code>PropertySource</code>顺序，以允许对属性值进行合理的覆盖，属性会以如下的顺序进行设值：（优先级从高到低，高优先级覆盖低优先级，形成互补）</p><ol><li>home目录下的<a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/reference/htmlsingle/#using-boot-devtools-globalsettings" target="_blank" rel="noopener">devtools全局设置属性</a>（<code>~/.spring-boot-devtools.properties</code>，如果devtools激活）。</li><li>测试用例上的<a href="http://docs.spring.io/spring/docs/4.3.3.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html" target="_blank" rel="noopener">@TestPropertySource</a>注解。</li><li>测试用例上的<a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/api/spring-boot-test/src/main/java/org/springframework/boot/test/context/SpringBootTest.html" target="_blank" rel="noopener">@SpringBootTest#properties</a>注解。</li><li><strong>命令行参数</strong>（多个参数可以用空格分隔开）</li><li>来自<code>SPRING_APPLICATION_JSON</code>的属性（环境变量或系统属性中内嵌的内联JSON）。</li><li><code>ServletConfig</code>初始化参数。</li><li><code>ServletContext</code>初始化参数。</li><li><strong>来自于<code>java:comp/env</code>的JNDI属性。</strong></li><li><strong>Java系统属性（System.getProperties()）。</strong></li><li><strong>操作系统环境变量。</strong></li><li><strong>RandomValuePropertySource，只包含<code>random.</code>中的属性。</strong></li><li><strong>没有打进jar包的<a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/reference/htmlsingle/#boot-features-external-config-profile-specific-properties" target="_blank" rel="noopener">Profile-specific应用属性</a>（<code>application-{profile}.properties</code>和YAML变量）。</strong></li><li><strong>打进jar包中的<a href="http://docs.spring.io/spring-boot/docs/1.4.1.RELEASE/reference/htmlsingle/#boot-features-external-config-profile-specific-properties" target="_blank" rel="noopener">Profile-specific应用属性</a>（<code>application-{profile}.properties</code>和YAML变量）。</strong></li><li><strong>没有打进jar包的应用配置（<code>application.properties</code>和YAML变量）。</strong></li><li><strong>打进jar包中的应用配置（<code>application.properties</code>和YAML变量）。</strong></li><li><strong><code>@Configuration</code>类上的<a href="http://docs.spring.io/spring/docs/4.3.3.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html" target="_blank" rel="noopener"><code>@PropertySource</code>注解</a>。</strong></li><li><strong>默认属性（使用<code>SpringApplication.setDefaultProperties</code>指定）。</strong></li></ol></blockquote><h2 id="自动配置的原理"><a href="#自动配置的原理" class="headerlink" title="自动配置的原理"></a>自动配置的原理</h2><p>配置文件可配置属性的范围：</p><ul><li><a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/content/X.%20Appendices/A.%20Common%20application%20properties.html" target="_blank" rel="noopener">官方文档</a></li></ul><p>自动配置原理：</p><ol><li><p>SpringBoot 启动时，加载主配置类，开启了自动配置功能 <code>@EnableAutoConfiguration</code></p></li><li><p><code>@EnableAutoConfiguration</code> 作用</p><p>利用 <code>AutoConfigurationImportSelector.class</code> 给容器中导入组件，里面的 <code>public String[] selectImports(AnnotationMetadata annotationMetadata) { ... }</code> 方法中，</p><p>调用了 <code>protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {...}</code> 方法，这里面有一句代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br></pre></td></tr></table></figure><p>通过这行代码来获取候选的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">        <span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">        <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的 <code>loadFactoryNames</code> 方法的源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描所有jar包类路径下的 META-INF/spring.factories 文件</span></span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">                                 classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :                        ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取 url 后对每个 url 进行遍历</span></span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            <span class="comment">// 把扫描到的文件内容包装为 properties 对象</span></span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = </span><br><span class="line">                PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 从 properties 对象中获取全类名</span></span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                <span class="keyword">for</span> (String factoryName : </span><br><span class="line">                     StringUtils.</span><br><span class="line">                     commaDelimitedListToStringArray((String) </span><br><span class="line">                                                     entry.getValue())) &#123;</span><br><span class="line">                    <span class="comment">// 添加</span></span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> </span><br><span class="line">            IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +　FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 EnableAutoConfiguration.class 类</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>所以总的来说，是将 META-INF/spring.factories 里面的所有 EnableAutoConfiguration 的值加入到容器中。使用这些类来做自动配置：</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190720100554.png" alt></p><ol start="3"><li><p>每一个自动配置类进行自动配置功能</p></li><li><p>以 <code>HttpEncodingAutoConfiguration</code> 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 表示这是一个配置类</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpProperties.class)</span><br><span class="line"><span class="comment">// 启用指定类的 ConfigurationProperties 功能，将配置文件中对应的值与这个properties类绑定在一起，并把 HttpProperties 加入到 Ioc 容器中</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="comment">// Spring 底层注解，根据不同的条件决定配置是否生效；</span></span><br><span class="line"><span class="comment">// 判断当前应用是否为 web 应用，如果是则生效</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter.class)</span><br><span class="line"><span class="comment">// 判断当前项目有没有这个类(Spring MVC 解决乱码中的过滤器)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="comment">// 判断在配置文件中是否启用，如果配置这个属性，也生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已近与 SpringBoot 的配置文件映射了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpProperties.Encoding properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个有参构造器的情况下，参数的值会从容器中获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties.getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给容器中添加组件，有些值需要从 properties 中获取</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 容器中没有这个组件时候才会执行</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> </span><br><span class="line">            OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(</span><br><span class="line">            <span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(</span><br><span class="line">            <span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断。决定配置类是否生效，一旦配置类生效，这个配置类就会在容器中添加各种组件，这些组件的属性是从对应的 propertie 类中获取的，而这些类的每一个属性又是和配置文件绑定的。</p></li><li><p>所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装着；<strong>配置文件能配置什么就可以参照某个功能对应的这个属性类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http"</span>)</span><br><span class="line"><span class="comment">// 从配置文件中获取指定的值和 bean 的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure></li></ol><p>SpingBoot 的精髓：</p><ol><li>SpringBoot 启动会加载大量的自动配置类</li><li>我们需要的功能有没有 SpringBoot 默认写好的自动配置类</li><li>在看这个自动配置类到底配置了哪些组件，如果有，就不需要自动配置了</li><li>给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性，可以在配置文件中指定属性的值</li></ol><h3 id="Conditional-扩展注解"><a href="#Conditional-扩展注解" class="headerlink" title="@Conditional 扩展注解"></a><code>@Conditional</code> 扩展注解</h3><table><thead><tr><th style="text-align:left">@Conditional扩展注解</th><th style="text-align:left">作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td style="text-align:left">@ConditionalOnJava</td><td style="text-align:left">系统的java版本是否符合要求</td></tr><tr><td style="text-align:left">@ConditionalOnBean</td><td style="text-align:left">容器中存在指定Bean；</td></tr><tr><td style="text-align:left">@ConditionalOnMissingBean</td><td style="text-align:left">容器中不存在指定Bean；</td></tr><tr><td style="text-align:left">@ConditionalOnExpression</td><td style="text-align:left">满足SpEL表达式指定</td></tr><tr><td style="text-align:left">@ConditionalOnClass</td><td style="text-align:left">系统中有指定的类</td></tr><tr><td style="text-align:left">@ConditionalOnMissingClass</td><td style="text-align:left">系统中没有指定的类</td></tr><tr><td style="text-align:left">@ConditionalOnSingleCandidate</td><td style="text-align:left">容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td style="text-align:left">@ConditionalOnProperty</td><td style="text-align:left">系统中指定的属性是否有指定的值</td></tr><tr><td style="text-align:left">@ConditionalOnResource</td><td style="text-align:left">类路径下是否存在指定资源文件</td></tr><tr><td style="text-align:left">@ConditionalOnWebApplication</td><td style="text-align:left">当前是web环境</td></tr><tr><td style="text-align:left">@ConditionalOnNotWebApplication</td><td style="text-align:left">当前不是web环境</td></tr><tr><td style="text-align:left">@ConditionalOnJndi</td><td style="text-align:left">JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>查看哪些配置类自动生效：</p><p>通过启用 debug 属性来打印自动配置报告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开启 SpringBoot 的 debug 模式</span><br><span class="line">debug=true</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190720112722.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;配置文件&quot;&gt;&lt;a href=&quot;#配置文件&quot; class=&quot;headerlink&quot; title=&quot;配置文件&quot;&gt;&lt;/a&gt;配置文件&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/categories/SpringBoot/"/>
    
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot之环境配置</title>
    <link href="https://phoenixxc.github.io/posts/cb2b0fb3/"/>
    <id>https://phoenixxc.github.io/posts/cb2b0fb3/</id>
    <published>2019-07-21T14:51:45.000Z</published>
    <updated>2019-08-18T08:59:36.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="将-SpringBoot-项目打包为-Jar-包"><a href="#将-SpringBoot-项目打包为-Jar-包" class="headerlink" title="将 SpringBoot 项目打包为 Jar 包"></a>将 SpringBoot 项目打包为 Jar 包</h2><p>maven <code>pom.xml</code> 中加入如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插件作用：将应用打包为可执行的 jar 包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 mvn package 就可以将应用打包。</p><p>在终端里 cd 到 jar 的位置后，<code>java -jar (jar包名称或路径）</code> 就可以运行项目，而且不需要配置 tomcat 环境，因为 SpringBoot 集成了 tomcat。</p><h2 id="POM-文件解析"><a href="#POM-文件解析" class="headerlink" title="POM 文件解析"></a>POM 文件解析</h2><h4 id="父项目"><a href="#父项目" class="headerlink" title="父项目"></a>父项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父项目作用：依赖管理</p><p>这个父项目还有一个父项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个父项目才是真正管理 Spring Boot 应用里面的所有的依赖管理的，其 <code>&lt;properties&gt;</code> 属性规定了常用包的版本号。所以导入以及规定版本的包是不需要写版本号的。</p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-starter-web</code>: spring-boot 场景启动器，导入了 web 模块正常运行需要的依赖</p><p>Sping Boot 将所有的功能场景都抽取出来，做成一个 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">starters</a>，只需要在项目里面引入这些 starter 相关的场景依赖都会自动导入进来。</p><h2 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring 应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@SpringBootApplication</code> 说明被注解标注的类是 SpringBoot 的主配置类，SpringBoot 应该运行这个类的 main 方法来启动 SpringBoot 应用。</p><p>注解部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), <span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p><code>@SpringBootConfiguration</code> : 表示被标注的类是 SpringBoot 的配置类，配置类也是容器中的一个组件</p><p><code>@EnableAutoConfiguration</code>：开启自动配置的功能</p><blockquote><p>自动配置的原理：</p><p>注解部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@AutoConfigurationPackage</span></span><br><span class="line">&gt; <span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>@AutoConfigurationPackage</code> : 自动配置包，使用 <code>@Import({Registrar.class})</code> 这个 Spring 底层注解来实现，给容器中导入一个组件。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><p><strong>将主配置类 （<code>@SpringBootApplication</code> 标注的类）的<u>所在包下面的所有子包</u>里面的所有组件扫描到 Spring 容器</strong></p><hr><p><code>@Import({AutoConfigurationImportSelector.class})</code>: 给容器中导入组件</p><p>将所有需要导入的组件以全类名的方式返回，添加到容器中。会给容器中导入非常多的<strong>自动配置类</strong>（xxxAutoConfiguration），就是给容器中导入这个场景所需要的所有组件，并配置好这些组件。</p><blockquote><p><code>AutoConfigurationImportSelector</code> 类部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">&gt; &gt;  <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">&gt; &gt;      <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">&gt; &gt;  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt; &gt;      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&gt; &gt;      AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">&gt; &gt;      <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&gt; &gt;  &#125;</span><br><span class="line">&gt; &gt; &#125;</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote><blockquote><p>方法 <code>getAutoConfigurationEntry</code> 中的 <code>List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</code> <code>configurations</code> 数组就是容器中需要导入的组件。</p><blockquote><p><code>SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</code></p><p>从类加载器中获取资源，将资源作为 <code>properties</code> 配置文件，从中拿出工程的名字：<code>factoryClass.getName()</code>。</p><p>从类路径下的 <strong><em>META-INF/spring.factories</em></strong> 中获取 <code>EnableAutoConfiguration</code> 指定的值，将这些值作为自动配置类导入到容器中。</p><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190719105837.png" alt></p></blockquote><p><img src="https://gitee.com/PhoenixXc/FigureBed/raw/picgo/img/20190719104706.png" alt></p></blockquote></blockquote><p>有了自动配置类，就免去了手动编写而配置注入功能组件等的工作。</p><p>J2EE 的整体解决方案和自动配置都在 <strong>spring-boot-autoconfigure-xxx.RELEASE.jar</strong>;</p><h2 id="使用-Spring-Initializr-快速创建项目"><a href="#使用-Spring-Initializr-快速创建项目" class="headerlink" title="使用 Spring Initializr 快速创建项目"></a>使用 Spring Initializr 快速创建项目</h2><p>Idea 或者<a href="https://start.spring.io/" target="_blank" rel="noopener">官网</a>的 Spring Initialzr 可以快速创建项目。</p><p>默认生成的 Spring Boot 项目：</p><ul><li>主程序、测试文件生成好了</li><li>resource 文件夹的目录结构<ul><li>static: 保存所有的静态资源：js、css、images；</li><li>templates: 保存所有的模板页面；（由于使用嵌入式的 Tomcat，默认不支持 JSP）</li><li>application.properties: Spring Boot 应用的配置文件，可以修改默认设置；</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;将-SpringBoot-项目打包为-Jar-包&quot;&gt;&lt;a href=&quot;#将-SpringBoot-项目打包为-Jar-包&quot; class=&quot;h
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://phoenixxc.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Servlet请求转发</title>
    <link href="https://phoenixxc.github.io/posts/e0aa16fa/"/>
    <id>https://phoenixxc.github.io/posts/e0aa16fa/</id>
    <published>2019-03-05T10:44:23.000Z</published>
    <updated>2019-07-22T12:18:05.429Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><p>在 Servlet 中请求转发的方法无非两种：</p><ul><li><p>使用 <code>RequestDispatcher</code> 来调派请求</p><ul><li><p>使用 <code>include()</code> 来将另一个 Servlet 的操作流程包括至目前的操作流程中</p></li><li><p>使用 <code>forward()</code> 方法将请求处理转发给其他的 Servlet</p></li></ul></li></ul><ul><li>使用 <code>HttpServletResponse</code> 的 <code>sendRedirect()</code> 方法要求浏览器重新请求另一个 URL</li></ul><p>如果要调用 <code>forward()</code> 和 <code>sendRedirect()</code> 方法，那么目前的 Servlet 不能有任何响应确认，否则会抛出异常。</p><p>调用 <code>forward()</code> 方法时需要传入请求与响应对象，由于传递的是同一个 request，所以在转发过程中可以使用请求范围属性来传递一些属性。但 <code>forward()</code> 转发的这个动作是在 Web 容器中进行的，浏览器不知道请求被转发，地址栏也不会发生变化，转发也限制只能转发到服务器的另一个资源。而在整个转发过程中，都还是在<strong>同一个请求周期</strong>中。</p><p>当浏览器请求 Servlet1 后，Servlet1 将请求转发给了 Servlet2，之后 Servlet2 对浏览器进行响应，全程浏览器都不知道发送的请求已被转发。这样会存在的一个问题：当我刷新页面后，不过不加以处理会导致数据被重复提交。</p><p>比如现在有如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">"UTF-8"</span> contentType=<span class="string">"text/html; UTF-8"</span> %&gt;</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"zh"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">          content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;test&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">"testServlet"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br/&gt;</span><br><span class="line">        消息&amp;emsp;&lt;input type=<span class="string">"text"</span> name=<span class="string">"message"</span>&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"上传"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xuac;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName    ServletTest-ServletOne</span></span><br><span class="line"><span class="comment"> * Description  forward()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xuanc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 19-3-17 下午2:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/testServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletOne</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"forward() 测试 ----------------------"</span>);</span><br><span class="line">        String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String message = request.getParameter(<span class="string">"message"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Username: "</span> + username + <span class="string">"\n"</span> + <span class="string">"Message: "</span> + message);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"index.jsp"</span>).forward(request, response);</span><br><span class="line">        System.out.println(<span class="string">"after forward()......................"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交表单后在输出了表单内容。</p><p><img src="/images/1552806823414.png" alt="1552806823414"></p><p>而当刷新一次后：</p><p>浏览器会提醒重复提交表单</p><p><img src="/images/1552806904960.png" alt="1552806904960"></p><p>当确认后发现内容被重复提交：</p><p><img src="/images/1552806949391.png" alt="1552806949391"></p><p><code>sendRedirect()</code> 方法顾名思义，是重定向而非转发。可以让浏览器重新请求另一个 URL，请求的资源也可以是其他服务端的资源。与 <code>forward()</code> 不同，重定向实际上是<strong>两次请求</strong>，浏览器请求 Servlet1 时，Servlet1 将浏览器重定向到 Servlet2，然后浏览器向 Servlet2 发出请求，之后则由 Servlet2 做出响应或者其他的操作。这样的重定向浏览器是可以知道的，地址栏也会发生变化。</p><p>上面的例子中，解决刷新重复提交表单的方法之一就是使用重定向而不是转发（<code>forward()</code>）。另一种方法是使用 token，通过它来判断是否是重复提交，进而进行处理。</p><p>由于在重定向的过程中，并没有使用同一个 <code>HttpRequest</code> 对象，所以想要传递属性只能通过 Session 来处理。而且因为是两次请求，需要额外的往返行为，所以相比 <code>forward()</code> 来说重定向会慢一些。</p><p>在上面的例子中我们也可以看到，调用 <code>forward</code> 或 <code>sendRedirect</code> 不会停止执行方法中的其余代码。所以如果转发和重定向之后还有可能会执行其他语句的话应该加上 <code>return</code>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在 Servlet 中请求转发的方法无非两种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;RequestDispatcher&lt;/code&gt; 来调派
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记－疯狂Java讲义[4]</title>
    <link href="https://phoenixxc.github.io/posts/603dd0d7/"/>
    <id>https://phoenixxc.github.io/posts/603dd0d7/</id>
    <published>2019-02-27T05:23:18.000Z</published>
    <updated>2019-07-22T12:11:17.277Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="第四章-流程控制与数组"><a href="#第四章-流程控制与数组" class="headerlink" title="第四章　流程控制与数组"></a>第四章　流程控制与数组</h2><h3 id="1-流程控制"><a href="#1-流程控制" class="headerlink" title="1.流程控制"></a>1.流程控制</h3><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>&emsp;&emsp;switch 语句后面控制表达式的数据类型<u>只能是</u><code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>、枚举类型和<code>java.lang.String</code>类型。<code>switch</code>中其他类型会隐式向上转换为<code>int</code>，<code>long</code>比<code>int</code>范围大，转换可能会损失精度，Java通过<code>string</code>的<code>hash()</code>值把<code>string</code>也转换为<code>int</code>。</p><h4 id="控制循环结构"><a href="#控制循环结构" class="headerlink" title="控制循环结构"></a>控制循环结构</h4><p>&emsp;&emsp;Java没有提供<code>goto</code>语句，与C类似，也有<code>continue</code>、<code>break</code>语句。不同的是，<code>break</code>和<code>continue</code>后可以紧跟标签来使得可以结束或直接跳到外层循环。</p><p>&emsp;&emsp;标签是一个紧跟英文冒号的标识符，Java中的标签<u>只有放在循环语句前才有用</u>。</p><p><center><u>代码清单</u></center><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">              System.out.println(<span class="string">"Hello ~"</span>);</span><br><span class="line">              <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="keyword">break</span> outer;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h3><p>&emsp;&emsp;数组也是一种数据类型，属于引用类型。数组用来存储一组具有相同数据类型的元素。Java中类与类可以继承，会造成一个数组中有多个类型的假象，但归根到底元素都属于同一种类型。<u>数组一旦初始化完成后，其长度将固定不变。</u></p><p>&emsp;&emsp;数组是一种引用类型，定义一个数组后相当于只定义了一个指针，这个指针还没指向任何有效内存。所以<u>定义数组的时候不能指定数组的长度。</u></p><hr><ol><li><p>数组的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName; </span><br><span class="line">type arrayName[];</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了更好的可读性，推荐使用第一种定义方式。</p></li><li><p>数组的初始化</p><p>&emsp;&emsp;初始化，即为数组的数组元素分配内存空间，并给每个数组元素赋值，数组的<u>定义和初始化可以同时</u>完成。</p><p>初始化的两种方式：</p><ul><li><p>静态初始化</p><p>初始化时显式指定数组元素的初值，长度由系统决定（指定长度会报错）。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> type[] &#123;element1, element2, ..., elementn&#125;;</span><br><span class="line"><span class="comment">// 数组的定义和静态初始化同时完成可以省略 new type[]</span></span><br><span class="line"><span class="comment">// type[] arrayName = &#123;element1, element2, ...&#125;;</span></span><br></pre></td></tr></table></figure><p>初始化时type类型以及元素的类型要与定义数组时指定的类型一致（相同或为定义时指定类型的子类），元素以逗号分隔开。</p></li><li><p>动态初始化</p><p>初始化时只指定数组的长度，系统为数组元素分配初值。</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> type[length];</span><br></pre></td></tr></table></figure><p>type类型要求同上。length可以是已初始化的变量。</p><p>系统默认分配的初值为：</p><ul><li><p>整数类型：0</p></li><li><p>浮点类型：0.0</p></li><li><p>字符类型：’\u0000’</p></li><li><p>布尔类型：false</p></li><li><p>引用类型：null</p></li></ul></li></ul></li></ol><ol start="3"><li><p>数组的使用</p><ul><li><p>数组可以通过索引的方式去除数组元素或对其进行赋值</p><p>如果索引超出数组大小范围在运行时会抛出异常：<code>java.lang.ArrayIndexOutOfBoundsException: N</code>，N的值即为非法的数组索引。</p></li><li><p>数组的长度可以通过其<code>length</code>属性获得</p></li><li><p>Java5之后，Java提供了更简单的循环：<code>foreach</code>循环，可以自动遍历数组和集合的每个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type variableName : array | collection) &#123;</span><br><span class="line">    <span class="comment">// variableName 自动访问每个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>foreach</code>循环中的循环变量variableName是一个临时变量，改变他并不能改变数或集合中元素的值</p></li></ul></li><li><p>数组的实质</p><p>&emsp;&emsp;数组引用变量只是一个引用，数组元素和数组变量在内存里分开存储。而引用变量是访问真实对象的根本方式，只能通过数组的引用变量才能访问数组对象本身。</p><p>&emsp;&emsp;实际的数组对象存储在堆中，如果引用数组对象的数组引用变量是局部变量，它被存储在栈中，如果堆中的对象不在有任何变量指向它，会被JVM的垃圾回收机制回收。</p><p>&emsp;&emsp;通过对数组的重新赋值，产生数组长度可变的错觉，但实际堆中实际的数组对象并不可变。</p><p><center><u>程序清单</u></center></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayInRam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        System.out.println(<span class="string">"b 数组的长度"</span> + b.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> temp : a) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> temp : b) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        b = a;</span><br><span class="line">        System.out.println(<span class="string">"b 数组的长度"</span> + b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多维数组</p><p>&emsp;&emsp;Java支持多维数组，但从本质上来说并没有多维数组。<u>多维数组实质上其元素也是引用变量</u>。</p><p><center><u>代码清单</u></center></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimensionTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 定义一个二维数组</span></span><br><span class="line">      <span class="keyword">int</span>[][] a;</span><br><span class="line">      <span class="comment">// 初始化数组，数组a有四个元素，每一个元素都是int[]类型</span></span><br><span class="line">      a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">      <span class="comment">// Error!</span></span><br><span class="line">      <span class="comment">// a = new int[][4];</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">         System.out.println(a[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">      </span><br><span class="line">      a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">         System.out.println(a[<span class="number">0</span>][i]);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"==========="</span>);</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 初始化的多种方式</span></span><br><span class="line">      <span class="comment">// One</span></span><br><span class="line">      <span class="comment">// int[][] b = new int[][] &#123;</span></span><br><span class="line">      <span class="comment">//    new int[]&#123;1&#125;,</span></span><br><span class="line">      <span class="comment">//    new int[]&#123;1, 2&#125;, </span></span><br><span class="line">      <span class="comment">//    new int[]&#123;1, 2, 3&#125;</span></span><br><span class="line">      <span class="comment">// &#125;;</span></span><br><span class="line">      <span class="comment">// Two</span></span><br><span class="line">      <span class="keyword">int</span>[][] b = &#123;</span><br><span class="line">         &#123;<span class="number">1</span>&#125;,</span><br><span class="line">         <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>],</span><br><span class="line">         <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// foreach()</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] tempArray : b) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> tempValue : tempArray) &#123;</span><br><span class="line">            System.out.println(tempValue);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"==========="</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Error!      </span></span><br><span class="line">      <span class="comment">// int[][] c = new int[2][] &#123;</span></span><br><span class="line">      <span class="comment">//    1, 2, 3, 4, 5, 6</span></span><br><span class="line">      <span class="comment">// &#125;;</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Arrays类</p><p>&emsp;&emsp;Java中Arrays类中的一些static方法可以直接操作数组，使用这些方法需要导入java.util.Arrays类(<code>import java.util.Arrays</code>)，static方法可以直接通过类名调用。</p><ul><li><p>int binarySearch(type[] a, type key)</p><p>使用二分法在数组a中查询值为key的元素，返回其索引，查找失败返回负数。要求数组为升序排列。</p></li><li><p>int binarySearch(type[] a, int fromIndex, int toIndex, type key)</p><p>与上一个类似，只是限定查找索引范围为fromIndex到toIndex。</p></li><li><p>type[] copyOf(type[] original, int length)</p><p>将original复制为一个新的数组，新数组长为length，如果length大于原数组的长度，后面元素补充为0、false或null。</p></li><li><p>type[] copyOfRange(type[] original, int from, int to)</p><p>只复制数组的from索引到to索引的元素</p></li><li><p>boolean equals(type[] a, type[] a2)</p><p>判断两个数组是否相等（长度+数组对应元素）</p></li><li><p>void fill(type[] a, type val)</p><p>将数组的所有元素设为val</p></li><li><p>void fill(type[] a, int fromIndex, int toIndex, type val)</p><p>与上一个相同，只是限制了赋值的索引范围</p></li><li><p>void sort(type[] a)</p><p>对数组元素排序（自定义排序方法涉及到重载）</p></li><li><p>void sort(type[] a, int fromIndex, int toIndex)</p><p>作用同上，只限制了排序的范围</p></li><li><p>String toString(type[] a)</p><p>将一个数组转换为字符串</p><p><center><u>代码清单</u></center></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimensionTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String names[] = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">         <span class="string">"人生苦短"</span>, </span><br><span class="line">         <span class="string">"来杯Java"</span></span><br><span class="line">      &#125;;</span><br><span class="line">      String namesCopy[] = Arrays.copyOf(names, names.length);</span><br><span class="line">      System.out.println(Arrays.toString(namesCopy));</span><br><span class="line">      names[<span class="number">0</span>] = <span class="string">"HelloWorld"</span>;</span><br><span class="line">      System.out.println(Arrays.toString(names));</span><br><span class="line">      System.out.println(Arrays.toString(namesCopy));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output------------------------------------------------------</span></span><br><span class="line"><span class="comment">// [人生苦短, 来杯Java]</span></span><br><span class="line"><span class="comment">// [HelloWorld, 来杯Java]</span></span><br><span class="line"><span class="comment">// [人生苦短, 来杯Java]</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;第四章-流程控制与数组&quot;&gt;&lt;a href=&quot;#第四章-流程控制与数组&quot; class=&quot;headerlink&quot; title=&quot;第四章　流程控制
      
    
    </summary>
    
      <category term="Java" scheme="https://phoenixxc.github.io/categories/Java/"/>
    
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
      <category term="Java" scheme="https://phoenixxc.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Chapter7-使用JSTL</title>
    <link href="https://phoenixxc.github.io/posts/2f1b8bf3/"/>
    <id>https://phoenixxc.github.io/posts/2f1b8bf3/</id>
    <published>2019-02-25T11:10:34.000Z</published>
    <updated>2019-07-22T12:16:20.733Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="JSTL-简介"><a href="#JSTL-简介" class="headerlink" title="JSTL 简介"></a>JSTL 简介</h2><p>JSTL 提供了与页面呈现相关的逻辑判断标签，也提供了对应 JSP 标注标签的扩展标签和更多的功能标签，可以分为五类：</p><ul><li>核心标签库：提供条件判断、属性访问、URL 处理及错误处理等</li><li>I18N 兼容格式标签库：提供数字、日期等的格式化和区域、编码处理等功能</li><li>SQL 标签库</li><li>XML 标签库：提供 XML 解析、流程控制、转换等功能</li><li>函数标签库：提供常用字串处理的已定义 EL 标签库</li></ul><p>idea 使用 JSTL 标签库：</p><ol><li>在 <a href="http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/" target="_blank" rel="noopener">JSTL</a> 中下载最新的 zip 文件，解压。</li><li>idea 中打开设置，搜索 Schemas and DTDs，点右边的 +，URL中输入 <a href="http://java.sun.com/jsp/jstl/core，浏览文件选择刚才解压后文件夹中的" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core，浏览文件选择刚才解压后文件夹中的</a> tld 目录下的 c.tld 文件。</li><li>将 zip 文件夹中的 lib 里的文件复制到项目中的 WEB-INF 的 lib 目录下，或者在 Project Setting -&gt; Libraries 中点＋，选择 lib 文件夹里面的文件。</li></ol><h2 id="核心标签库"><a href="#核心标签库" class="headerlink" title="核心标签库"></a>核心标签库</h2><h3 id="流程处理标签"><a href="#流程处理标签" class="headerlink" title="流程处理标签"></a>流程处理标签</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;param.name == 'momor'&amp;&amp; param.password == '1234'&#125;"</span>&gt;</span><br><span class="line">    &lt;h1&gt;$&#123;param.name&#125; 登录成功 &lt;/h1&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;%-- JSTL中可以使用EL表达式--%&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>test</code> 属性为 true，才会输出 <code>&lt;c:if&gt;</code> 标签中的语句。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;user.valid&#125;"</span>&gt;</span><br><span class="line">        &lt;jsp:getProperty name=<span class="string">"user"</span> property=<span class="string">"name"</span>/&gt; 登录成功</span><br><span class="line">        &lt;%--</span><br><span class="line">    * 属性的名称就是get/set方法去除get/set后 ,再把首字母小写</span><br><span class="line">* <span class="keyword">boolean</span>的方法可以是is开头</span><br><span class="line">--%&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        &lt;h1&gt; 登录失败 &lt;/h1&gt;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><p>当 <code>&lt;c:when&gt;</code> test 为 true 时，只会输出这个标签中的 Body 内容。否则继续判断下一个 <code>&lt;c:when&gt;</code> 标签中的 test，如果所有的 <code>&lt;c:when&gt;</code> 都不满足，就输出 <code>&lt;c:otherwise&gt;</code> 的内容（如果有这个标签）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"message"</span> items=<span class="string">"$&#123;messageService.messages&#125;"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;message.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;message.text&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>类似 Java 中的 forEach 循环，<code>items</code> 属性可以是数组、<code>Collection</code>、<code>Iterator</code>、<code>Enumeration</code>、<code>Map</code> 与字符串。每次会从 <code>items</code> 中取出元素，指定给 <code>var</code> 属性设置的变量。</p><p><code>items</code> 属性是 <code>Map</code> :</p><p>&emsp;&emsp;设置给 <code>var</code> 的对象是 <code>Map.Entry</code> ，有 <code>getKey()</code> <code>getValue()</code> 方法取得键与值。</p><p><code>items</code> 属性是字符串：</p><p>&emsp;&emsp;以逗号来切割字符串，如果要自定义切割依据可以使用<code>&lt;c:forTokens&gt;</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forTokens <span class="keyword">var</span>=<span class="string">"token"</span> delims=<span class="string">";"</span> items=<span class="string">"a;b;c;d;e"</span>&gt;</span><br><span class="line">&lt;%-- ... --%&gt;</span><br><span class="line">&lt;/c:forTokens&gt;</span><br></pre></td></tr></table></figure><h3 id="错误处理标签"><a href="#错误处理标签" class="headerlink" title="错误处理标签"></a>错误处理标签</h3><p>错误发生时，在当前网页捕捉异常并显示相关信息。使用 <code>&lt;c:catch&gt;</code> 标签。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">catch</span> <span class="keyword">var</span>=<span class="string">"error"</span>&gt;</span><br><span class="line">    $&#123;param.a&#125; + $&#123;param.b&#125; = $&#123;param.a + param.b&#125;</span><br><span class="line">&lt;/c:catch&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;error != null&#125;"</span>&gt;</span><br><span class="line">    &lt;br&gt;&lt;span style="color: red;"&gt;$&#123;error.message&#125;&lt;/span&gt;</span><br><span class="line">    &lt;br&gt;$&#123;error&#125;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><p>用 <code>&lt;c:catch&gt;</code> 标签将可能产生异常的部分包起来，如果有异常会给 <code>var</code> 设值。所有的异常都是 <code>Throwable</code> 的子类，都有 <code>getMessage()</code> 方法。</p><h3 id="网页导入、重定向、URL处理标签"><a href="#网页导入、重定向、URL处理标签" class="headerlink" title="网页导入、重定向、URL处理标签"></a>网页导入、重定向、URL处理标签</h3><p>包含其他 JSP 网页到当前网页的几种方式：</p><ul><li><code>&lt;%@include file=&quot;/....&quot; %&gt;</code></li><li>使用 <code>&lt;jsp:include&gt;</code> 标签，动态包含，还可传递参数</li></ul><p>JSTL 中有一个 <code>&lt;c:import&gt;</code> 标签，也可以在运行时动态导入到另一个网页。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">import</span> url=<span class="string">"add.jsp"</span>&gt;</span><br><span class="line">&lt;c:param name=<span class="string">"a"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">    &lt;%-- 用 &lt;c:param&gt; 标签传递参数--%&gt;</span><br><span class="line">&lt;/c:import&gt;</span><br><span class="line">&lt;c:<span class="keyword">import</span> url=<span class="string">"https://...."</span> charEncoding=<span class="string">"BIG5"</span> /&gt;</span><br><span class="line">&lt;%--导入外部网页，如果编码不同需指定具体编码--%&gt;</span><br><span class="line">&lt;%--没有使用参数--%&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;c:redirect&gt;</code> 标签，可以重定向网页，类似 Servlet 中的 <code>HttpServletResponse.sendRedirect()</code> 方法，可以使用 <code>&lt;c:param&gt;</code> 标签在重定向时指定参数。</p><p>之前利用 <code>response.encodeURL()</code> 方法来作 URL 重写，以在关闭 Cookie 后正常维持 Session 进行会话管理，现在可以用 <code>&lt;c:url&gt;</code> 标签达到同样的目的。</p><h3 id="属性处理与输出标签"><a href="#属性处理与输出标签" class="headerlink" title="属性处理与输出标签"></a>属性处理与输出标签</h3><p>可以用 JSTL 设置属性：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"p1q1"</span> value=<span class="string">"$&#123;param.p1q1&#125;"</span> scope=<span class="string">"session"</span> /&gt;</span><br><span class="line">&lt;%--属性值太长可以用 Body 形式--%&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"p1q2"</span> scope=<span class="string">"session"</span>&gt;</span><br><span class="line">    some....</span><br><span class="line">&lt;/c:set&gt;</span><br></pre></td></tr></table></figure><p><code>var</code> 用来设置属性名，<code>value</code> 设置属性值（可以用 EL 表达式），如果不设置 <code>scope</code> ，会从 <code>page</code> 、<code>request</code> 、<code>session</code>、<code>application</code> 的范围中查找属性名称，如果找到就在该范围设置，找不到就在<code>page</code> 范围新建。</p><p>移除属性：<code>&lt;c:remove var=&quot;login&quot; scope=&quot;session&quot;/&gt;</code></p><p><code>&lt;c:set&gt;</code> 可以设置 JavaBean 的属性或 <code>Map</code> 对象的键/值，需要使用 <code>target</code> 属性进行设置。</p><p><code>&lt;c:set target=&quot;${pageContext.request}&quot; property=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;</code></p><p>如果 <code>target</code> 属性是 JavaBean，就用 JavaBean 的 <code>setXXX</code> 方法为 <code>property</code> 设值。</p><p>如果是 <code>Map</code> 对象，则会以 <code>property</code> 为键，以 <code>value</code> 为值。</p><hr><p><code>&lt;c：out&gt;</code> 标签可以输出内容，并用合适的字符替换 &lt;、&gt;、”等字符。eg.<code>&lt;c:out value=&quot;some&quot;&gt;</code></p><p>如果不想取代字符，可以设置属性 <code>escapeXml</code> 为 <code>false</code> （默认为 true），如果输出内容的 EL 表达式结果为 null 时，不会显示任何内容，也可以加上 <code>default</code> 属性设置为null时的默认值。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;JSTL-简介&quot;&gt;&lt;a href=&quot;#JSTL-简介&quot; class=&quot;headerlink&quot; title=&quot;JSTL 简介&quot;&gt;&lt;/a&gt;JST
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter6-使用jsp</title>
    <link href="https://phoenixxc.github.io/posts/2bd95d05/"/>
    <id>https://phoenixxc.github.io/posts/2bd95d05/</id>
    <published>2019-02-22T06:22:34.000Z</published>
    <updated>2019-08-18T08:46:37.130Z</updated>
    
    <content type="html"><![CDATA[<h3 id="指示元素"><a href="#指示元素" class="headerlink" title="指示元素"></a>指示元素</h3><p>JSP指示元素主要是为了表示容器将 JSP 转译为 Servlet 源代码时所必须遵守的信息。</p><p>语法为：<code>&lt;%@ 指示类型 [属性=&quot;值&quot;]* %&gt;</code>，指示元素可以有多对的属性/值</p><p>JSP 常用的三种指示类型为：<code>page</code> 、<code>include</code>、<code>taglib</code></p><ul><li><code>page</code>： 告知容器如何转译当前的JSP网页</li><li><code>include</code>： 告知容器将别的JSP页面包括进来进行转译</li><li><code>taglib</code>： 告知容器如何转译这个页面的标签库</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.util.Date"</span> %&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br></pre></td></tr></table></figure><p><code>1</code>：告知容器转译时要包括<code>import</code>属性中的值的包，即 Servlet 要有<code>import java.uutil.Date;</code>，如果有多个包要包含，可以用逗号分割开：<code>... import=&quot;java.util.Date, java.util.io*, ...&quot;</code></p><p><code>2</code>：<code>contenType</code>属性对应转译后的<code>response.setContentType(&quot;...&quot;)</code>，<code>pageEncoding</code>告诉容器这个网页的编码</p><p><code>include</code>类型的范例：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- includeDemo.jsp --&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">"/WEB-INF/jspf/header.jspf"</span>%&gt;</span><br><span class="line">&lt;h1&gt;这是本尊&lt;/h1&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">"/WEB-INF/jspf/foot.jspf"</span>%&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--header.jspf--&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"zh"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;示范开头&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;这是开头&lt;/h1&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--foot,jspf--&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;h1&gt;这是结尾&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>includeDemo.jsp 第一次执行时会将上面两个文件的内容包括起来，然后进行转译，所以最终会生成一个Servlet，这是一种静态的包括方式。<code>&lt;jsp:include&gt;</code>标签是运行时动态包括别的网页执行流程进行响应的方式，会各自生成独立的 Servlet。</p><p>同时也可以看到，包含的两个文件的后缀名是 .jspf，.jspf 文件通常是通过include伪指令包含在.jsp文件中的文件。’f’代表’fragment’，因为这些文件本身可能并不是完整的JSP，而是JSP的片段。类似这样的后缀名还有一个 .jspx。</p><p>同样，关于一些JSP的设置也可以在 web.xml 中更改，例如网页编码、内容类型等等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">page-encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">page-encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">default-content-type</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">default-content-type</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以声明指定的JSP文件的开头和结尾所要包括的网页</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include-perlude</span>&gt;</span>some...<span class="tag">&lt;/<span class="name">include-perlude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include-coda</span>&gt;</span>some...<span class="tag">&lt;/<span class="name">include-coda</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在编写JSP网页时，换行字符不会忽略，所以最后产生的换行字符也会输出，如果要忽略，可以在 web.xml 中的<code>&lt;jsp-property-group&gt;标签中加上</code> <code>&lt;trim-directive-whitespaces&gt;true&lt;/...&gt;</code></p><h3 id="声明、Scriptlet-与表达式元素"><a href="#声明、Scriptlet-与表达式元素" class="headerlink" title="声明、Scriptlet 与表达式元素"></a>声明、Scriptlet 与表达式元素</h3><p>JSP 中可以使用 声明、Scriptlet 元素和表达式来指定转译后 Servlet 类中包括的类成员、方法声明和语句。</p><p>声明元素的语法：<code>&lt;@! 类成员声明或方法声明 %&gt;</code></p><p>Scriptlet 的语法：<code>&lt;% Java 语句 %&gt;</code></p><p>在 JSP 中的编写的 HTML，都会变成 out 语句所输出的内容，而 Scriptlet 出现的顺序在转译为 Servlet 后，会按顺序出现在 <code>_jsoService()</code> 中。</p><p>表达式元素的语法：<code>&lt;%= Java表达式 %&gt;</code></p><p>表达式的运算结果将直接输出为网页的一部分，但表达式语句不能加上分号，因为在转译后，表达式语句的表达式会转译为 out 对象输出时的指定内容。</p><p>由于<code>&lt;%</code>和<code>%&gt;</code>在 JSP 中用来作为一些元素的开头和结尾，所以如果要在 JSP 网页中输出这两个符号要换成其他字符：<code>&lt;%</code> –&gt; <code>&amp;lt;%</code>，<code>%&gt;</code> –&gt; <code>%&amp;gt;</code>或<code>%\&gt;</code> （HTML输出<code>&amp;</code>用<code>&amp;amp</code>）。</p><p>一个网页通过适当的规划、切割业务逻辑与呈现逻辑，JSP 网页可以通过标准标签、EL 或  JSTL 自定义标签等消除网页上的 Scriptlet。</p><h3 id="注释元素"><a href="#注释元素" class="headerlink" title="注释元素"></a>注释元素</h3><p>使用 <code>&lt;%-- JSP注释 --%&gt;</code>，写出网页注释会输出到网页上。</p><h3 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h3><p><center>JSP 隐式对象</center><br>| 隐式对象    | 说明                                                         |<br>| :———- | ———————————————————— |<br>| out         | 转译后对应 <code>JspWriter</code> 对象，其内部关联一个 <code>PrintWriter</code> 对象 |<br>| request     | 转译后对应 <code>HttpServletRequest</code> 对象                         |<br>| response    | 转译后对应 <code>HttpServletResponse</code> 对象                        |<br>| config      | 转译后对应 <code>ServletConfig</code> 对象                              |<br>| applicaton  | 转译后对应 <code>ServletContext</code> 对象                             |<br>| session     | 转译后对应 <code>HttpSession</code> 对象                                |<br>| pageContext | 转译后对应 <code>pageContext</code> 对象，提供了 JSP 页面资源的封装，可设置页面范围属性 |<br>| exception   | 转译后对应 <code>Throwable</code> 对象 ，代表其他 JSP 页面抛出的异常对象，只会出现于 JSP 错误页面 |<br>| page        | 转译后对应 <code>this</code>                                            |</p><p>隐式对象只能在<code>&lt;%</code>和<code>%&gt;</code>或<code>&lt;%=</code>和<code>%&gt;</code>之间使用。隐式对象转译后是<code>_jspService()</code>中的局部变量。</p><p><code>JspWriter</code> 主要模拟了 <code>BufferedWriter</code> 与 <code>PrintWriter</code> 的功能，内部也是用 <code>PrntWriter</code> 来输出，但 <code>JspWriter</code> 具有缓冲区功能，使用 <code>print()</code> 和 <code>println()</code> 响应输出时，如果 JSP 页面没有缓冲或清楚缓冲时，才会直接创建 <code>printWriter()</code> 对象进行输出。</p><hr><p><code>page</code> 指示元素的 <code>buffer</code> 属性来设置缓冲区的大小，默认是8kb，<code>autoFlush</code> 属性决定缓冲区已满后的行为，默认值是 <code>true</code> ，表示慢了就清除，如果设置为 <code>false</code>，要自行调用 <code>JspWriter</code> 的 <code>flush()</code> 方法来清除，否则调用 <code>println()</code> 会抛出 <code>IOException</code> 异常。</p><hr><p>所有的隐式对象都可以通过 <code>pageContext</code> 的 <code>getXXX()</code> 方法来取得，<code>pageContext</code> 也可以设置页面范围属性，类似 Servlet 中的几个对象，可以使用 <code>setAttribute()</code>、<code>getAttribute()</code>、<code>removeAttribute()</code> 来设置。页面范围属性的作用范围仅仅局限于同一页面中。</p><p><code>pageContext</code> 提供了单一的 API  来设置四种范围属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getAttribute(String name, <span class="keyword">int</span> scope);</span><br><span class="line">setAttribute(String name, Object value, <span class="keyword">int</span> scope);</span><br><span class="line">removeAttribute(String name, <span class="keyword">int</span> scope);</span><br></pre></td></tr></table></figure><p>scope 的取值所代表的范围：</p><ul><li><code>pageContext.PAGE_SCOPE</code>: 页面</li><li><code>pageContext.REQUEST_SCOPE</code> : 请求</li><li><code>pageContext.SESSION_SCOPE</code>: 会话</li><li><code>pageContext.APPLICATION_SCOPE</code> :  应用程序范围</li></ul><p>如果不知道属性范围的名称，可以用 <code>pageContext</code> 的 <code>findAttribute()</code> 方法依序从页面、请求、会话、应用程序范围中寻找，先找到就返回。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>JSP 发生错误按时段分为三种：</p><ul><li>JSP 转换为 Servlet 源代码</li><li>Servlet 源代码编译时</li><li>Servlet 载入容器进行服务但发生运行时错误时</li></ul><p>可以自定义运行时异常发生时的处理页面，需要用 <code>page</code> 指示元素，设置 <code>errorPage</code> 属性来指定错误处理的页面。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--add.jsp--%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> errorPage=<span class="string">"error.jsp"</span> %&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--error.jsp--%&gt;</span><br><span class="line">&lt;%<span class="meta">@page</span> contentType=<span class="string">"text/html; UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> isErrorPage=<span class="string">"true"</span> %&gt;</span><br></pre></td></tr></table></figure><p><code>exception</code> 对象是 JSP 的隐式对象，只有 <code>isErrorPage</code> 设置为 <code>true</code> 的页面才可以使用这个对象。如果没有处理，会由容器默认处理，直接显示异常信息和堆栈跟踪信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--容器收到某个类型的异常对象时进行转发--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.NullPointerException<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/report.view<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--基于HTTP错误状态码转发至处理页面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标准标签"><a href="#标准标签" class="headerlink" title="标准标签"></a>标准标签</h2><p>JSP 规范中提供了一些标准标签，所有容器都支持，可协助编写 JSP 是减少 Scriptlet 的使用，所有的标签都以 <strong>jsp:</strong> 为前缀。</p><h3 id="lt-jsp-include-、-lt-jsp-forward-标签"><a href="#lt-jsp-include-、-lt-jsp-forward-标签" class="headerlink" title="&lt;jsp:include>、&lt;jsp:forward>标签"></a>&lt;jsp:include>、&lt;jsp:forward>标签</h3><p><code>&lt;jsp:include&gt;</code> 和 <code>&lt;jsp:forward&gt;</code>标签在转译后，底层是取得 <code>RequestDispatcher</code> 对象，并执行对应的 <code>forward()</code> 方法和 <code>include()</code> 方法。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">"add.jsp"</span>&gt;</span><br><span class="line">&lt;jsp:param name=<span class="string">"a"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;jsp:param&gt;</code> 指定了动态包括 add.jsp 时需要给页面的请求参数。</p><h3 id="lt-jsp-userBean-、-lt-jsp-setProperty-与-lt-jsp-getProperty-gt"><a href="#lt-jsp-userBean-、-lt-jsp-setProperty-与-lt-jsp-getProperty-gt" class="headerlink" title="&lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt;"></a>&lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt;</h3><p>JavaBean 元件具有的条件：</p><ul><li><p>必须实现 <code>java.io.Serializable</code> 接口</p></li><li><p>没有公开的类变量</p></li><li><p>具有无参数的构造器</p></li><li><p>具有公开的设值(setXXX)和取值(getXXX)方法</p><p>&lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt; 这三个标准标签就是搭配 JavaBean 元件的。</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"User"</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">"user"</span> property=<span class="string">"*"</span>/&gt;</span><br></pre></td></tr></table></figure><p>1.用来取得或创建 JavaBean</p><p><code>id</code> 指定 JavaBean 的实例名，之后可使用这个指定的名称设值和取值。</p><p><code>class</code> 属性指定要实例化哪个类。</p><p>还有一个属性 <code>scope</code> （默认为 <code>page</code> 范围）指定先查找设定的属性范围是否有名为<code>id</code> 指定值的 JavaBean 的属性存在，如果找到就直接使用，没有找到就会新建新的对象。</p><p> <code>type</code> 属性，指定声明 JavaBean 的类型，可以是一个抽象类、也可以是一个接口。但如果只设置了 type 而没有 class , 如果指定范围内找不到对象会抛出异常。</p><p>2.设置 JavaBean 的属性值</p><p><code>name</code> 指定要使用哪个名称来使用 JavaBean 实例，<code>property</code> 表示要设置的 JavaBean 属性，这两个属性在这个标签中必需的。</p><p><code>value</code> 和 <code>param</code> 两个属性可选，找到 JavaBean 后，如果指定了 <code>value</code> 元素，会将value的值转换为合适的基本类型赋值给指定的 JavaBean 属性。有 <code>param</code> 属性的话会将指定的参数的值转化会合适的基本类型赋给 JavaBean 属性。</p><p>如果<code>value</code> 和 <code>param</code> 都省略，可以用 JSP 的自省机制判断是否有 <code>property</code> 值相同的请求参数，有的话就赋给 JavaBean。</p><p>最有弹性的写法是示例代码第二行所示，标签中只有必要元素，<code>property</code> 值设为 <code>*</code>，代表将请求参数名称和 JavaBean 属性名交给自省机制自动匹配。自省机制可以自动转换基本类型。</p><p>有两种很容易混淆的写法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"User"</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">"user"</span> property=<span class="string">"*"</span>/&gt;</span><br></pre></td></tr></table></figure><p>这种写法无论如何都会使用设值。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"User"</span>&gt;</span><br><span class="line">&lt;jsp:setProperty name=<span class="string">"user"</span> property=<span class="string">"*"</span>/&gt;</span><br><span class="line">&lt;/jsp:useBean&gt;</span><br></pre></td></tr></table></figure><p>这种只有找不到 JavaBean 对象的时候，才会新建对象并设置值。</p><hr><p><code>&lt;jsp:getProperty&gt;</code> 只有一种使用方法：<code>&lt;jsp:getProperty name=&quot;JavaBean 对象实例名&quot;, property=&quot;JavaBean 对象属性名&quot;&gt;</code> ，然后用 <code>pageContext</code> 的 <code>findAttribute()</code>依次查找。</p><h3 id="表达式语言（EL）"><a href="#表达式语言（EL）" class="headerlink" title="表达式语言（EL）"></a>表达式语言（EL）</h3><p>JSP 中一些简单的属性、请求参数、标头和 Cookie 等信息可以用 EL 来处理，更加简便。</p><p>EL 是使用 <code>${</code> 与 <code>}</code> 来包括要处理的表达式。EL 处理了<code>null</code>值的情况，对 <code>null</code> 值直接以空字符串显示，运算时不会因此发生错误而抛出异常。</p><p>由于某些时候网页使用了模板等有类似EL表达式的语法存在，可以设置 JSP 网页是否使用 EL.</p><ul><li><p>web.xml 中修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-ignored</span>&gt;</span>true<span class="tag">&lt;/<span class="name">el-ignored</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>page</code> 指示元素的属性 <code>isELIgnored</code> (<em>default:</em>  <code>false</code>)</p></li></ul><p>如果在 <code>page</code> 中设置了属性，以 <code>page</code> 中的设置为主。</p><hr><h3 id="隐式对象-1"><a href="#隐式对象-1" class="headerlink" title="隐式对象"></a>隐式对象</h3><p>EL 中，可以用 EL 隐式对象指定范围来存取属性。如果不指定属性的范围，以 page、request、session、application 的顺序依次查找。</p><p>EL 中有11个隐式对象，只有 <code>pageContext</code> 隐式对象对应 <code>PageContext</code> ，其他都对应 <code>Map</code> 类型</p><ul><li><p><code>pageContext</code></p><p>PageContext 本身是 JavaBean 对象，所以只要是 getXXX() 方法，就可以使用 <code>${pageContext.xxx}</code> 来取得。也可以使用点运算符连续存取对象。</p></li><li><p>属性范围相关隐式对象</p><p>表示作用范围，<code>pageScope</code>, <code>requestScope</code>, <code>sessionScope</code>, <code>applicationScope</code> 分别可以取得使用对应 JSP 隐式对象的 <code>setAttribute()</code> 方法所设置的属性对象。</p></li><li><p>请求参数相关隐式对象：<code>param</code> 和 <code>paramValues</code></p><p><code>${param.user}</code> 想当于 <code>&lt;%= request.getParameter(&quot;user&quot;)%&gt;</code></p><p><code>paramValues</code> 相当于 <code>request.getParameterValues()</code> ，因为返回的可能是多个值，可以用 [] 运算符指定取得的是那个元素。</p></li><li><p>标头相关隐式对象：<code>header</code> 和 <code>headersValues</code>，</p><p><code>${header[&quot;User-Agent&quot;]}</code> <--> <code>reqest.getHeader(&quot;User-Agent&quot;)</code></--></p></li><li><p>Cookie 隐式对象：<code>cookie</code></p><p>用来取得用户 Cookie 设置值。</p></li><li><p>初始参数隐式对象：<code>initParam</code> 可以取得 web.xml 中设置的 <code>ServletContext</code> 初始参数</p></li></ul><h3 id="取得元素的方式"><a href="#取得元素的方式" class="headerlink" title="取得元素的方式"></a>取得元素的方式</h3><p>可以用 . 和 [] 来取得属性中的元素：</p><ul><li>. 运算符：左边可以是 JavaBean 或 Map 对象（Map 建议用 [] 运算符）</li><li>[] 运算符：左边可以是 JavaBean 属性，Map，数组或 List 对象</li></ul><p>[] 在指定索引是使用双引号，就是作为键名或索引来使用，不加双引号会先尝试运算。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol><li>算数运算符：+, -, *(mod), /(div), %(mod), ? : </li><li>逻辑运算符：and, or, not</li><li>关系运算符：&lt;(lt), &gt;(gt), &lt;=(le), &gt;=(ge), ==(eq), !=(ne)</li></ol><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><strong>第一步</strong>：编写类，公开类，且调用的方法是公开且为静态方法</p><p><strong>第二步</strong>：编写 TLD（标签程序描述）文件（xml文件，以 .tld 为后缀），告诉容器如何将类中的方法作为 EL 函数</p><p><strong>第三步</strong>：将文件放在 WEB-INF 文件夹下或 JAR 文件中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;指示元素&quot;&gt;&lt;a href=&quot;#指示元素&quot; class=&quot;headerlink&quot; title=&quot;指示元素&quot;&gt;&lt;/a&gt;指示元素&lt;/h3&gt;&lt;p&gt;JSP指示元素主要是为了表示容器将 JSP 转译为 Servlet 源代码时所必须遵守的信息。&lt;/p&gt;
&lt;p&gt;语法为：&lt;co
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter5 Servlet 进阶API,过滤器与监听器</title>
    <link href="https://phoenixxc.github.io/posts/fd419a6b/"/>
    <id>https://phoenixxc.github.io/posts/fd419a6b/</id>
    <published>2019-02-18T02:44:34.000Z</published>
    <updated>2019-07-22T12:15:56.236Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h3 id="使用-ServletContext"><a href="#使用-ServletContext" class="headerlink" title="使用 ServletContext"></a>使用 ServletContext</h3><blockquote><p><img src="https://img-blog.csdn.net/20160513225142387" alt></p><ul><li><p>你可以把它想象成一个公用的空间，可以被所有的客户访问，也就是说A客户端可以访问D，B客户端可以访问D，C客户端也可以访问D。</p></li><li><p>WEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext，它代表当前Web应用。并且它被所有客户端共享。</p></li><li><p>ServletContext对象可以通过ServletConfig.getServletContext()方法获得对ServletContext对象的引用，也可以通过this.getServletContext()方法获得其对象的引用。</p></li><li><p>由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。公共聊天室就会用到它。</p></li><li><p>当web应用关闭、Tomcat关闭或者Web应用reload的时候，ServletContext对象会被销毁</p></li></ul><hr><p>作者：KLeonard<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/gavin_john/article/details/51399425" target="_blank" rel="noopener">https://blog.csdn.net/gavin_john/article/details/51399425</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p></blockquote><p>当整个Web应用程序加载Web容器后，容器会生成一个<code>ServletContext</code>对象作为<strong>整个应用程序的代表</strong>，可以通过<code>ServletConfig</code>的<code>getServletContext()</code>方法就可以取得<code>ServletContext</code>对象．</p><p><code>ServletContext</code>接口定义了运行Servlet的应用环境的一些行为，可以使用该接口的实现对象来取得所请求资源的URL，设置和存储属性，应用程序初始参数等．</p><ol><li><p><code>getRequestDispatcher()</code></p><p>用来取得<code>RequestDispatcher()</code>实例，路径必须是绝对路径，即以＂/＂开头（代表应用程序根目录）．</p><p><code>HttpServletRequest.getRequestDispatcher(String)</code>既可以使用相对路径也可以使用绝对路径，但是实际上在实现时，如果是环境相对路径则直接委托给<code>ServletContext</code>的<code>getServletContext()</code>，如果是请求相对路径则转换为环境相对路径后，再委托．</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;使用-ServletContext&quot;&gt;&lt;a href=&quot;#使用-ServletContext&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter4 会话管理基本原理</title>
    <link href="https://phoenixxc.github.io/posts/b2e1ccaf/"/>
    <id>https://phoenixxc.github.io/posts/b2e1ccaf/</id>
    <published>2019-02-15T08:18:34.000Z</published>
    <updated>2019-07-22T12:15:38.596Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="会话管理的基本原理"><a href="#会话管理的基本原理" class="headerlink" title="会话管理的基本原理"></a>会话管理的基本原理</h2><p>Web应用程序中有些功能需要多次请求才能完成，所以需要某些方式来记得此次请求与之后请求之间的关系，这类方式称之为<strong>会话管理</strong>．</p><p>会话管理的基本方式有：隐藏域（Hidden Field），Cookie，URL重写等</p><h3 id="使用隐藏域"><a href="#使用隐藏域" class="headerlink" title="使用隐藏域"></a>使用隐藏域</h3><p>在HTTP协议中，服务器并没有记忆功能，那么可以让浏览器在每次请求时＂主动告知＂服务器多次请求间的必要信息，服务器只需单纯处理请求中的信息就好．</p><p>隐藏域就是主动告知服务器多次请求间必要信息的方式之一．</p><p><strong>使用隐藏域的缺点：</strong></p><p>&emsp;&emsp;关掉网页后会丢失之前的信息，仅适合简单的状态管理，查看网页源码可以看到隐藏的信息，不适合用于隐秘性较高的数据．</p><p>隐藏域不是Servlet/JSP实际管理会话时的机制，实现Web应用程序会话的基本原理是由浏览器主动告知必要的信息．</p><h3 id="使用-Cookie"><a href="#使用-Cookie" class="headerlink" title="使用 Cookie"></a>使用 Cookie</h3><p>Cookie 是在浏览器存储信息的一种方式，服务器可以响应浏览器 set-cookie 标头，浏览器收到标头与数值后会以文件的形式存储在计算机上，即 Cookie.</p><p>Cookie 可以设置存活期限．<br>Servlet可以通过<code>Cookie</code>类的<code>getMaxAge()</code>方法获取Cookie的有效期；<br>Servlet可以通过设置<code>Cookie</code>类的<code>setMaxAge( int expiry );</code></p><p>//expiry默认值为 -1；<br>1.如果expiry大于0，则保存有效期为expire时间长度，单位毫秒；<br>2.如果expiry等于0，则指示浏览器删除当前cookie；<br>3.如果expiry小于0，则指示浏览器不保存该cookie到硬盘，就保存在内存中，浏览器关闭就消失；</p><p>创建Cookie:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"user"</span>, <span class="string">"caterpillar"</span>);</span><br><span class="line">cookie.setMaxAge(<span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>); <span class="comment">// 以秒为单位</span></span><br><span class="line"><span class="comment">// 创建cookie及其存活期限</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"><span class="comment">// 将cookie加入响应之中</span></span><br></pre></td></tr></table></figure><p>获取Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">// 取得 Cookie</span></span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">        String name = cookie.getName();<span class="comment">// 获取Cookie名称</span></span><br><span class="line">        String value = cookie.getValue();   <span class="comment">// 获取Cookie数值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"user"</span>.equals(name) &amp;&amp; <span class="string">"caterpillar"</span>.equals(value)) &#123;</span><br><span class="line">            request.setAttribute(name, value);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/user.view"</span>).forward(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet 3.0 中，<code>Cookie</code>增加了<code>setHttpOnly()</code>方法，将Cookie标示为仅用于HTTP，如果浏览器支持，这个Cookie不会被客户端脚本读取，可以用<code>isHttpOnly()</code>方法判断是否被标示</p><h3 id="使用-URL-重写"><a href="#使用-URL-重写" class="headerlink" title="使用 URL 重写"></a>使用 URL 重写</h3><p>URL重写就是GET请求参数的应用，当服务器响应浏览器的上一次请求时，将某些相关信息以超链接的方式响应给浏览器，超链接包括请求参数信息．</p><p>由于URL重写是在超链接之后附加信息，所以必须以GET方式发送请求．</p><p>通常URL重写是用在一些简单的客户端信息保留，或者辅助会话管理．</p><h2 id="HttpSession-会话管理"><a href="#HttpSession-会话管理" class="headerlink" title="HttpSession 会话管理"></a>HttpSession 会话管理</h2><p>Servlet/JSP中会话管理的机制：<code>HttpSession</code></p><h3 id="使用-HttpSession"><a href="#使用-HttpSession" class="headerlink" title="使用 HttpSession"></a>使用 HttpSession</h3><p>获得<code>HttpSession</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line"><span class="comment">// getSession()有两个版本</span></span><br><span class="line"><span class="comment">// 另一个可以传入布尔值作为参数, </span></span><br><span class="line"><span class="comment">// 默认为true，表示尚未存在HttpSession对象时, 直接创建一个新的对象</span></span><br><span class="line"><span class="comment">// 如果是false，如不存在实例返回null</span></span><br></pre></td></tr></table></figure><p>默认在浏览器关闭前，<code>HttpSession</code>都是相同的实例，如果想要让目前的<code>HttpSession</code>失效可以调用<code>HttpSession</code>的<code>invalidate()</code>方法，执行这个方法后，容器会销毁回收<code>HttpSession</code>对象，再调用<code>getSession()</code>取得的对象是另一个新对象.</p><p>设置与获得属性：</p><ul><li><code>setAttribute()</code>：设置属性</li><li><code>getAttribute()</code>：获得属性</li></ul><p><strong><code>HttpSession</code>不是线程安全，需要注意属性设定的共享存取问题</strong></p><h3 id="HttpSession-会话管理原理"><a href="#HttpSession-会话管理原理" class="headerlink" title="HttpSession 会话管理原理"></a>HttpSession 会话管理原理</h3><p>尝试运行<code>HttpSession</code>的<code>getSession()</code>方法时，Web容器会创建<code>HttpSession</code>对象，每个对象都有一个特殊的ID: <strong>Session ID</strong>，可以用<code>HttpSession</code>的<code>getId()</code>来取得Session ID，ID默认使用Cookie存储在浏览器中．</p><p><code>HttpSession</code>中存放的属性也存放在服务端的Web容器里，当浏览器请求应用程序时，会将Cookie中的Session ID 一同发送给应用程序里，Web容器会根据得到的ID找到对应的Session对象，这样就可以取得各浏览器的各自的会话数据．</p><p>Web容器存储Session ID的Cookie默认设置当浏览器被关闭就失效，浏览器重新启动后由于ID失效，尝试<code>getSession()</code>后，容器会产生新的<code>HttpSession</code>对象，如果不使用<code>invalidate()</code>使对象立即失效，对象会等到设定的失效期间过后才会被销毁回收．</p><p>设置<code>HttpSession</code>对象失效时间的方法：</p><ul><li><p>调用该对象的<code>setMaxInactiveInterval()</code>方法，设定浏览器多久没请求应用程序的话就自动失效，单位为<strong>秒</strong>；</p></li><li><p>也可以在web.xml中修改，设定的单位是<strong>分钟</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><code>HttpSession</code>的属性中尽量不要存储耗资源的对象，必要时将属性移除（<code>public void removeAttribute(String name)</code>），或者让其失效．</p><p>Servlet 3.0 中新增了<code>SessonCookieConfig</code>接口，可以通过<code>ServleContext</code>的<code>getSessionCookieConfig()</code>取得该接口的对象，通过这个接口的实现对象可以设定存储Session ID的Cookie相关的信息，设定必须在<code>ServletContext</code>初始化之前</p><ul><li>在web.xml中设定</li><li>实现<code>ServletContextListener</code></li></ul><h3 id="HttpSession-与-URL-重写"><a href="#HttpSession-与-URL-重写" class="headerlink" title="HttpSession 与 URL 重写"></a>HttpSession 与 URL 重写</h3><p>因为<code>HttpSession</code>默认使用Cookie来存储ID，如果浏览器禁用Cookie，还想使用<code>HttpSession</code>来进行会话管理的话，可以搭配URL重写，向浏览器响应一段超链接，超链接URL附加上Session ID，单击超链接后将Session ID以<strong>GET</strong>请求发送给Web应用程序．</p><p>如果要使用URL重写的方式发送Session ID，可以使用<code>HttpServletResponse</code>的<code>encodeURL()</code>协助产生需要的URL，如果Cookie可用，将URL本身输出，如果不可以会自动产生带有Session ID的URL重写．</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;会话管理的基本原理&quot;&gt;&lt;a href=&quot;#会话管理的基本原理&quot; class=&quot;headerlink&quot; title=&quot;会话管理的基本原理&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter3 请求与响应</title>
    <link href="https://phoenixxc.github.io/posts/2b70cf0d/"/>
    <id>https://phoenixxc.github.io/posts/2b70cf0d/</id>
    <published>2019-02-13T06:30:34.000Z</published>
    <updated>2019-07-22T12:15:21.569Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="从容器到-HttpServlet"><a href="#从容器到-HttpServlet" class="headerlink" title="从容器到 HttpServlet"></a>从容器到 HttpServlet</h2><h3 id="web-容器做了什么"><a href="#web-容器做了什么" class="headerlink" title="web 容器做了什么"></a>web 容器做了什么</h3><p>当浏览器请求来到HTTP服务器, HTTP服务器转交给容器, 容器会创建一个代表本次请求的<code>HttpServlet</code>对象, 并传给请求的相关信息, 同时会创建一个<code>HttpServletResponse</code>对象, 作为稍后要对客户端进行响应的Java对象.</p><p>然后, 容器会根据@WebServlet标注或web.xml的设置, 找到处理该请求的Servlet, 调用它的<code>service()</code>方法, 传入容器在之前所创建的两个对象, 在service()方法中会根据HTTP请求的方式来调用对应的<code>doXXX()</code>方法.</p><p>最后容器将<code>HttpServletRequest</code>对象和<code>HttpServletResponse</code>对象销毁回收, 结束本次响应.</p><h3 id="doXXX-方法"><a href="#doXXX-方法" class="headerlink" title="doXXX() 方法"></a>doXXX() 方法</h3><p>Servlet接口的<code>service()</code>方法中, 实际接受的参数是<code>ServletRequest</code>, <code>ServletResponse</code>, 在定义Servlet时, 期待Servlet不止用于HTTP, 与HTTP相关的行为由两者的子接口<code>HttpServletRequest</code>, <code>HttpServletResponse</code> 定义.</p><h2 id="关于-HttpServletRequest"><a href="#关于-HttpServletRequest" class="headerlink" title="关于 HttpServletRequest"></a>关于 HttpServletRequest</h2><h3 id="处理请求参数与标头"><a href="#处理请求参数与标头" class="headerlink" title="处理请求参数与标头"></a>处理请求参数与标头</h3><p>HttpServletRequest中定义了取得通用<strong>请求信息</strong>的方法</p><ul><li><p><code>getParameter()</code>: 指定请求参数名称来取得对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String username = request.getParameter(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure><p>返回String对象, 如果请求中没有指定的参数名称, 返回null</p></li><li><p><code>getParameterValues()</code>: 若同一个请求参数名称有多个值, 可以使用这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] values = request.getParameterValues(<span class="string">"param"</span>);</span><br></pre></td></tr></table></figure><p>返回一个存储了参数的值的String数组</p></li><li><p><code>getParameterNames()</code>: 获取请求中所有的请求参数名称, 返回<code>Enumeration</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;String&gt; e = req.getParameterNames();</span><br><span class="line"><span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line">    String name = e.nextElement();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getParameterMap()</code>: 将请求参数以<code>Map</code>对象返回, 键为请求参数名(String), 值为请求参数值(String[])</p></li></ul><p>获取HTTP<strong>标头信息</strong></p><ul><li><code>getHeader()</code>: 与<code>getParameter()</code>类似, 指定标头名称返回标头信息</li><li><code>getHeaders()</code>: 与<code>getParameterValues()</code>类似, 指定标头名称返回<code>Enumeration</code>对象, 元素为字符串</li><li><code>getHeaderName()</code>: 与<code>getParameterNames()</code>类似, 取得所有标头名称, 返回<code>Enumeration</code></li></ul><h3 id="请求参数编码处理"><a href="#请求参数编码处理" class="headerlink" title="请求参数编码处理"></a><del>请求参数编码处理</del></h3><ul><li><p>POST</p><p>如果客户端没有在 Content-Type 标头中设置字符编码, 使用<code>HttpSerletRequest</code>的<code>getCharacterEncoding()</code>返回值是<code>null</code></p><p>可以使用<code>HttpServletRequest</code>的<code>setCharacterEncoding()</code>方法指定取得POST请求参数时使用的编码, 只有在取得参数前执行才有用.</p></li><li><p>GET</p><p>如果是GET, 上述的方法设置编码无用.</p><p>另一种处理编码的方式: 通过<code>String</code> 的 <code>getBytes()</code>指定编码来取得字符串的字节数组, 然后再重新构造为正确编码的字符串.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = req.getParameter(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 假设浏览器使用UTF-8, web容器使用ISO-8859-1</span></span><br><span class="line">name = <span class="keyword">new</span> String(name.getBytes(<span class="string">"ISO-8859-1"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// public String(byte[] bytes, String charsetName);</span></span><br></pre></td></tr></table></figure></li></ul><p>Tomcat8URI默认编码为“UTF-8”，而Tomcat7URI默认编码为“ISO-8859-1”</p><p><strong>原书为繁体, 如果要使结果正常需要使用Tomcat7环境, form-get.html, form-post.html两个网页用繁体(编码为Big5), 或者简体(编码为GBK)</strong></p><p>参考资料: <a href="https://blog.csdn.net/h12kjgj/article/details/73496528" target="_blank" rel="noopener">(转)Java 正确的做字符串编码转换</a></p><blockquote><p>那么，如何利用getBytes 和 new String() 来进行编码转换呢？ 网上流传着一种错误的方法:<br>GBK–&gt; UTF-8: new String( s.getBytes(“GBK”) , “UTF-8); ,这种方式是完全错误的，因为getBytes 的编码与 UTF-8 不一致，肯定是乱码。<br>但是为什么在tomcat 下，使用 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 却可以用呢？ 答案是：<br>tomcat 默认使用iso-8859-1编码， 也就是说，如果原本字符串是GBK的，tomcat传输过程中，将GBK转成iso-8859-1了，<br>默认情况下，使用iso-8859-1读取中文肯定是有问题的，那么我们需要将iso-8859-1 再转成GBK， 而iso-8859-1 是单字节编码的，<br>即他认为一个字节是一个字符， 那么这种转换不会对原来的字节数组做任何改变，因为字节数组本来就是由单个字节组成的，<br>如果之前用GBK编码，那么转成iso-8859-1后编码内容完全没变， 则 s.getBytes(“iso-8859-1”) 实际上还是原来GBK的编码内容<br>则 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 就可以正确解码了。 所以说这是一种巧合。</p></blockquote><h3 id="getReader-getInputStream-读取-Body-内容"><a href="#getReader-getInputStream-读取-Body-内容" class="headerlink" title="getReader(), getInputStream() 读取 Body 内容"></a>getReader(), getInputStream() 读取 Body 内容</h3><p><code>HttpServletRequest</code>上有<code>getReader()</code>方法, 可以取得<code>BufferedReader</code>对象, 通过这个对象可以读取请求的 Body 数据.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">readBody</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader reader = request.getReader();</span><br><span class="line">    <span class="comment">// 取得 BufferedReader 对象, 通过该对象可以读取请求的 Body 数据</span></span><br><span class="line">    String input = <span class="keyword">null</span>;</span><br><span class="line">    String requestBody = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> ((input = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBody = requestBody + input + <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestBody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=%E5%BC%A0%E4%B8%89&amp;passed=1234567&amp;login=%E9%80%81%E5%87%BA</span><br></pre></td></tr></table></figure><p></p><p>如果要上传文件, \&lt;form> 标签需要设置<code>enctype</code>属性为: <code>multipart/form-data</code></p><h3 id="getPart-getParts-取得上传文件"><a href="#getPart-getParts-取得上传文件" class="headerlink" title="getPart() , getParts() 取得上传文件"></a>getPart() , getParts() 取得上传文件</h3><p>在Servlet3.0之后, 新增了<code>Part</code>接口, 可以方便的进行文件上传处理, 可以通过<code>HttpServletRequest</code>的<code>getPart()</code>方法并指定名称才能取得<code>Part</code>实现对象.</p><p>Servlet中要设置<code>@MultipartConfig</code>标注才能取得<code>Part</code>对象, 否则会得到<code>null</code>, 仅仅标注<code>@MultipartConfig</code>表示相关属性使用默认值:</p><ul><li><p><code>fileSizeThreshold</code>: 0</p><p>整数值, 若上传文件大小超过设置的值, 会先写入缓存文件</p></li><li><p><code>loaction</code>: 空字符串 “”</p><p>设置写入文件时的目录</p></li><li><p><code>maxFileSize</code>: -1L 不限制大小</p><p>限制上传文件的大小</p></li><li><p><code>maxRequestSize</code>: -1L 不限制请求个数</p><p>限制 <code>multipart/form-data</code>请求个数</p></li></ul><p>也可以使用<code>getParts()</code>来上传多个文件, 该方法返回一个<code>Collection&lt;Part&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">for</span> (Part part : req.getParts()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(part.getName().startsWith(<span class="string">"file"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 使用getName()获取名称, startsWith()判断名称是否以file开头</span></span><br><span class="line">                String filename= getFilename(part);</span><br><span class="line">                part.write(filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在 web.xml 中也可以设置<code>@MultipartConfig</code>属性:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>UploadServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/tmp/<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="使用-RequestDispatcher-调派请求"><a href="#使用-RequestDispatcher-调派请求" class="headerlink" title="使用 RequestDispatcher 调派请求"></a>使用 RequestDispatcher 调派请求</h3><p>在 Web 应用程序中, 经常需要多个 Servlet 来完成请求, 这时可以使用<code>HttpServletRequest</code>的<code>getRequestDispatcher()</code>方法取得<code>RequestDispatcher</code>接口的实例, 调用时只需指定转发或包含相对的URL网址.</p><ol><li><p>使用 include() 方法</p><p><code>RequestDispatcher</code> 的 include() 方法可以将另一个 Servlet 的操作流程包括至目前 Servlet 操作流程之中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher dispatcher = req.getRequestDispatcher(<span class="string">"other.view"</span>);</span><br><span class="line">dispatcher.include(req, resp);</span><br></pre></td></tr></table></figure><p>在取得<code>RequestDispatcher</code>时也可以包括查询字符串, .<code>..(&quot;other.view?data=123456&quot;);</code></p></li><li><p>请求范围属性</p><p>在<code>include()</code>或<code>forward()</code>时如果包括请求参数的做法只适用于传递字符串给另一个Servlet, 在调派请求中, 如果有必须共享的对象, 可以设置请求范围属性</p><p><code>HttpServletRequest</code>上与请求范围属性有关的方法:</p><ul><li><code>setAttribute()</code>: 指定名称与对象设置属性</li><li><code>getAttribute()</code>: 指定名称取得属性</li><li><code>getAttributeNames()</code>: 取得所有属性名称</li><li><code>remoteAttribute()</code>: 指定名称移除属性</li></ul><p>以<code>java.</code>, <code>javax.</code>开头的名称通常保留, 用于表示一些特定的意义:</p><ul><li><code>javax.servlet.include.request_uri</code></li><li><code>javax.servlet.include.context_path</code></li><li><code>javax.servlet.include.servlet_path</code></li><li><code>javax.servlet.include.path_info</code></li><li><code>javax.servlet.include.query_string</code></li></ul><p>在被包含的 Servlet 中分别表示上一个 Servlet 的 Request URI, Context path, Servlet path, Path info 和取得<code>RequestDispatcher</code>时给定的参数</p></li><li><p>使用 forward() 方法</p><p>调用时同样也要传入请求和响应对象, 表示要将请求处理转发给别的 Servlet , 对客户端的响应同时转发给另一个 Servlet</p><p>如果要调用<code>forward()</code>方法, 当前的Servlet中不能有任何响应确认, 如果通过响应对象设置了响应但未确认, 响应设置会全部被忽略, 如果有响应确认了仍调用这个方法, 会抛出<code>IllegalStateException</code></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;从容器到-HttpServlet&quot;&gt;&lt;a href=&quot;#从容器到-HttpServlet&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>Chapter2 编写与设置Servlet</title>
    <link href="https://phoenixxc.github.io/posts/92aa08ef/"/>
    <id>https://phoenixxc.github.io/posts/92aa08ef/</id>
    <published>2019-02-11T10:40:34.000Z</published>
    <updated>2019-07-22T12:15:15.349Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --><h2 id="在-HelloServlet-之后"><a href="#在-HelloServlet-之后" class="headerlink" title="在 HelloServlet 之后"></a>在 HelloServlet 之后</h2><h3 id="关于-HttpServlet"><a href="#关于-HttpServlet" class="headerlink" title="关于 HttpServlet"></a>关于 HttpServlet</h3><p>Servlet 需要的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 Servlet 定义相关的类或接口都位于 javax.servlet 包中</span></span><br><span class="line"><span class="comment">// 与 HTTP 定义先关的类与接口都位于 javax.servlet.http 包中</span></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br></pre></td></tr></table></figure><p>当请求到来时，Web容器会调用 Servlet 的 <code>service()</code> 方法．</p><p>HttpServlet 的 service() 方法的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">servlet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String method = req.getMethod();<span class="comment">// 取得请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        doGet(req, resp);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        doHead(req, resp);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-WebServlet"><a href="#使用-WebServlet" class="headerlink" title="使用@WebServlet"></a>使用@WebServlet</h3><p>在Servlet3.0中，可以使用标注来告诉容器哪些Servlet会提供服务和额外的信息.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/hello.view"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="comment">// 告诉容器请求的URL如果是＂/hello.view＂，就由 HelloServlet 的实例来提供服务</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(</span><br><span class="line">name = <span class="string">"Hello"</span>, </span><br><span class="line">    <span class="comment">// 告诉容器这个 Servlet 的名称为 Hello, 默认为 Servlet 类的完整名称</span></span><br><span class="line">    urlPatterns = &#123;<span class="string">"/hello.view"</span>&#125;,</span><br><span class="line">    <span class="comment">// 如果客户端的请求的URL是/hello.view，由这个Servlet的实例来处理</span></span><br><span class="line">    loadOnStartup = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 默认值: -1</span></span><br><span class="line">    <span class="comment">// 容器在首次处理某个Servlet服务时才会初始化对应的Servlet实例，</span></span><br><span class="line">    <span class="comment">// 如果希望应用程序启动时就将Servlet类载入, 实例化并初始化</span></span><br><span class="line">    <span class="comment">// 可以用loadOnStartup设置为大于0的值, 数字小的初始化, 相同的值由容器自定义行为</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="使用Web-xml"><a href="#使用Web-xml" class="headerlink" title="使用Web.xml"></a>使用Web.xml</h3><p>Servlet3.0 之前, 必须通过web.xml来定义Servlet的相关信息, Servlet3.0中也可以用他来定义相关的信息.</p><p>web.xml 中的设置会覆盖 Servlet 中定义的值（name 值要相同）.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--...--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>   </span><br><span class="line">        <span class="comment">&lt;!--名字--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Servlet 是 servlet-class 指定类的实例--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置何时初始化, 值相同按照在web.xml中设置的顺序初始化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloUser.view<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果客户端请求的URL是/helloUser.view, 则由HelloServlet这个Servlet来处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--...--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件组织与部署"><a href="#文件组织与部署" class="headerlink" title="文件组织与部署"></a>文件组织与部署</h3><p>Web程序应用程序文件组织:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── other</span><br><span class="line">│   └── \......</span><br><span class="line">└── web</span><br><span class="line">    ├── index.jsp</span><br><span class="line">    └── WEB-INF</span><br><span class="line">        ├── classes</span><br><span class="line">        │   └── HelloServlet.class</span><br><span class="line">        ├── lib</span><br><span class="line">        └── web.xml</span><br></pre></td></tr></table></figure><ul><li>WEB-INF: 目录名称固定, 该目录对外界封闭, 客户端无法使用HTTP的任何方式直接访问该目录下的文件及目录</li><li>web.xml: 放在WEB-INF根目录下, 名称固定, Web应用程序部署描述文件</li><li>lib: 放置JAR文件的目录, 放在WEB-INF根目录下, 名称固定</li><li>classes: 放置编译后的.class文件的目录, 位于WEB_INF根目录下, 名称固定, 编译后的类文件, 必须有与包名称相符的目录结构</li></ul><p>在部署Web应用程序时, 会将Web应用程序封装为<strong>WAR</strong>文件, 如过服务器使用Tomcat, 可以将war文件放置在tomcat安装目录的<code>webapps</code>目录中, 然后重启Tomcat服务.</p><p>然后可以用: <code>http://(服务器ip或域名):(端口号)/(war文件名)/</code> 来访问</p><h2 id="进阶部署设置"><a href="#进阶部署设置" class="headerlink" title="进阶部署设置"></a>进阶部署设置</h2><p>…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 06 2020 10:04:18 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;在-HelloServlet-之后&quot;&gt;&lt;a href=&quot;#在-HelloServlet-之后&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="JavaWeb" scheme="https://phoenixxc.github.io/categories/JavaWeb/"/>
    
    
      <category term="JSP&amp;Servlet学习笔记" scheme="https://phoenixxc.github.io/tags/JSP-Servlet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Note" scheme="https://phoenixxc.github.io/tags/Note/"/>
    
  </entry>
  
</feed>
