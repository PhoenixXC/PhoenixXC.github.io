<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BASE理论]]></title>
    <url>%2Fposts%2Fd302a974%2F</url>
    <content type="text"><![CDATA[由于分布式数据库的结构特性，根据分布式系统的 CAP定理，实现 ACID 事务需要付出很大的成本来维护可用性，所以为了保障可用性而总结出一套弱化的事务特性：基本可用（Basically Available）：系统能够基本运行、一直提供服务。软状态（Soft-state）：系统不要求一直保持强一致状态。最终一致性（Eventual consistency）：系统需要在某一时刻后达到一致性要求。简称BASE，与ACID相对应（acid为“酸”的英文名称，base为“碱”的英文名称）。基本可用什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：响应时间上的损失：正常情况下的搜索引擎0.5秒即返回给用户结果，而基本可用的搜索引擎可以在2秒作用返回结果。功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。软状态什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。最终一致性上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素。而在实际工程实践中，最终一致性分为5种：因果一致性（Causal consistency）因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。读己之所写（Read your writes）读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。会话一致性（Session consistency）会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。单调读一致性（Monotonic read consistency）单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。单调写一致性（Monotonic write consistency）单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。作者：零壹技术栈链接：https://juejin.im/post/5b2663fcf265da59a401e6f8来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。参考资料：分布式数据库#事务性质分布式理论二—BASE理论]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAP理论]]></title>
    <url>%2Fposts%2F6940af88%2F</url>
    <content type="text"><![CDATA[CAP 定理，又被称为 布鲁尔定理，指出对于一个分布式计算系统来说，不可能同时满足以下三点：一致性（*C**onsistency*）所有节点都能访问同一份最新的数据副本三种一致性策略对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。CAP中说，不可能同时满足的这个一致性指的是 强一致性。可用性（*A**valiablity*）每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据，服务一直可用且是正常响应时间。对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。| 可用性分类 | 可用水平（%） | 年可容忍停机时间 || :————————–: | :———–: | :————–: || 容错可用性 | 99.9999 | &lt;1 min || 极高可用性 | 99.999 | &lt;5 min || 具有故障自动恢复能力的可用性 | 99.99 | &lt;53 min || 高可用性 | 99.9 | &lt;8.8h || 商品可用性 | 99 | &lt;43.8 min |好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。分区容错性（*P**artition tolerance*）分布式系统在某节点或网络分区故障的时候，仍然能够堆外提供满足一致性和可用性的服务以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。参考资料：维基百科—CAP定理分布式系统的CAP理论]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud学习]]></title>
    <url>%2Fposts%2F5c6cd659%2F</url>
    <content type="text"><![CDATA[参考视频：阳哥带你学spring cloud代码地址：https://github.com/PhoenixXC/LearnJava/tree/master/SpringCloud/ShangGuiGu准备版本对应关系浏览器访问：https://start.spring.io/actuator/info可以获得版本的详细对应关系视频版本推荐组件版本cloudHoxton.SR1boot2.2.2.RELEASEcloud alibaba2.1.0.RELEASEJavaJava 8Maven3.5+MySQL5.7+Cloud 停更被动修复 bugs不接受合并请求不再发布新版本资料查看官网文档/社区中文版。架构搭建约定 &gt; 配置 &gt; 编码微服务模块的创建建立 module修改 pom编写 YML主启动业务类热部署的开启热部署在开发阶段中使用，不要在生产环境中使用项目中添加 devtools1234567&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;在 pom.xml 中添加插件123456789101112131415&lt;!-- pom.xml --&gt;&lt;build&gt; &lt;finalName&gt;cloud-provider-payment8001&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 热部署 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;启用 automatic build更新值Idea 中 CTRL+SHIFT+ALT+/ ：点击 Registry将框住的选项打钩重启 IDEA服务治理服务治理：管理服务之间的依赖关系，可以实现服务调用，负载均衡、容错等，实现服发现和注册Eureka集群原理Eureka Server服务注册将服务信息注册进注册中心服务发现从注册中心上获取服务信息，实质：存 key 服务名，取 value 调用地址Service Provider先启动 eureka 注册中心启动服务提供者服务提供者将自身的信息注册进 eurekaService Consumer消费者在需要调用接口时，使用服务别名去注册中心获取实际的 RPC 远程调用地址消费者获取调用地址后，底层利用 HttpClient 技术实现远程调用消费者获取服务地址后会缓存在本地 Jvm 内存中，默认每隔 30 秒更新一次服务调用地址自我保护机制原因：某时刻某一个微服务不可用了，Eureka 不会立刻清理，依旧会保留微服务信息CAP 理论中的 AP 分支如何关闭：yml 中设置 eureka.server.eable-self-preservation=falseZookeeper引入 zookeeper-discovery排除自带的 zookeeper，引入版本合适的 zookeeperyml文件配置1234567spring: application: # 微服务注册名称 name: cloud-payment-service cloud: zookeeper: connect-string: 169.22.2.2:2181SpringBoot 启动类加上注解：@EnableDiscoveryClient启动服务后，在 /services 下面会有有服务名称相同的节点，里面有一个临时节点存储了服务注册的信息。Zookeeper 没有自我保护机制ConsulGo 语言编写作用服务注册健康检查KV存储安全多数据三个注册中心异同组件语言CAP服务健康检查对外暴露端口SpringCloud集成EurekaJavaAP可配HTTP集成ConsulGoCP支持HTTP/DNS集成ZookeeperJavaCP支持客户端集成负载均衡关于什么是负载均衡将用户的请求平摊的分配到多个服务上，从而达到系统的 HA （高可用）。常见的负载均衡有软件 Nginx，LVS，硬件 F5 等本地负载均衡客户端 vs Nginx 服务端负载均衡Nginx 是服务器负载均衡，客户端说起有请求都会交给 Nginx，然后由 Nginx 实现请求转发。Ribbon 本地负载均衡，在调用微服务接口的时候，会在注册中心上获取注册信息服务列表之后缓存到 JVM 本地，从而在本地实现 RPC 远程服务调用技术。集中式 vs 进程内集中式在服务的消费方和提供方之间使用独立的 LB 设施，由该设施负责把访问请求通过某种策略转发至服务的提供方。进程内将 LB 集成到消费方RibbonRibbon 是一个软负债均衡的客户端组件，可以和其他客户端配合使用。工作分为两步：先选择 EurekaServer，优先选择在同一个区域内负债较少的 server根据用户指定的策略，在从 server 取到的服务注册列表中选择一个地址。Ribbon 提供了多种策略，轮训、随机和根据响应时间加权等引入 Eureka 的时候，默认引入了 RibbonIRuleRibbon 内置了很多负载均衡策略：替换负载均衡算法创建自定义配置自定义配置类不能放在 @CompoentScan 所扫描的包以及子包下，否则这个自定义的配置类就会被所有的 Ribbon 客户端共享，达不到特殊化定制的目的。123456789@Configurationpublic class MySelfRule &#123; @Bean public IRule myRule() &#123; return new RandomRule(); &#125;&#125;主启动类添加 @RibbonClient12345678910@SpringBootApplication@EnableEurekaClient@RibbonClient(name = "CLOUD-PAYMENT-SERVICE", configuration = MySelfRule.class)public class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class); &#125;&#125;负载均衡算法原理轮训rest 接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启后 rest 从1开始计数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677private AtomicInteger nextServerCyclicCounter;private static final boolean AVAILABLE_ONLY_SERVERS = true;private static final boolean ALL_SERVERS = false; private static Logger log = LoggerFactory.getLogger(RoundRobinRule.class); public RoundRobinRule() &#123; nextServerCyclicCounter = new AtomicInteger(0);&#125; public RoundRobinRule(ILoadBalancer lb) &#123; this(); setLoadBalancer(lb);&#125; public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; log.warn("no load balancer"); return null; &#125; Server server = null; int count = 0; while (server == null &amp;&amp; count++ &lt; 10) &#123; List&lt;Server&gt; reachableServers = lb.getReachableServers(); List&lt;Server&gt; allServers = lb.getAllServers(); int upCount = reachableServers.size(); int serverCount = allServers.size(); if ((upCount == 0) || (serverCount == 0)) &#123; log.warn("No up servers available from load balancer: " + lb); return null; &#125; int nextServerIndex = incrementAndGetModulo(serverCount); server = allServers.get(nextServerIndex); if (server == null) &#123; /* Transient. */ Thread.yield(); continue; &#125; if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123; return (server); &#125; // Next. server = null; &#125; if (count &gt;= 10) &#123; log.warn("No available alive servers after 10 tries from load balancer: " + lb); &#125; return server;&#125; /** * Inspired by the implementation of &#123;@link AtomicInteger#incrementAndGet()&#125;. * * @param modulo The modulo to bound the value of the counter. * @return The next value. */private int incrementAndGetModulo(int modulo) &#123; for (;;) &#123; int current = nextServerCyclicCounter.get(); int next = (current + 1) % modulo; if (nextServerCyclicCounter.compareAndSet(current, next)) return next; &#125;&#125; @Overridepublic Server choose(Object key) &#123; return choose(getLoadBalancer(), key);&#125;手写负载均衡算法原理 + JUC(CAS + 自旋锁)服务调用OpenFeginFegin 是一个声明式的 WebService 客户端，使用 Fegin 可以让客户端更加简单。使用方法：定义一个服务接口然后在上面添加注解，支持可拔插式的编码器和解码器。SpringCloud 对 Fegin 进行了封装，使其支持 Spring MVC 标准注解和 HttpMessgaeConverts。Fegin 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡超时设置123456789101112131415feign: client: config: default: # 建立链接后从服务器读取到可用资源所用的时间 connectTimeout: 5000 # 两端建立连接所用的时间 readTimeout: 5000 # 设置日志类型，打印 loggerLevel: fulllogging: level: com.example.springcloud.service.PaymentFeignService: debughttps://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/3.0.0.M1/reference/html/#configuration-properties日志官网文档有，yml 中配置 config 或创建一个 config bean服务降级Hystrix目前停更，但是用处很多，非常重要resillience4j国外用的多sentinelali牛掰复制分布式系统结构中的应用有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败服务雪崩多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，导致“雪崩效应”。服务降级（fallback）导致服务降级的原因：程序运行异常超时服务熔断触发服务降级线程池/信号量打满也会导致服务降级服务熔断（break）达到最大服务访问后，直接决绝访问，调用服务降级的方法返回友好提示。服务限流（flowlimit）秒杀高并发等操作，严禁一起来，先排队，一秒n个，有序进行Hystrix做用服务降级服务熔断接近实时监控服务降级 Pratice使用注解 @HystrixCommand8001设置自身调用时间的峰值，峰值内可以正常运行超过了需要有兜底的方法处理，作服务降级 fallback服务端：主启动类上添加：@EnableCircuitBreaker服务上添加123456789101112131415161718@HystrixCommand(fallbackMethod = "paymentInfoTimeoutHandler", commandProperties = &#123; // 设置线程的超时时间为3秒 @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "3000")&#125;)public String paymentInfoTimeout(Integer id) &#123; int timeNumber = 5; try &#123; // int age = 10 / 0; TimeUnit.SECONDS.sleep(timeNumber); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return "线程池：" + Thread.currentThread().getName() + " paymentInfoTimeout";&#125;public String paymentInfoTimeoutHandler(Integer id) &#123; return "线程池：" + Thread.currentThread().getName() + " paymentInfoTimeoutHandler, :(";&#125;不管是运行超时还是服务异常，都会使用 fallback服务降级既可以加在客户端，也可以加载服务端，一般加载客户端客户端：主启动类加上注解：@EnableHystrix服务上：123456789101112131415@HystrixCommand(fallbackMethod = "paymentInfoTimeoutFallbackMethod", commandProperties = &#123; // 设置线程的超时时间为3秒 @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "1500")&#125;)@GetMapping("/order/payment/hystrix/timeout/&#123;id&#125;")public String paymentInfoTimeout(@PathVariable("id") Integer id) &#123; int age = 10 / 0; String result = paymentHystrixService.paymentInfoTimeout(id); log.info("--- result: " + result); return result;&#125;public String paymentInfoTimeoutFallbackMethod(@PathVariable("id") Integer id) &#123; return "Sorry, I'm consumer80, service busy, please wait some time try again";&#125;存在的问题：Fallback 代码与业务代码耦合代码膨胀解决方式：大部分用通用 Fallback，类上配置注解：@DefaultProperties(defaultFallback = &quot;paymentTimeoutFallbackMethod&quot;)需要降级的方法上直接 @HystrixCommand通用 Fallback 的返回值要兼容，且不能有参数同时为了处理代码耦合，由于需要降级处理的都是来自 OpenFeign 的那个接口，所以可以让 Feign 开启 Hyxtrix，实现该接口，并在接口注解上指定实现类作为 fallback1234567891011@Component@FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-PAYMENT", fallback = PaymentFallbackService.class)public interface PaymentHystrixService &#123; @GetMapping("/payment/hystrix/ok/&#123;id&#125;") String paymentInfoOk(@PathVariable("id") Integer id); @GetMapping("/payment/hystrix/timeout/&#123;id&#125;") String paymentInfoTimeout(@PathVariable("id") Integer id);&#125;1234567891011121314@Componentpublic class PaymentFallbackService implements PaymentHystrixService &#123; @Override public String paymentInfoOk(Integer id) &#123; return "--- PaymentFallbackService OK, :("; &#125; @Override public String paymentInfoTimeout(Integer id) &#123; return "--- PaymentFallbackService Timeout, :("; &#125;&#125;1234# feign 开启 hystrixfeign: hystrix: enabled: true这样当失败时，会调用指定的接口实现类中对应的方法，而且不会处理htstrixCommand指定的的fallback。服务熔断三种状态：断路器起作用的条件：如果断路器开启：进入半开启：Hystrix Dashboard都要添加 actutor 依赖被监控服务注入一个bean123456789101112/** * 配置服务器监控默认路径 */ @Bean public ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings("/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean; &#125;打开监控页面，输入服务url:hystrix.stream服务网关zuul 停更，计划 zuul2，3名作者被挖走，大佬撕逼，导致 zuul2 夭折，Spring 社区受不了自己弄了 gateway。Gateway作用反向代理鉴权流量控制熔断日志监控优势Neflix 一直跳票，Gateway 由 SpringCloud 研发，集成度更好。Gateway 基于异步非阻塞模型开发，性能优秀。Zuul 模型Gateway使用了 WebFlux ：路由(Route)是构建网关的基本模块，由 ID、目标 URI、一系列的断言和过滤器组成，如果断言为 true 则匹配该路由。断言(Predicate)参考 Java8 的 java.util.function.Predicate开发人员可以匹配 HTTP 请求中的所有内容（如请求参数和请求头），如果请求与断言相匹配则进行路由过滤(Filter)指的是 Spring 框架中 GateFilter 的实例，使用过滤器，可以在请求被路由前或路由后进行修改。Gateway 工作流程核心逻辑：路由转发 ＋执行过滤器链配置导入 Gateway移除 starter-web 这个包，如果需要 web 支持，可以导入 starter-webflux配置（静态）yaml123456789101112131415spring: application: name: cloud-gateway cloud: gateway: routes: - id: payment_routh # 路由ID，要求唯一，建议配合服务名 uri: http://localhost:8001 # 匹配后提供的路由地址 predicates: - Path=/payment/get/** # 断言 - id: payment_routh # 路由ID，要求唯一，建议配合服务名 uri: http://localhost:8001 # 匹配后提供的路由地址 predicates: - Path=/payment/lb/**创建Bean123456789@Beanpublic RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder) &#123; RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); routes.route("path_route_xcphoenix", r -&gt; r.path("/guonei") .uri("https://news.baidu.com/")); return routes.build();&#125;配置（动态）静态路由会写死 url，但是多数情况下是要部署集群的，这就需要通过微服务名实现动态路由123456789101112131415161718192021spring: application: name: cloud-gateway cloud: gateway: discovery: locator: # 开启从注册中心动态创建路由的功能，利用微服务名进行路由 enabled: true routes: - id: payment_routh # 路由ID，要求唯一，建议配合服务名# uri: http://localhost:8001 # 匹配后提供的路由地址 uri: lb://CLOUD-PAYMENT-SERVICE # 匹配后提供微服务的路由地址 predicates: - Path=/payment/get/** # 断言 - id: payment_routh2 # 路由ID，要求唯一，建议配合服务名# uri: http://localhost:8001 # 匹配后提供的路由地址 uri: lb://CLOUD-PAYMENT-SERVICE predicates: - Path=/payment/lb/** # 断言Predicate官方提供了很多 Predicate：Filter自定义：12345678910111213141516171819202122232425@Component@Slf4jpublic class MyLogGatewayFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; log.info("---------- come in myLogGatewayFilter"); String uname = exchange.getRequest().getQueryParams().getFirst("uname"); if (uname == null) &#123; log.info("----- 非法用户"); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125; /** * 优先级，值越小优先级越高 */ @Override public int getOrder() &#123; return 0; &#125;&#125;服务配置ConfigThe HTTP service has resources in the following form:12345/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.propertieswhere application is injected as the spring.config.name in the SpringApplication (what is normally application in a regular Spring Boot app), profile is an active profile (or comma-separated list of properties), and label is an optional git label (defaults to master.)不管是 .yml 还是 .properties 都可以通过 xxxx.yml 或 xxxx.properties。其中 /{application}/{profile}[/{label}] 这种格式返回的是一个 json 字符串其他四种返回的都是对应的文件内容如果访问一个不存在的配置，那么返回一个表示错误的 json 字符串服务端配置maven12345&lt;!-- Config --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;yml123456789spring: application: name: cloud-config-center cloud: config: server: git: uri: /home/xuanc/桌面/LearnJava/SpringCloud/ShangGuiGu/springcloud-config label: master可以使用 git 或者文件路径，git 可以需要配置用户名和密码，git 地址，仓库名等客户端配置maven123456&lt;!-- 写错就是一个坑 --&gt;&lt;!-- Config --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;配置 bootstrap.yml1234567891011121314151617server: port: 3355spring: application: name: config-client cloud: config: label: master name: config profile: dev uri: http://config3344:3344 eureka: client: server-url: defaultZone: http://eureka7001:7001/eurekacode123456789101112@RestControllerpublic class ConfigController &#123; @Value("$&#123;config.info&#125;") private String configInfo; @GetMapping("/configInfo") public String getConfigInfo() &#123; return configInfo; &#125;&#125;config.info 来自 config-server 中配置的信息（git或文件中的数据），客户端通过配置向服务端发送请求，获取到：12&gt; &#123;"name":"config","profiles":["dev"],"label":"master","version":"e7b77b33bada2e2812236072305022642242c58b","state":null,"propertySources":[&#123;"name":"/home/xuanc/桌面/LearnJava/SpringCloud/ShangGuiGu/springcloud-config/config-dev.yml","source":&#123;"config.info":"master branch,springcloud-config/config-dev.yml version=1"&#125;&#125;]&#125;&gt;并取出其中的 propertySources 与添加到客户端的环境属性中，这样客户端可以直接通过 config.info 去访问配置信息boostrap.ymlapplication.yml 是用户级bootstrap.yml 是系统级的，优先级更高配置刷新当文件发生变化后（git 需要 commit 才行），服务端可以感知到变化并更新配置，客户端不能立马感知。设置动态刷新：引入 actuator 模块暴露监控端点12345management: endpoints: web: exposure: include: "*"控制类加上 @RefreshScope发送 POST 刷新 http://localhost:3355/actuator/refresh缺点：不能广播，批量刷新，同时保证精确刷新消息总线Bus为了解决上面的动态刷新的问题，引入了 SpringCloud Bus第二种架构更加合适，第一种：破坏了微服务的职责单一性，微服务本身是业务模块，不应该承担配置刷新的职责破坏了微服务各节点的对等性有一定的局限性，比如当微服务迁移时，网络地址和常常会发生变化Bus 支持两种 MQ：RabbitMQ、KafkaConfig自动刷新步骤基于上面的手动刷新添加依赖12345&lt;!-- Bus: RabbitMQ --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;需要amqp以及actuator依赖yaml 配置 RabbitMQ123456# 配置rabbitmqrabbitmq: host: localhost port: 5672 username: guest password: guest前两部分服务端和客户端都要配置服务端暴露端点123456# rabbitmq相关配置，暴露bus刷新配置的端点management: endpoints: web: exposure: include: '*'POST 请求：http://ip:port/actuator/bus-refresh这样就可以自动刷新客户端的配置（控制器要有 @RefreshScope）定点通知在上面配置完成后，如果需要定点刷新，可以发送 POST /actuator/bus-refresh/{destination}服务端收到请求后，会通过参数来指定需要更新配置的服务或实例Cloud Stream常用的 MQ（消息中间件）ActiveMQRabbitMQRocketMQKafkaMQ 太多，如果服务用到多个 MQ，那么切换、维护、开发都会带来困难所以需要一种适配绑定的方式，自动的在各种 MQ 切换那么 springcloud stream 就可以屏蔽 MQ 的细节概述是什么屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型。Spring Cloud Stream 是一个构建消息驱动微服务的框架。应用程序通过 inputs 和 outputs 来与 Spring Cloud Stream 中 binder 对象交互所以，只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。通过使用 Spring Integration 来连接消息代理中间件以实现消息事件驱动。Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引发了发布-订阅、消费组、分区的三个核心概念。目前仅支持：RabbitMQ、KafkaBinder 绑定器是屏蔽 MQ 的核心设计思想标准MQ生产者/消费者之间靠消息媒介传递消息内容：Message消息必须走特定的通道：消息通道MessageChannel消息通道里的消息如何被消费，谁负责收发消息：消息通道的子接口 SubscribableChannel，由 MessageHandler 消息处理器所订阅为什么用Cloud Stream如果用到了多个 MQ，多个 MQ 的架构不同，直接使用会导致代码耦合，切换和适配就十分困难。通过定义绑定器 Binder 作为中间层，实现了应用程序和消息中间件细节之间的隔离BinderINPUT消费者OUTPUT生产者通信方式发布——订阅模式，使用 Topic 主题广播（RabbitMQ -&gt; Exchange，Kafka -&gt; Topic）使用方法组成Binder连接中间件，屏蔽差异Channel通道，是队列 Queue 的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过 Channel 对队列进行配置可以理解为参照对象是 Spring Cloud Stream 自身，从 Stream 发布消息就是输出，接受消息就是输入常用注解USE导入依赖12345&lt;!-- MQ --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt;Yaml 配置1234567891011121314151617181920212223242526272829spring: application: name: cloud-stream-provider cloud: stream: # 配置需要绑定的 rabbitmq 的服务信息 binders: # 表示定义的名称，用于 binding 整合 defaultRabbit: # 消息组件类型 type: rabbit # mq 环境配置 enviroment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest # 服务资源整合 bindings: # 通道名，消费端为input output: # 要使用的 Exchange 名称 destination: studyExchange # 消息类型 content-type: application/json # 设置绑定的消息服务的具体设置 binder: defaultRabbit生产者123456789101112131415161718192021// 定义消息的推送管道@EnableBinding(Source.class)public class MessageProviderImpl implements IMessageProvider &#123; /** * 消息发送管道 */ @Resource private MessageChannel output; @Override public String send() &#123; String serial = UUID.randomUUID().toString(); // 发送 output.send(MessageBuilder.withPayload(serial) .build()); log.info("----&gt; serial: " + serial); return null; &#125;&#125;消费者1234567891011121314@Slf4j@Component@EnableBinding(Sink.class)public class ReceiveMessageController &#123; @Value("$&#123;server.port&#125;") private String serverPort; @StreamListener(Sink.INPUT) public void input(Message&lt;String&gt; message) &#123; log.info("receive: " + message.getPayload() + "\t port: " + serverPort); &#125;&#125;泛型和生产者类型要匹配分组消费和持久化重复消费如果有多个消费端，会出现消息被重复消费的问题；这种就需要用到 消息分组 才解决，在 Stream 中，处于同一个 group 的多个消费者是竞争关系，能够保证消息只会被其中一个应用消费一次。==不同组是可以重复消费的，同一个组存在竞争关系。==不配置的话，默认情况下 group 是不同的设置分组的方法：修改 yaml 配置12345678910111213141516171819202122232425262728293031spring: application: name: cloud-stream-consumer cloud: stream: # 配置需要绑定的 rabbitmq 的服务信息 binders: # 表示定义的名称，用于 binding 整合 defaultRabbit: # 消息组件类型 type: rabbit # mq 环境配置 enviroment: spring: rabbitmq: host: localhost port: 5672 username: guest password: guest # 服务资源整合 bindings: # 通道名 input: # 要使用的 Exchange 名称 destination: studyExchange # 消息类型 content-type: application/json # 设置绑定的消息服务的具体设置 binder: defaultRabbit ＃设置分组 group: groupA这样只需要将同一应用的不同实例设置为同一个组就可避免单独消费持久化：没有配置 group，会导致错过消息链路追踪在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的结果请求，每一个前端请求都会形成一条复杂的分布式服务调用链路，链路中任何一环出现高延时或错误都会引起请求最后的失败。所以需要一套跟踪的框架去追踪。Sleuth &amp; ZipkinSleuth 复制搜集，zipkin 图像化呈现Zipkin12curl -fL -o 'zipkin.jar' 'https://repo1.maven.org/maven2/io/zipkin/zipkin-server/2.21.1/zipkin-server-2.21.1-exec.jar'java -jar zipkin.jar浏览器打开 localhost:9411/zipkin使用添加依赖12345&lt;!-- Sleuth &amp; zipkin --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt;配置 yaml1234567spring: zipkin: base-url: http://localhost:9411 sleuth: sampler: # 采样率值介于 0 ~ 1，1表示全部收集 probability: 1NacosNacos（Naming, Configuration，Service）网址：https://nacos.io/zh-cn/概述是什么注册中心＋配置中心 &lt;==&gt; Eureka + Config + Bus（注册+配置+总线）作用服务注册中心服务配置中心注册中心比较Nacos 支持 CP 和 AP 的切换安装运行环境：Java8 + Maven从 最新稳定版本 下载 nacos-server-$version.zip 包。12unzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gzcd nacos/binLinux/Unix/Mac启动命令(standalone代表着单机模式运行，非集群模式):1sh startup.sh -m standalone如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：1bash startup.sh -m standalone浏览器打开：http://localhost:8848/nacos/用户名和密码都是：nacos服务注册&amp;发现和配置管理服务注册1curl -X POST 'http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080'服务发现1curl -X GET 'http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName'发布配置1curl -X POST "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld"获取配置1curl -X GET "http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test服务注册Nacos 默认支持负载均衡服务端启动服务客户端父项目添加依赖管理12345678&lt;!-- spring cloud alibaba 2.1.0.RELEASE --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;添加依赖1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;配置 yaml12345678910111213spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848management: endpoints: web: exposure: include: '*'启用服务发现主启动类加上注解：@EnableDiscoveryClient服务调用创建 RestTemplate bean，还需要加上 @LoadBalance 注解添加负载均衡，使用服务名来调用服务Consumer 的应用可能还没像启动一个 Provider 应用那么简单。因为在 Consumer 端需要去调用 Provider 端提供的REST 服务。例子中我们使用最原始的一种方式， 即显示的使用 LoadBalanceClient 和 RestTemolate 结合的方式来访问。 pom.xml 和 application.properties 的配置可以参考 1.2 小结。启动一个 Consumer应用的示例代码如下所示：Note 通过带有负载均衡的RestTemplate 和 FeignClient 也是可以访问的。基础配置添加依赖12345678910&lt;!-- Nacos Config --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Nacos 服务发现 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;修改 YAML 配置Nacos 与 springcloud-config 一样，在项目初始化时，要先保证从配置中心进行配置拉取拉取配置后，才能保证项目的正常启动。springboot 配置文件的加载存在优先级，bootstrap 优先级高于 applicationbootstrap.yml123456789101112131415server: port: 3377spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 config: # Nacos 作为配置中心地址 server-addr: localhost:8848 # 指定为 yaml 格式 file-extension: yamlapplication.yml1234# 设置环境spring: profiles: active: dev启动类与服务注册相同，使用 springcloud 原生注解动态刷新@Controller 上添加 @RefreshScope在 Nacos 管理界面更新配置信息后，客户端可以直接感知到配置文件的变化Data ID 命名：在 Nacos Spring Cloud 中，dataId 的完整格式如下：12&gt; $&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;&gt;prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。spring.profile.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。分类配置Nacos 类似与 Java 里面的 package 和 类名，最外层的 namespace 可以区分部署环境，Group 和 DataID 逻辑上区分两个目标对象。默认情况：Namespace=public，Group=DEFAULT_GROUP，Cluster=DEFAULTNamspace 主要用来实现隔离，比如有开发、测试、生产环境，就可以创建三个 Namespace，不同的 Namespace 之间是隔离的；Group 可以把不同的微服务划分到同一个分组里面去；Service 就是微服务，一个 Service 可以包含多个 Cluster，Cluster 是对指定微服务的一个虚拟划分Nacos概念 https://nacos.io/zh-cn/docs/concepts.html命名空间用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。配置集 IDNacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识。Data ID 通常采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名规则保证全局唯一性。此命名规则非强制。配置分组Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和 MQ_topic 配置。DataID指定spring.profile.active 和配置文件的 DataID 来使不同环境下读取不同的配置Group在配置文件中可以指定 group1234567891011121314spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 config: # Nacos 作为配置中心地址 server-addr: localhost:8848 # 指定为 yaml 格式 file-extension: yaml # group group: TEST_GROUPNamespace12345678910111213141516spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 config: # Nacos 作为配置中心地址 server-addr: localhost:8848 # 指定为 yaml 格式 file-extension: yaml # group group: DEV_GROUP # 命名空间 ID namespace: 78df1403-40c7-4c0a-9647-63a1583d2336集群集群模式部署这个快速开始手册是帮忙您快速在你的电脑上，下载安装并使用Nacos，部署生产使用的集群模式。集群部署架构图因此开源的时候推荐用户把所有服务列表放到一个vip下面，然后挂到一个域名下面VIP：虚拟IP，例如 Nginx 集群http://ip1:port/openAPI 直连ip模式，机器挂则需要修改ip才可以使用。http://VIP:port/openAPI 挂载VIP模式，直连vip即可，下面挂server真实ip，可读性不好。http://nacos.com:port/openAPI 域名 + VIP模式，可读性好，而且换ip方便，推荐模式https://nacos.io/zh-cn/docs/cluster-mode-quick-start.htmlNacos 默认使用嵌入式数据库（derby）保存数据，如果启动多个默认配置的 Nacos 节点，数据存储存在一致性问题，为了解决这个问题，Nacos 采用了集中式存储的放啊是来支持集群化部署，目前只支持 MySQL 的存储。部署部署 Nacos 集群Clone 项目，进入根目录12git clone https://github.com/paderlol/nacos-docker.gitcd nacos-docker修改配置example/cluster-ip.yaml1234567891011121314151617181920212223242526272829303132333435363738394041424344version: "2"services: nacos1: image: nacos/nacos-server:latest container_name: nacos1 # 指定网络名和ip networks: Utils: ipv4_address: 169.1.0.6 volumes: - ./cluster-logs/nacos1:/home/nacos/logs env_file: - ../env/nacos-ip.env restart: on-failure nacos2: image: nacos/nacos-server:latest container_name: nacos2 networks: Utils: ipv4_address: 169.1.0.7 volumes: - ./cluster-logs/nacos2:/home/nacos/logs env_file: - ../env/nacos-ip.env restart: always nacos_netcos3: image: nacos/nacos-server:latest container_name: nacos3 networks: Utils: ipv4_address: 169.1.0.8 volumes: - ./cluster-logs/nacos2:/home/nacos/logs env_file: - ../env/nacos-ip.env restart: alwaysnetworks: Utils: # 引入外部网络，默认是创建了一个新的网络 external: name: Utilsenv/nacos-ip.env12345678#nacos dev env#配置集群ip、mysql信息NACOS_SERVERS=169.1.0.6:8848 169.1.0.7:8848 169.1.0.8:8848MYSQL_SERVICE_HOST=172.17.0.1MYSQL_SERVICE_DB_NAME=nacos_configMYSQL_SERVICE_PORT=3306MYSQL_SERVICE_USER=rootMYSQL_SERVICE_PASSWORD=mysqlpass拉取进行生成容器1docker-compose -f example/cluster-ip.yaml up配置 Nginx使用 docker 创建镜像，并设置容器的网络ip配置 nginx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 设置nacos集群ipupstream cluster &#123; server 169.1.0.6:8848; server 169.1.0.7:8848; server 169.1.0.8:8848;&#125;server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; # 匹配路径，设置代理到集群上 location /nacos &#123; #root /usr/share/nginx/html; #index index.html index.htm; proxy_pass http://cluster/nacos; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125;&#125;最后nacos的yaml配置中直接填nginx ip就可以Sentinel概述Hystrix：需要手动搭建平台没有 Web 界面可以细粒度化配置Sentinel:单独的一个组件web 界面配置随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。Sentinel 具有以下特征:丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。广泛的开源生态：Sentinel 提供开gaishu箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。Sentinel 的主要特性：简单来说，Sentinel 的功能：服务雪崩服务降级服务熔断服务限流组成核心库（Java客户端），不依赖于任何框架/库，能够运行于所有的 Java 环境控制体（Dashboard），基于 Spring Boot 开发，可以直接运行安装jar 包地址：https://github.com/alibaba/Sentinel/releases，下载 dashboard使用服务端运行 jar 包客户端添加依赖12345678910&lt;!-- sentinel --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 后续做持久化 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;yaml 配置12345678910111213141516171819spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:12345 # 默认8719，如果被占用会自动从8719开始+1扫描 port: 8719# 监控management: endpoints: web: exposure: include: '*'编写 controller 并访问，就可以看到 sentinel 控制台显示的信息sentinel 是懒加载，只有当访问了之后才会显示出来流量控制（流控，flow control）Doc: 流量控制概述流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：resource：资源名，即限流规则的作用对象count：限流阈值grade： 限流阈值类型（QPS 或并发线程数）limitApp： 流控针对的调用来源，若为 default 则不区分调用来源strategy： 调用关系限流策略controlBehavior： 流量控制效果（直接拒绝、Warm Up、匀速排队）流控模式设置资源名唯一资源，默认请求路径针对来源Sentinel 可以针对调用者进行限流，填写服务名，默认 default（不区分来源）阈值类型/单机阈值QPS（每秒的请求数量）当调用该 api 的 QPS 达到阈值的时候，进行限流线程数当调用该 api 的线程数达到阈值的时候，进行限流处理该 api 请求的线程数达到阈值，再来请求就会直接拒绝；而 QPS 是每秒并发请求数的限制；这个是最大并发请求线程树的限制。当选择 线程数 时，【流控效果】只能是 快速失败。流控模式直接当 api 达到限流条件时，直接限流关联当关联的资源达到阈值时，限流当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢链路只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流），api 级别的针对来源流控效果（只有是 QPS 时才可以设置）快速失败直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。Warm Up当流量突然增大的时候，我们常常会希望系统从空闲状态到繁忙状态的切换的时间长一些。即如果系统在此之前长期处于空闲的状态，我们希望处理请求的数量是缓步的增多，经过预期的时间以后，到达系统处理请求个数的最大值。Warm Up（冷启动，预热）模式就是为了实现这个目的的。默认 coldFactor 为 3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值。限流－冷启动：冷启动设置界面单位是 5可以看到，最开始的阈值是 100/3，慢慢的再一段时间内才开始上升到设置的 100排队等待匀速排队（RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER）方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。Leaky Bucket 对应 流量整形 中的匀速器。它的中心思想是，以固定的间隔时间让请求通过。当请求到来的时候，如果当前请求距离上个通过的请求通过的时间间隔不小于预设值，则让当前请求通过；否则，计算当前请求的预期通过时间，如果该请求的预期通过时间小于规则预设的 timeout 时间，则该请求会等待直到预设时间到来通过（排队等待处理）；若预期的通过时间超出最大排队时长，则直接拒接这个请求。流量控制 - 匀速器模式设置界面单位是 ms设置 QPS = 10，每秒匀速 10 个，间隔时间：1000ms / 10 = 100ms超时时间 20 * 1000ms = 20s如果请求等待时间超过 20s，就会失败：Jmeter 绝对并发：熔断降级概述除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。由于调用关系的复杂性，如果调用链路中的某个资源不稳定，最终会导致请求发生堆积。Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException）。==❈ Setinel 的断路器没有半开状态：半开状态时系统会自动检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常就继续打开断路器不可用（Hystrix）。==策略源码：com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule我们通常用以下几种方式来衡量资源是否处于稳定的状态：平均响应时间 (DEGRADE_GRADE_RT)：当资源的平均响应时间超过阈值（DegradeRule 中的 count，以 ms 为单位）之后，资源进入准降级状态。接下来如果持续进入 5 个请求，它们的 RT 都持续超过这个阈值，那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。Github Wiki 没有强调 5 个请求异常比例 (DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;= N（可配置），并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。N 默认是5，目前没有找到配置 N 的地方异常数 (DEGRADE_GRADE_EXCEPTION_COUNT)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。注意：异常降级仅针对业务异常，对 Sentinel 限流降级本身的异常（BlockException）不生效。为了统计异常比例或异常数，需要通过 Tracer.trace(ex) 记录业务异常。示例：123456789101112131415Entry entry = null;try &#123; entry = SphU.entry(key, EntryType.IN, key); // Write your biz code here. // &lt;&lt;BIZ CODE&gt;&gt;&#125; catch (Throwable t) &#123; if (!BlockException.isBlockException(t)) &#123; Tracer.trace(t); &#125;&#125; finally &#123; if (entry != null) &#123; entry.exit(); &#125;&#125;开源整合模块，如 Sentinel Dubbo Adapter, Sentinel Web Servlet Filter 或 @SentinelResource 注解会自动统计业务异常，无需手动调用。热点key概述何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式。简单使用用 @SentineResource 注解，设置参数，同时在控制台设置参数索引、阈值、时间窗口等参数进行热点key限流；不使用注解无效参数例外项偶尔期望参数是某个特殊值时，限流值要特殊设置。仅支持基本类型和String系统规则（系统自适应限流）Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。系统保护规则是从应用级别的入口流量进行控制，从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。系统规则支持以下的模式：Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。@SentinelResource概述Sentinel 提供了 @SentinelResource 注解用于定义资源，并提供了 AspectJ 的扩展用于自动定义资源、处理 BlockException 等。使用 Sentinel Annotation AspectJ Extension 的时候需要引入以下依赖：12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-annotation-aspectj&lt;/artifactId&gt; &lt;version&gt;x.y.z&lt;/version&gt;&lt;/dependency&gt;注意：注解方式埋点不支持 private 方法。参数说明@SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性：value：资源名称，必需项（不能为空）entryType：entry 类型，可选项（默认为 EntryType.OUT）blockHandler / blockHandlerClass: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数==必需为 static 函数==，否则无法解析。如果被热点限流，且没有设置这个参数，就会直接返回异常错误页面仅被限流时会处理，运行时异常不会处理fallback/fallbackClass：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：返回值类型必须与原函数返回值类型一致；方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。defaultFallback（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：返回值类型必须与原函数返回值类型一致；方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。exceptionsToIgnore（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。注：1.6.0 之前的版本 fallback 函数只针对降级异常（DegradeException）进行处理，不能针对业务异常进行处理。特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 BlockException 时只会进入 blockHandler 处理逻辑。若未配置 blockHandler、fallback 和 defaultFallback，则被限流降级时会将 BlockException 直接抛出（若方法本身未定义 throws BlockException 则会被 JVM 包装一层 UndeclaredThrowableException）。示例：1234567891011121314151617181920212223242526public class TestService &#123; // 对应的 `handleException` 函数需要位于 `ExceptionUtil` 类中，并且必须为 static 函数. @SentinelResource(value = "test", blockHandler = "handleException", blockHandlerClass = &#123;ExceptionUtil.class&#125;) public void test() &#123; System.out.println("Test"); &#125; // 原函数 @SentinelResource(value = "hello", blockHandler = "exceptionHandler", fallback = "helloFallback") public String hello(long s) &#123; return String.format("Hello at %d", s); &#125; // Fallback 函数，函数签名与原函数一致或加一个 Throwable 类型的参数. public String helloFallback(long s) &#123; return String.format("Halooooo %d", s); &#125; // Block 异常处理函数，参数最后多一个 BlockException，其余与原函数一致. public String exceptionHandler(long s, BlockException ex) &#123; // Do some log here. ex.printStackTrace(); return "Oops, error occurred at " + s; &#125;&#125;从 1.4.0 版本开始，注解方式定义资源支持自动统计业务异常，无需手动调用 Tracer.trace(ex) 来记录业务异常。Sentinel 1.4.0 以前的版本需要自行调用 Tracer.trace(ex) 来记录业务异常。SpringCloud 不需要额外配置就可以使用注解，基于 AOP （SpringMVC、SpringBoot）都需要额外配置。自定义限流处理通过设置属性 blockHandlerClass 来将兜底方法与业务代码分开Feign需要在配置文件中开启 sentinel 对 feign 的支持：1feign.sentinel.enabled=true持久化微服务重启或 Sentinel 重启都会丢失配置规则；可以将 sentinel 的配置保存在 Nacos 上或 Redis 中；参考：生产环境中使用-Sentinel一般来说，规则的推送有下面三种模式:推送模式说明优点缺点原始模式API 将规则推送至客户端并直接更新到内存中，扩展写数据源（WritableDataSource）简单，无任何依赖不保证一致性；规则保存在内存中，重启即消失。严重不建议用于生产环境Pull 模式扩展写数据源（WritableDataSource）， 客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 RDBMS、文件 等简单，无任何依赖；规则持久化不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题。Push 模式扩展读数据源（ReadableDataSource），规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用 Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证。生产环境下一般采用 push 模式的数据源。规则持久化；一致性；快速引入第三方依赖持久化到 Nacos添加依赖12345&lt;!-- 后续做持久化 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;修改 yaml 配置1234567891011121314151617181920212223spring: application: name: cloudalibaba-sentinel-service cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:12345 # 默认8719，如果被占用会自动从8719开始+1扫描 port: 8719 # 配置datasource datasource: # 数据源名 ds1: # 使用nacos nacos: server-addr: localhost:8848 dataId: cloudalibaba-sentinel-service groupId: DEFAULT_GROUP data-type: json rule-type: flow可以看到，可以使用多种数据源来持久化添加 Nacos 配置，在上一步设定的配置信息中：1234567891011[ &#123; "resource": "bbyResource", "limitApp": "default", "grade": 1, "count": 5, "strategy": 0, "controlBehavior": 0, "clusterMode": false &#125;]这样重启会后也可以持久化然而控制台添加的规则还是在内存里面，不会从存储到 nacos 中当新建配置时，会发送一个 post 请求：直接复制请求的 json 到 nacos 中就可以（nacos 中的配置是一个数组，将 json 对象添加到数组中）如果想在控制台修改的数据自动同步到 Nacos 中，可以参考：Sentinel-Nacos实现规则持久化参考：查询更改规则Sentinel-控制台（集群流控管理）#规则配置)Seata分布式事务概述单体应用被拆分成微服务，每个服务内部的数据一致性由本地事务保证，但是全局的数据一致性没办法保证。一次业务操作需要跨多个数据源或多个系统进行远程调用，就会产生分布式事务问题。分布式事务2.分布式事务产生原因当架构由单体向多服务演进时，整个系统的可靠性变得难以控制，在单体服务中，一个请求的整个周期，从请求到响应结果，都是在一台服务器上，本地事务就可以保证一组数据操作的一致性。在微服务中，从请求到响应，之间可能跨越多台服务器，多个数据库，如下图，假设有个金融系统，拆分为了多个微服务，每个微服务有自己的数据库，我们现在发起借款这个操作，需要用到以下几个微服务：这个借款操作，可以抽象概括为以下几个步骤：1.用户发起借款，调用借款服务的借款接口；2.借款同时，在授信服务里 减少授信额度；3.借款同时，在资金服务里 增加账户余额；4.借款同时，在日志服务里 增加流水记录；……这里只是假设，实际金融项目中的借款这个动作发生的事情远比上图复杂。由于每个服务都是单独部署的，在理想状态下，上述的操作，可以顺利得以执行。如果中间有服务发生故障了呢？假设一个常见的场景，资金服务由于没有合理使用线程池和连接池，现在内存爆掉，无法正常处理请求，那么，这个链路成为了如下的样子：1.用户发起借款，调用借款服务的借款接口；2.借款同时，在授信服务里 减少授信额度；3.借款同时，在资金服务里 增加账户余额；x4.借款同时，在日志服务里 增加流水记录；……此时，由于是在多个服务中，本地的Transaction已经无法应对这个情况了，现在系列操作导致了上述的情况，用户的授信额度减少了，流水也记录了，但是用户没有收到钱。SOURCE 再有人问你分布式事务，把这篇扔给他分布式事务过程（一ID + 三组件）Transaction ID XID 全局唯一的事务 ID三组件Transaction Coordinator(TC)事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或混滚；Transaction Manager(TM)控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议；Resource Manager(RM)控制分支事务，负责分支注册、状态汇报、并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚一个典型的分布式事务过程：TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。XID 在微服务调用链路的上下文中传播。RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖。TM 向 TC 发起针对 XID 的全局提交或回滚决议。TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。Seata概述Seata 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。官网：http://seata.io/zh-cn/下载安装下载相应的版本：http://seata.io/zh-cn/blog/download.html新建数据库，导入 sqlsql 地址：https://github.com/seata/seata/blob/1.2.0/script/server/db/mysql.sql修改 file.conf12345678910111213141516171819202122232425262728293031## transaction log store, only used in seata-serverstore &#123; ## store mode: file、db # 设置为db mode = &quot;db&quot; ## file store property file &#123; ## .... &#125; ## database store property db &#123; ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = &quot;druid&quot; ## mysql/oracle/postgresql/h2/oceanbase etc. dbType = &quot;mysql&quot; driverClassName = &quot;com.mysql.jdbc.Driver&quot; # 数据库配置 url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot; user = &quot;root&quot; password = &quot;mysqlpass&quot; minConn = 5 maxConn = 30 globalTable = &quot;global_table&quot; branchTable = &quot;branch_table&quot; lockTable = &quot;lock_table&quot; queryLimit = 100 maxWait = 5000 &#125;&#125;修改 register.conf12345678910111213registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = &quot;nacos&quot; nacos &#123; application = &quot;seata-server&quot; serverAddr = &quot;localhost:8848&quot; namespace = &quot;&quot; cluster = &quot;default&quot; username = &quot;&quot; password = &quot;&quot; &#125; ## ....启动 Nacos运行脚本：| -h | –host | 指定在注册中心注册的 IP | 不指定时获取当前的 IP，外部访问部署在云环境和容器中的 server 建议指定 || —- | ———— | ————————– | ———————————————————— || -p | –port | 指定 server 启动的端口 | 默认为 8091 || -m | –storeMode | 事务日志存储方式 | 支持file和db，默认为 file || -n | –serverNode | 用于指定seata-server节点ID | ,如 1,2,3…, 默认为 1 || -e | –seataEnv | 指定 seata-server 运行环境 | 如 dev, test 等, 服务启动时会使用 registry-dev.conf 这样的配置 |如：1$ sh ./bin/seata-server.sh -p 8091 -h 127.0.0.1使用用例来自官网文档用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：仓储服务：对给定的商品扣除仓储数量。订单服务：根据采购需求创建订单。帐户服务：从用户帐户中扣除余额。配置官网 WIKI 莫得配置说明就很难受 emmm参考：Seata极简入门Seata 配置文件说明架构图步骤在 MySQL 中分别创建三个数据库每个数据库中创建 undo_log 回滚日志表在业务相关的数据库中添加 undo_log 表，用于保存需要回滚的数据12345678910111213141516CREATE TABLE `undo_log`( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `branch_id` BIGINT(20) NOT NULL, `xid` VARCHAR(100) NOT NULL, `context` VARCHAR(128) NOT NULL, `rollback_info` LONGBLOB NOT NULL, `log_status` INT(11) NOT NULL, `log_created` DATETIME NOT NULL, `log_modified` DATETIME NOT NULL, `ext` VARCHAR(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8地址：https://github.com/seata/seata/blob/develop/script/client/at/db/mysql.sql引入依赖1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;1234567891011121314151617&lt;!-- Seata--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- seata 1.2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt;==导入Maven包时，一定要注意，seato-all的版本和本地服务的版本是否一致！！！不然即使配置OK，也可能会出现运行错误！！==exclude 排除包之后，引入与服务端版本匹配的 jar 包添加Seata 配置文件registry.conf该配置用于指定 TC 的注册中心和配置文件，默认都是 file; 如果使用其他的注册中心，要求 Seata-Server 也注册到该配置中心上12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 注册中心(要与服务端注册中心相同)registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = &quot;file&quot; nacos &#123; serverAddr = &quot;localhost&quot; namespace = &quot;public&quot; cluster = &quot;default&quot; &#125; eureka &#123; serviceUrl = &quot;http://localhost:8761/eureka&quot; application = &quot;default&quot; weight = &quot;1&quot; &#125; redis &#123; serverAddr = &quot;localhost:6379&quot; db = &quot;0&quot; &#125; zk &#123; cluster = &quot;default&quot; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; consul &#123; cluster = &quot;default&quot; serverAddr = &quot;127.0.0.1:8500&quot; &#125; etcd3 &#123; cluster = &quot;default&quot; serverAddr = &quot;http://localhost:2379&quot; &#125; sofa &#123; serverAddr = &quot;127.0.0.1:9603&quot; application = &quot;default&quot; region = &quot;DEFAULT_ZONE&quot; datacenter = &quot;DefaultDataCenter&quot; cluster = &quot;default&quot; group = &quot;SEATA_GROUP&quot; addressWaitTime = &quot;3000&quot; &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125;# 配置中心，只有为&apos;file&apos;时，file.conf才会生效，需要配置config &#123; # file、nacos 、apollo、zk、consul、etcd3 type = &quot;file&quot; nacos &#123; serverAddr = &quot;localhost&quot; namespace = &quot;public&quot; cluster = &quot;default&quot; &#125; consul &#123; serverAddr = &quot;127.0.0.1:8500&quot; &#125; apollo &#123; app.id = &quot;seata-server&quot; apollo.meta = &quot;http://192.168.1.204:8801&quot; &#125; zk &#123; serverAddr = &quot;127.0.0.1:2181&quot; session.timeout = 6000 connect.timeout = 2000 &#125; etcd3 &#123; serverAddr = &quot;http://localhost:2379&quot; &#125; file &#123; name = &quot;file.conf&quot; &#125;&#125;file.conf该配置用于指定TC的相关属性；如果使用注册中心也可以将配置添加到配置中心123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121transport &#123; # tcp udt unix-domain-socket type = &quot;TCP&quot; #NIO NATIVE server = &quot;NIO&quot; #enable heartbeat heartbeat = true #thread factory for netty thread-factory &#123; boss-thread-prefix = &quot;NettyBoss&quot; worker-thread-prefix = &quot;NettyServerNIOWorker&quot; server-executor-thread-prefix = &quot;NettyServerBizHandler&quot; share-boss-worker = false client-selector-thread-prefix = &quot;NettyClientSelector&quot; client-selector-thread-size = 1 client-worker-thread-prefix = &quot;NettyClientWorkerThread&quot; # netty boss thread size,will not be used for UDT boss-thread-size = 1 #auto default pin or 8 worker-thread-size = 8 &#125; shutdown &#123; # when destroy server, wait seconds wait = 3 &#125; serialization = &quot;seata&quot; compressor = &quot;none&quot;&#125;service &#123; #vgroup-&gt;rgroup vgroup_mapping.my_test_tx_group = &quot;default&quot; #only support single node default.grouplist = &quot;127.0.0.1:8091&quot; #degrade current not support enableDegrade = false #disable disable = false #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent max.commit.retry.timeout = &quot;-1&quot; max.rollback.retry.timeout = &quot;-1&quot;&#125;client &#123; async.commit.buffer.limit = 10000 lock &#123; retry.internal = 10 retry.times = 30 &#125; report.retry.count = 5&#125;## transaction log storestore &#123; ## store mode: file、db mode = &quot;file&quot; ## file store file &#123; dir = &quot;sessionStore&quot; # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions max-branch-session-size = 16384 # globe session size , if exceeded throws exceptions max-global-session-size = 512 # file buffer size , if exceeded allocate new buffer file-write-buffer-cache-size = 16384 # when recover batch read size session.reload.read_size = 100 # async, sync flush-disk-mode = async &#125; ## database store db &#123; ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc. datasource = &quot;dbcp&quot; ## mysql/oracle/h2/oceanbase etc. db-type = &quot;mysql&quot; url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot; user = &quot;mysql&quot; password = &quot;mysql&quot; min-conn = 1 max-conn = 3 global.table = &quot;global_table&quot; branch.table = &quot;branch_table&quot; lock-table = &quot;lock_table&quot; query-limit = 100 &#125;&#125;lock &#123; ## the lock store mode: local、remote mode = &quot;remote&quot; local &#123; ## store locks in user&apos;s database &#125; remote &#123; ## store locks in the seata&apos;s server &#125;&#125;recovery &#123; committing-retry-delay = 30 asyn-committing-retry-delay = 30 rollbacking-retry-delay = 30 timeout-retry-delay = 30&#125;transaction &#123; undo.data.validation = true undo.log.serialization = &quot;jackson&quot;&#125;## metrics settingsmetrics &#123; enabled = false registry-type = &quot;compact&quot; # multi exporters use comma divided exporter-list = &quot;prometheus&quot; exporter-prometheus-port = 9898&#125;参数配置需要注意的是 service.vgroup_mapping 这个配置，在 Spring Cloud 中默认是${spring.application.name}-fescar-service-group，可以通过指定application.properties的 spring.cloud.alibaba.seata.tx-service-group这个属性覆盖，但是必须要和 file.conf中的一致，否则会提示 no available server to connect。（jar包与服务端版本号不一致有时也会出现这个问题）注入数据源Seata 通过代理数据源的方式实现分支事务；MyBatis 和 JPA 都需要注入 io.seata.rm.datasource.DataSourceProxy, 不同的是，MyBatis 还需要额外注入 org.apache.ibatis.session.SqlSessionFactoryMybatis需要引入依赖：123456789101112131415161718&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;mysql&lt;/groupId&gt;&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&gt; &lt;/dependency&gt;&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt;&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;&gt; &lt;version&gt;1.1.10&lt;/version&gt;&gt; &lt;/dependency&gt;&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&gt; &lt;/dependency&gt;&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&gt; &lt;/dependency&gt;&gt;官网示例引入了 Druid配置文件：123456789101112131415161718192021@Configurationpublic class DataSourceProxyConfig &#123; @Bean @ConfigurationProperties(prefix = "spring.datasource") public DataSource dataSource() &#123; return new DruidDataSource(); &#125; @Bean public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123; return new DataSourceProxy(dataSource); &#125; @Bean public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceProxy); return sqlSessionFactoryBean.getObject(); &#125;&#125;这种方式由于手动创建了 SqlSessionFactory，所以 application.yml/properties 中的配置需要手动注入并设置才会生效启动类也要添加注解：1234// import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)启动必要的服务：包括 Seata-server 以及依赖的注册或配置中心使用 @GlobalTransactional 开启事务在业务的发起方的方法上使用 @GlobalTransactional 开启全局事务，Seata 会将事务的 xid 通过拦截器添加到调用其他服务的请求中，实现分布式事务参考：https://www.cnblogs.com/victorbu/p/12738556.htmlhttps://blog.funkye.icu/2020/02/19/seata-quick/参数配置2.2.0.RELEASE+ 不需要手动配置数据源代理，直接创建一个123456&gt; @Bean&gt; @ConfigurationProperties(prefix = "spring.datasource")&gt; public DataSource dataSource() &#123;&gt; return new DruidDataSource();&gt; &#125;&gt;即可，如果不是 2.2.0 及以上但 Seata 版本高于 1.1.0，可以参考：（貌似0.8以上的支持参数配置，1.1.0 使用注解代替）seata1.1.0版本新加入以下注解,用于开启数据源自动代理功能 @EnableAutoDataSourceProxy对于使用seata-spring-boot-starter的方式，默认已开启数据源自动代理,如需关闭，请配置seata.enableAutoDataSourceProxy=false，该项配置默认为true。 如需切换代理实现方式，请通过seata.useJdkProxy=false进行配置,默认为false，采用CGLIB作为数据源自动代理的实现方式。对于使用seata-all的方式，请使用@EnableAutoDataSourceProxy来显式开启数据源自动代理功能。如有需要，可通过该注解的useJdkProxy属性进行代理实现方式 的切换。默认为false,采用CGLIB作为数据源自动代理的实现方式。]]></content>
      <tags>
        <tag>springcloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码分析之 —— ArrayList]]></title>
    <url>%2Fposts%2Fe7896c93%2F</url>
    <content type="text"><![CDATA[ArrayList描述List接口的可调整大小的数组实现。实现所有可选的 List 操作，并允许包括 null 的所有元素。除了实现 List 接口之外，此类还提供一些方法来操纵内部用于存储列表的数组的大小。（此类与Vector大致等效 ，但它是不同步的。）size, isEmpty, get, set, iterator, 和 listIterator 在 O(1) 时间内运行。add操作运行摊销恒定时间，添加N元素需要O(n)的时间。其他操作均以线性时间运行（大致而言）。每个ArrayList实例都有一个容量。容量是用于在列表中存储元素的数组的大小。它总是至少与列表大小一样大。随着元素添加到ArrayList中，其容量会自动增长。除了添加元素具有固定的摊销时间成本外，没有指定增长策略的详细信息。应用程序可以使用ensureCapacity 操作在添加大量元素之前增加ArrayList实例的容量。这可以减少增量重新分配的数量。请注意，ArrayList是线程不安全的。 如果多个线程同时访问ArrayList实例，并且至少有一个线程在做是修改操作，则 必须在外部进行同步。（修改是添加或删除一个或多个元素，或显式调整后备数组的大小的任何操作；仅设置元素的值不是修改。）通常通过在自然封装了对象的某个对象上进行同步来实现。清单。如果不存在这样的对象，则应使用Collections.synchronizedList 方法“包装”列表 。最好在创建时完成此操作，以防止意外的不同步访问列表：1List list = Collections.synchronizedList（new ArrayList（...））;此类iterator和 listIterator方法返回的迭代器是快速失败的：如果在创建迭代器之后的任何时间对列表进行结构修改，则除了通过迭代器自己的remove或 add方法外，迭代器都将抛出 ConcurrentModificationException。因此，面对并发修改，迭代器将快速而干净地失败，而不是在未来的不确定时间内冒任意，不确定的行为的风险。注意，迭代器的快速失败行为无法得到保证，因为通常来说，在存在不同步的并发修改的情况下，不可能做出任何严格的保证。快速失败的迭代器会ConcurrentModificationException尽力而为。因此，编写依赖于此异常的程序的正确性是错误的： 迭代器的快速失败行为应仅用于检测错误。源码细节变量1234567891011121314151617181920212223242526/** 序列化id */private static final long serialVersionUID = 8683452581122892189L;/** * 默认初始容量：10 */private static final int DEFAULT_CAPACITY = 10;/** * 指定容量为０或Collection为０的时候 &lt;code&gt;elementData&lt;/code&gt; 的值 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * 与 EMPTY_ELEMENTDATA的区别在于默认不指定容量大小的时候 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * ArrayList存储的数据，不可序列化，ArrayList的容量就是这个数组buffer的大小 */transient Object[] elementData; /** * ArrayList的实际大小 */private int size;构造器12345678910111213141516171819202122232425262728293031323334353637/** * 指定容量 * - 大于0：创建对应大小的数组 * - 等于0：使用空数组 */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity); &#125;&#125;/** * 使用默认的空数组 */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * 从集合中获取 */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125;方法初始容量为 10若数组长度小于要扩容的最小值：默认扩容 1/2如果还不够就扩容到 最小扩容值若扩容后的大小超出设置的数组最大容量（Integer.MAX_VALUE - 8）如果 要扩容的最小值 溢出，抛出异常如果 要扩容的最小值 小于最大容量值，就使用最大容量值作为扩容后的大小如果大于，使用 Interger.MAX_VALUE 作为扩容后的大小trimToSize1234567891011/** * 修建当前容量为实际大小 */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125;get123456789/** * 获取下标所在的元素 */public E get(int index) &#123; // 范围检查，index无效会抛出异常 rangeCheck(index); return elementData(index);&#125;set123456789101112/** * 设置 */public E set(int index, E element) &#123; // 范围检查+1 rangeCheck(index); // 获取旧值 E oldValue = elementData(index); // 设置新值，返回旧值 elementData[index] = element; return oldValue;&#125;add12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 添加元素 */public boolean add(E e) &#123; // 确认容量，进行扩容策略处理 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; // calculateCapacity 计算最小容量＝minCapacity，若 elementData 为默认的空数组，返回最小容量和初始大小的最大值 ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;// 如果最小容量大于当前数组的大小，扩容private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * 数组分配的最大值 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * 扩容策略 * @param minCapacity 扩容的最小容量 */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新容量为原来的 3/2，扩容 1/2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) // 如果还不够，设置为最小容量的值 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果新容量超出规定的最大值（Integer.MAX_VALUE - 8） // 若最小容量也大于规定的最大值，就扩容到 Integer.MAX_VALUE // 否则就扩容到规定的最大值 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; // 溢出，超出可分配的范围 if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;add(int index, E element)123456789101112public void add(int index, E element) &#123; // 检查下标是否合理 rangeCheckForAdd(index); // 容量操作 ensureCapacityInternal(size + 1); // Increments modCount!! // index - size 区域后移 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 设置值 elementData[index] = element; size++;&#125;remove1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public E remove(int index) &#123; // 范围检查 rangeCheck(index); modCount++; // 获取旧值 E oldValue = elementData(index); // 计算需要移动的元素数量 int numMoved = size - index - 1; if (numMoved &gt; 0) // 前移 System.arraycopy(elementData, index + 1, elementData, index, numMoved); // 删除元素 // 容量-1 elementData[--size] = null; // clear to let GC do its work // 返回旧值 return oldValue;&#125;/** * 移除遇到的第一个元素 返回是否移除成功 */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/* * 和普通的remove区别只在于没有进行范围检查和旧值获取 */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index + 1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;关于 modCount上面的源码中我们可以看到 modCount++ 出现了多次。源码的doc文档是这样描述的：modCount 是结构修改的次数（结构修改参考描述中的说明），这个字段用于 iterator、listIterator 方法所返回的 iterator 实现中：在 next、remove、previous、set、add 操作中，如果值得改变不是所预期的，意味着多个线程同时修改了 List，这样就会抛出异常：ConcurrentModificationException 。这也是所说的快速失败机制。]]></content>
      <tags>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2Fposts%2F69e7b86f%2F</url>
    <content type="text"><![CDATA[单例模式定义一个类只能构建一个对象的设计模式。实现懒汉模式1234567891011121314151617public class LazySingleton &#123; /** * 私有构造函数 */ private LazySingleton() &#123;&#125; private static LazySingleton instance = null; public static LazySingleton getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; return instance; &#125; &#125;只能通过一个私有的构造方法去创建对象，而创建对象的前提是此对象不存在。一开始 instance 为空，当需要时才会创建对象，称之为：懒汉模式那么如果一开始就创建 instance ，不在进行判空操作，我们称之为：饿汉模式饿汉模式1234567891011public class HungrySingleton &#123; private HungrySingleton() &#123;&#125; private static HungrySingleton singleton = new HungrySingleton(); public static HungrySingleton getInstance() &#123; return singleton; &#125; &#125;懒汉模式升级版 ——双重加锁上面的懒汉模式存在线程安全的问题：当 instance == null 的情况下，假设目前有两个线程A、B。两个线程同时调用 getInstance 方法，由于 instance == null 满足，两个线程同时通过了条件判断，执行 new 创建对象。显然这样就会使得本来只想有一个实例的对象出现了多次。基于此，我们可以更新代码为：123456789101112131415161718192021public class LazySingletonCheckTwice &#123; private LazySingletonCheckTwice() &#123;&#125; private static LazySingletonCheckTwice instance = null; public static LazySingletonCheckTwice getInstance() &#123; // 第一重判断 if (instance == null) &#123; // 使用锁机制 synchronized (LazySingletonCheckTwice.class) &#123; // 第二重判断 if (instance == null) &#123; instance = new LazySingletonCheckTwice(); &#125; &#125; &#125; return instance; &#125; &#125;使用同步锁的原因：防止 new 多次，在 new 操作前加上同步锁，锁住整个类第二次判断的原因：两个线程会存在同时通过第一重检测的情况，当第一个线程创建对象后，若不进行再一次判空检测，还会再创建一个对象。不在第一次检测加锁：使用同步锁比两次 if 更加消耗性能，由于单例的缘故，绝大多数情况下访问方法时已经有了单例对象，再第一重加上同步锁反而会带来性能消耗，远不如第一判断获取对象要快。懒汉模式 ——线程安全终极版上述的操作过程中，我们实现了相对安全的单例模式的代码。这是并没有做到绝对的线程安全。真正的原因涉及到 JVM 的 指令重排：在计算机执行指令的顺序在经过程序编译器编译之后形成的指令序列，一般而言，这个指令序列是会输出确定的结果；以确保每一次的执行都有确定的结果。但是，一般情况下，CPU和编译器为了提升程序执行的效率，会按照一定的规则允许进行指令优化，在某些情况下，这种优化会带来一些执行的逻辑问题，主要的原因是代码逻辑之间是存在一定的先后顺序，在并发执行情况下，会发生二义性，即按照不同的执行逻辑，会得到不同的结果信息。————————————————版权声明：本文为CSDN博主「bladestone」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/blueheart20/article/details/52117761比如，创建对象：instance = new LazySingletonCheckTwice() 会被编译为：memory = allocate() 分配内存空间ctorInstance(memory) 初始化对象instance = memory 设置 instance 指向分配的内存地址然而这些指令可能会经过 JVM 和 CPU 的优化后，重排为：1、3、2 这样的顺序。我们还是假设有两个线程A、B，当 A 线程创建对象时执行了 1、3，instance 已经不在指向 null，此刻若线程 B 获得了CPU，将不会通过第一重检测，直接返回一个未完全初始化的对象。为了防止指令重排所带来的问题，我们可以使用 volatile 关键字：如何防止指令重排volatile 关键字可以保证变量的可见性，因为对 volatile 的操作都在Main Memory中，而Main Memory 是被所有线程所共享的，这里的代价就是牺牲了性能，无法利用寄存器或Cache，因为它们都不是全局的，无法保证可见性，可能产生脏读。volatile 还有一个作用就是局部阻止重排序的发生，对volatile变量的操作指令都不会被重排序，因为如果重排序，又可能产生可见性问题。在保证可见性方面，锁（包括显式锁、对象锁）以及对原子变量的读写都可以确保变量的可见性。但是实现方式略有不同，例如同步锁保证得到锁时从内存里重新读入数据刷新缓存，释放锁时将数据写回内存以保数据可见，而volatile变量干脆都是读写内存。可见性这里提到的可见性是指前一条程序指令的执行结果，可以被后一条指令读到或者看到，称之为可见性。反之为不可见性。这里主要描述的是在多线程环境下，指令语句之间对于结果信息的读取即时性。————————————————版权声明：本文为CSDN博主「bladestone」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/blueheart20/article/details/52117761静态内部类实现单例模式12345678910111213public class StaticInnerClassSingleton &#123; private StaticInnerClassSingleton() &#123;&#125; private static class LazyHolder &#123; private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton(); &#125; public static StaticInnerClassSingleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125;外部无法访问静态内部类，只有通过 getInstance() 来获取实例，再调用方法的时候，静态内部类才会加载（利用 classloader 的加载机制实现懒加载），同时这种方式也保证了线程安全。上面的Bug上面的方法说到底还是使用私有构造器去创建对象，那么 Java 中反射可以打破上面单例的约束，只要设置构造器为可访问，便可以任意调用构造器去创建足够多的对象。那么如何防止这个逆天Bug呢：使用枚举JVM 会阻止反射获取枚举类的私有构造方法在构造方法中可以这样操作：当已有实例时，抛出异常；没有则创建对象。123456789private StaticInnerClassSingleton() &#123; synchronized (StaticInnerClassSingleton.class) &#123; if (first) &#123; first = false; &#125; else &#123; throw new RuntimeException("单例对象已存在"); &#125; &#125;&#125;这里还是用了同步锁，防止两个操作反射的线程在通过 if 判断后，同时通过构造器去创建对象。这样，在标记变量没有 setter 方法且为私有基本类型的变量的情况下，就算使用反射也无法通过强行更改标记变量的值来创建第二个对象。]]></content>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-代理模式]]></title>
    <url>%2Fposts%2Fe3d6aa41%2F</url>
    <content type="text"><![CDATA[代理模式定义代理模式是对象的结构模式。代理模式给某一个对象提供代理对象，并有代理对象控制对源对象的应用。好处我们在写一个功能函数时，经常需要在其中写入与功能不是直接相关但很有必要的代 码，如日志记录，信息发送，安全和事务支持等，这些枝节性代码虽然是必要的，但它会带来以下麻烦：枝节性代码游离在功能性代码之外，它不是函数的目的，这是对OO是一种破坏枝节性代码会造成功能性代码对其它类的依赖，加深类之间的耦合，可重用性降低从法理上说，枝节性代码应该 监视着功能性代码，然后采取行动，而不是功能性代码 通知枝节性代码采取行动，这好比吟游诗人应该是主动记录骑士的功绩而不是骑士主动要求诗人记录自己的功绩结构角色抽象对象角色：声明了目标对象和代理对象的共同接口，这样在任何可以使用目标对象的地方都可以使用代理对象目标对象角色：定义了代理对象所代表的目标对象代理对象角色：代理对象内部包含目标对象的引用，从而可以在任何时候操作目标对象。代理对象提供与目标对象相同的接口，可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作。而非单纯的把调用传递给目标对象。静态代理静态代理在使用时，要定义好接口或者父类，被代理对象和真实对象继承相同的接口或父类。静态代理中，一个目标对象对应一个代理对象，彼此的关系和类型都需要在编译前约定好。缺点：存在代码重复、不利于代码的后续维护、灵活性不高Movie12345678public interface Movie &#123; /** * 播放影片 */ void play();&#125;TwelveMonkeysMovie12345678public class TwelveMonkeysMovie implements Movie &#123; @Override public void play() &#123; System.out.println("playing... [12 Monkeys]"); &#125;&#125;Cinema123456789101112131415161718192021222324public class Cinema implements Movie &#123; private Movie realMovie; public Cinema(Movie realMovie) &#123; this.realMovie = realMovie; &#125; @Override public void play() &#123; doSome(true); realMovie.play(); doSome(false); &#125; private void doSome(boolean isStart) &#123; if (isStart) &#123; System.out.println("电影马上开始，请各位就坐，为了电影的播放效果，请将手机关机或调至静音。"); &#125; else &#123; System.out.println("请大家有序立场，携带好自己的随身物品，照顾好自己的小孩。"); &#125; &#125;&#125;Main1234567public static void main(String[] args) &#123; TwelveMonkeysMovie monkeysMovie = new TwelveMonkeysMovie(); Movie movie = new Cinema(monkeysMovie); movie.play();&#125;动态代理（JDK代理）特点运行期间，通过 反射机制 创建实现了一组给定接口的类在运行时生成的 class 要实现给定的一组 interface，因此 class 的实例可以当做 interface 的任何一个来使用。同时要提供一个 handler，接管实际的工作。接口中声明的方法被转移到调用处理器的 InvocationHandler.invoke 集中处理，在接口方法数量多的回收可以灵活处理，使类职责更加单一，复用性更强。使用JDK反射动态生成类，不需要第三方库就可以代理，使用条件：必须实现InvocationHandler接口；使用Proxy.newProxyInstance产生代理对象；被代理的对象必须要实现接口；API代理类所在的包：java.lang.reflect.Proxy使用其静态方法：static Object newProxyInstance(ClassLoader loader, Class [] interfaces, InvocationHandler handler) 实现代理。ClassLoader loader: 指定当前目标对象使用类加载器,用null表示默认类加载器Class [] interfaces: 需要实现的接口数组InvocationHandler handler: 调用处理器,执行目标对象的方法时,会触发调用处理器的方法,从而把当前执行目标对象的方法作为参数传入java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。123// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象// 第三个方法是调用参数。Object invoke(Object proxy, Method method, Object[] args);代码DemoInterface（目标类实现的接口）12345678public interface DemoInterface &#123; /** * 输出信息 */ void echo();&#125;ProxyFactory（代理类）123456789101112131415161718192021222324252627282930313233public class ProxyFactory &#123; /** * 目标对象 */ private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; /** * 为目标对象生成代理对象 */ public Object getProxyInstance() &#123; return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), // InvocationHandler.invoke(proxy, method, args) 方法 (proxy, method, args) -&gt; &#123; System.out.println("proxy: " + proxy.getClass()); System.out.println("method: " + method.getDeclaringClass() + " -&gt; " + method.getName()); System.out.println("args: " + Arrays.toString(args)); System.out.println("开始事务2"); Object returnValue = method.invoke(target, args); System.out.println("提交事务2"); return returnValue; &#125; ); &#125;&#125;Main（测试）123456public static void main(String[] args) &#123; DemoInterface demoInterface = new DemoInterfaceImpl("demo"); DemoInterface demoInterfaceProxy = (DemoInterface) new ProxyFactory(demoInterface).getProxyInstance(); demoInterfaceProxy.echo();&#125;Cglib 代理（子类代理）静态代理和Jdk动态代理都要求目标对象实现一个接口或多个接口（静态代理代理对象也需要实现接口）。当目标对象未实现任何接口，可以使用构建目标对象之类的方法实现动态代理，即 Cglib。底层实现：使用字节码处理框架 ASM 转换字节码并生成新的子类。API自定义 MethodInterceptor 实现类，实现方法：1234567 /** * sub：cglib生成的代理对象 * method：被代理对象方法 * objects：方法入参 * methodProxy: 代理方法 */ Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy)生成 CGLIB 代理对象1234567891011121314/** * 为目标对象创建代理对象 */public Object getProxyInstance() &#123; // 增强器 Enhancer en = new Enhancer(); // 设置父类 en.setSuperclass(target.getClass()); // 设置回调对象, 即 MethodInterceptor // 方法上是 Callback&lt;T&gt; 即可 en.setCallback(this); // 创建类 return en.create();&#125;调用目标代理对象方法CodeProxyFactory（代理工厂）12345678910111213141516171819202122232425262728293031323334353637383940public class ProxyFactory implements MethodInterceptor &#123; /** * 目标对象 */ private Object target; public ProxyFactory(Object target) &#123; this.target = target; System.out.println("target: " + target); &#125; /** * 为目标对象创建代理对象 */ public Object getProxyInstance() &#123; // 增强器 Enhancer en = new Enhancer(); // 设置父类 en.setSuperclass(target.getClass()); // 设置回调对象 en.setCallback(this); // 创建类 return en.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("obj: " + obj.getClass()); System.out.println("method: " + method.getDeclaringClass() + " -&gt; " + method.getName()); System.out.println("args: " + Arrays.toString(args)); System.out.println("methodProxy: " + proxy.getClass()); System.out.println("\nbegin"); Object returnValue = method.invoke(target, args); System.out.println("end"); return returnValue; &#125;&#125;Main（测试）12345public static void main(String[] args) &#123; ProxyFactory proxyFactory = new ProxyFactory(new Demo()); Demo demo = (Demo) proxyFactory.getProxyInstance(); demo.save();&#125;]]></content>
      <tags>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown测试]]></title>
    <url>%2Fposts%2F45babedb%2F</url>
    <content type="text"><![CDATA[欢迎使用 Markdown在线编辑器 MdEditorMarkdown是一种轻量级的「标记语言」Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面，Markdown文件的后缀名便是“.md”MdEditor是一个在线编辑Markdown文档的编辑器MdEditor扩展了Markdown的功能（如表格、脚注、内嵌HTML等等），以使让Markdown转换成更多的格式，和更丰富的展示效果，这些功能原初的Markdown尚不具备。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc，Pandao；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。MdEditor源于Pandao的JavaScript开源项目，开源地址Editor.md，并在MIT开源协议的许可范围内进行了优化，以适应广大用户群体的需求。向优秀的markdown开源编辑器原作者Pandao致敬。MdEditor的功能列表演示标题H1标题H2标题H3标题H4标题H5标题H5字符效果和横线等删除线 删除线（开启识别HTML标签时）斜体字 斜体字粗体 粗体粗斜体 粗斜体上标：X2，下标：O2缩写(同HTML的abbr标签)即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启The HTML specification is maintained by the W3C.引用 Blockquotes引用文本 Blockquotes引用的行内混合 Blockquotes引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。锚点与链接 Links普通链接普通链接带标题直接链接：https://www.mdeditor.com[锚点链接][anchor-id][anchor-id]: https://www.mdeditor.com/mailto:test.test@gmail.comGFM a-tail link @pandao邮箱地址自动链接 test.test@gmail.com www@vip.qq.com@pandao多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked缩进风格即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。&lt;?php echo &quot;Hello world!&quot;; ?&gt; 预格式化文本：| First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码123function test() &#123; console.log("Hello world!");&#125;HTML 代码 HTML codes1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest="utf-8" /&gt; &lt;meta name="keywords" content="Editor.md, Markdown, Editor" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type="text/css"&gt; body&#123;font-size:14px;color:#444;font-family: "Microsoft Yahei", Tahoma, "Hiragino Sans GB", Arial;background:#fff;&#125; ul&#123;list-style: none;&#125; img&#123;border:none;vertical-align: middle;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="text-xxl"&gt;Hello world!&lt;/h1&gt; &lt;p class="text-green"&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;图片 Images图片加链接 (Image + Link)：Follow your heart.列表 Lists无序列表（减号）Unordered Lists (-)列表一列表二列表三无序列表（星号）Unordered Lists (*)列表一列表二列表三无序列表（加号和嵌套）Unordered Lists (+)列表一列表二列表二-1列表二-2列表二-3列表三列表一列表二列表三有序列表 Ordered Lists (-)第一行第二行第三行GFM task listGFM task list 1GFM task list 2GFM task list 3GFM task list 3-1GFM task list 3-2GFM task list 3-3GFM task list 4GFM task list 4-1GFM task list 4-2绘制表格 Tables项目价格数量计算机$16005手机$1212管线$1234First HeaderSecond HeaderContent CellContent CellContent CellContent CellFirst HeaderSecond HeaderContent CellContent CellContent CellContent CellFunction nameDescriptionhelp()Display the help window.destroy()Destroy your computer!Left-AlignedCenter AlignedRight Alignedcol 3 issome wordy text$1600col 2 iscentered$12zebra stripesare neat$1ItemValueComputer$1600Phone$12Pipe$1特殊符号 HTML Entities Codes&copy; &amp; &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot;X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo;18&ordm;C &quot; &apos;[========]Emoji表情 :smiley:Blockquotes :star:GFM task lists &amp; Emoji &amp; fontAwesome icon emoji &amp; editormd logo emoji :editormd-logo-5x::smiley: @mentions, :smiley: #refs, links, formatting, and tags supported :editormd-logo:;list syntax required (any unordered or ordered list supported) :editormd-logo-3x:;[ ] :smiley: this is a complete item :smiley:;[]this is an incomplete item test link :fa-star: @pandao;[ ]this is an incomplete item :fa-star: :fa-gear:;:smiley: this is an incomplete item test link :fa-star: :fa-gear:;:smiley: this is :fa-star: :fa-gear: an incomplete item test link;反斜杠 Escape*literal asterisks*[========]科学公式 TeX(KaTeX)$$E=mc^2$$行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。$$x &gt; y$$$$(\sqrt{3x-1}+(1+x)^2)$$$$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$多行公式：12345\displaystyle\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2\leq\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right)123456789\displaystyle \frac&#123;1&#125;&#123; \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123; \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123; 1+\frac&#123;e^&#123;-6\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\cdots&#125; &#125; &#125; &#125;123f(x) = \int_&#123;-\infty&#125;^\infty \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125; \,d\xi分页符 Page breakPrint Test: Ctrl + P[========]绘制流程图 Flowchart12345678st=&gt;start: 用户登陆op=&gt;operation: 登陆操作cond=&gt;condition: 登陆成功 Yes or No?e=&gt;end: 进入后台st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op[========]绘制序列图 Sequence Diagram1234Andrew-&gt;China: Says HelloNote right of China: China thinks\nabout itChina--&gt;Andrew: How are you?Andrew-&gt;&gt;China: I am good thanks!End]]></content>
  </entry>
  <entry>
    <title><![CDATA[MyBatis的解析和运行原理]]></title>
    <url>%2Fposts%2Fd90473f8%2F</url>
    <content type="text"><![CDATA[构建 SqlSessionFactory 过程重要类的说明SqlSessionFactory描述：MyBatis 核心类之一作用：【最重要】提供创建 MyBatis 的核心接口 SqlSession创建：使用 Builder 模式创建，实际中可以通过 SqlSessionFactoryBuilder 去构建通过 org.apache.ibatis.builder.xml.XMLConfigBuilder 解析 XML 配置文件，将读取的参数存入 org.apache.ibatis.session.Configuration 类对象中Configuration 采用单例模式，几乎所有的配置内容都存放在这个单例对象中使用 Configuration 对象创建 SqlSessionFactory，SqlSessionFactory 是一个接口，MyBatis 提供了默认的实现类 org.apache.ibatis.session.defaults.DefaultSqlSessionFactory需要提供配置文件和相关参数Configuration描述：存储了 MyBatis 的几乎所有的配置信息作用：在构建 SqlSessionFactory 的过程中起重要作用：读入配置文件，包括基础的 XML 和映射器 XML（或注解）初始化基础配置提供单例，为创建 SessionFactory 服务提供配置的参数执行一些重要对象的初始化方法在读取并解析配置文件后，将其保存在 Configuration 对象中后，会做一些初始化操作：properties 全局参数typeAliases 别名Plugins 插件objectFactory 对象工厂objectWrapperFactory 对象包装工厂reflectionFactory 反射工厂settings 环境参数environments 数据库环境databaseIdProvider 数据库标识typeHandlers 类型转换器Mappers 映射器Mappers 映射器 是最重要的内容，在插件中需要频繁的访问，也是 MyBatis 底层运行原理的基础※ 构建映射器的内部组成当 XMLConfigBuilder 解析 XML 的时候，会将每一个 SQL 与其配置的内容保存起来。在 MyBatis 中一条 SQL 和相关的配置信息由三个部分组成：MapperStatement、SqlSource、BoundSqlMapperStatement保存一个映射器节点（select | insert | …）的内容。是一个类，包括了很多配置的 SQL、SQL 的 id、缓存信息、resultMap、parameterType、resultType、resultMap 等重要配置信息。有一个重要的属性：sqlSource（MyBatis 可以通过它来获取 SQL 配置的所有信息）SqlSource它是一个接口，是 MapperStatement的一个属性,其实现类有：DynamicSqlSource、ProviderSqlSource、RawSqlSource、StaticSqlSource。作用：根据上下文和参数解析生成需要的 SQL，接口只定义了一个接口方法 —— getBoundSql(parameterObject)，用于提供 BoundSql 对象。BoundSql是一个结果对象，是建立 SQL 和参数的地方，有三个常用的属性：sql、parameterObject、parameterMappings最终的参数和 SQL 都反映在 BoundSql 类对象上，在插件中往往拿到它就可以获得当前运行的 SQL 和参数，从而修改运行过程以满足需求。下面分别介绍 BoundSql 提供的三个主要的属性：sql、parameterObject、parameterMappingsparameterObject为参数本身，可以传递简单对象、POJO、或者 Map、@Param 注解的参数关于它的一些规则：传递简单对象时： 会将基本类型参数装箱为对应的对象来传递传递 POJO 或 Map： parameterObject 就是对应的对象传递多个对象： 如果没有 @Param 注解，会把 parameterObject 变为一个 Map&lt;String, Object&gt; 对象，键值关系按顺序规划，其对应的键为：1, 2, 3 … 或是 param1, param2, param3 …使用 @Param 注解： 类似与 [传递多个对象] 的规则，只是把数字的键值换成了注解的键值parameterMappings是一个 List，每一个元素都是 ParameterMapping 对象，描述了参数的属性：属性名、表达式、javaType、jdbcType等重要信息。通过它就可以实现参数和 SQL 的结合，使得 PreparedStatement 可以通过它找到 parameterObject 对象的属性设置参数，使得程序正常运行。sql书写在映射器中被 SqlSource 解析后的 SQL，大部分情况下不需要修改它，在使用插件的时候可以根据情况来进行改写。SqlSession 的执行过程SqlSession 是 MyBatis 底层运行的核心，是一个接口，给出了查询、插入、更新、删除的方法（MyBatis 目前建议使用 Mapper）。映射器的动态代理SqlSession 默认的实现类 DefaultSqlSession 中的 getMapper 方法：可以看到，方法调用了 configuration 的 getMapper 方法。我们可以继续追踪到对应的方法：这里使用了映射器的注册器 mapperRegistry 来获取对应的接口对象。knowMappers 是一个 HashMap，存储了注册的 mapper 接口完全限定名和对应的代理工厂。如果没有注册就会抛出异常，如果有，就会启用 MapperProxyFactory 工厂来生成一个代理实例。我们深入 MapperProxy 源码中会发现：类中 invoke 方法的逻辑为：如果 Mapper 是一个 JDK 动态代理对象，就会运行到 invoke 方法里面。否则，就会通过 cachedMapperMethod 方法生成 MapperMethod 对象，最后执行 execute 方法。深入 execute 方法中，会发现代码非常复杂，调用了很多其他的方法，从中我们可以看到一些细节，那就是最终都是通过 SqlSession 对象来运行 SQL的。MyBatis 根据 XML 中的全限定名和 SQL id 指向的方法，将其和代理对象绑定起来，通过动态代理，让接口运行起来，最后使用 SqlSession 接口的方法使得它可以执行对应的 SQL。SqlSession 下的四大对象映射器就是一个动态代理对进入到了 MapperMethod 的 execute 方法，经过简单的判断进入了 SqlSession 的 delete、update、insert、select 等方法，而这些方法的如何执行就是正确编写插件的根本。SqlSession 的执行过程是通过 Executor、StatementHandler、ParameterHandler 和 ResultSetHandler 来完成数据库操作和结果返回的。Executor执行器，它来调度 StatementHandler、ParameterHandler 和 ResultSetHandler 等来执行对应的 SQL，其中 c 是最重要的。StatementHandler使用数据库的 Statement(PreparedStatement) 执行操作，是这四个对象的核心，很多重要的插件都是通过拦截它来实现的。ParameterHandler处理 SQL 参数ResultSetHandler对数据集（ResultSet）进行封装返回处理的，比较复杂，我们也不太常用它。Executor —— 执行器SqlSession 是一个门面，真正干活的是执行器，它是真正执行 Java 和数据库交互的对象，非常重要。MyBatis 有三种执行器：SIMPLE —— 简易执行器（默认的执行器）REUSE —— 执行重用预处理语句的执行器BATCH —— 执行器重用语句、批量更新，批量专用的执行器Executor 是在 Configuration 中创建的：会根据配置的类型来创建对应的 Executor ，在创建对象之后，会执行 executor = (Executor) interceptorChain.pluginAll(executor); 这样一句代码来配置插件，这也正是插件的原理。在 SqlSession 中，执行数据库的操作为：我们会发现实际上执行的正是 executor 的 query 方法，以 SimpleExecutor 为例，它的 query 方法中调用了 doQuery 方法，在这个方法里，才轮到 StatementHandler 来执行。MyBatis 先根据 Configuration 来构建 StatementHandler，然后使用 prepareStatement 方法，对 SQL 编译和参数进行初始化。先调用 prepare() 进行预编译和基础的设置，之后使用 StatemantHandler 的 parameterize() 来设置参数，在最后执行 StatemantHandler 的 query() 方法。我们将焦点移至 StatementHandler 对象上。SatementHandler —— 数据库会话在 Configuration 类中创建 StatementHandler 的方法为：创建的真实对象为 RoutingStatementHandler，它实现了接口 StatementHandler。而 RoutingStatementHandler 也是通过适配模式来找到对应的 StatementHandler 来执行的：从代码中可以看到，它也分三种：SimpleStatementHandler、PreparedStatementHandler、CallableStatementHandler，分别对应 JDBC 的 Statement、PreparedStatement（预处理编译）、CallableStatement（存储过程处理）。根据上述的代码追溯过程，我们可以看到一条查询 SQL 的执行过程： Executor 先调用 StatementHandler 的 prepare() 方法预编译 SQL，并设置一些基本运行的参数。之后调用 parameterize() 方法启用 ParameterHandler 设置参数，完成预编译，执行查询，update() 也是同样的流程，如果是查询，MyBatis 会使用 ResultSetHandler 封装结果返回给调用者。ParameterHandler —— 参数处理器参数处理器的接口非常简单，接口定义为：getParameterObject() 返回参数的对象setParameters() 设置预编译 SQL 语句的参数ResultSetHandler —— 结果处理器接口定义为：handleOutputParameters() 方法是处理存储过程输出参数的handleResultSets() 方法则用来包装结果集。]]></content>
      <categories>
        <category>JavaEE 互联网轻量级框架整合开发</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之Web开发]]></title>
    <url>%2Fposts%2Fd16715c9%2F</url>
    <content type="text"><![CDATA[使用 SpringBoot：创建 SpringBoot 应用，选中需要的模块SpringBoot 默认将这些场景自动配置好，只需要在配置文件中指定少量配置自己编写业务逻辑代码SpringBoot 对静态资源的映射规则1234// org/springframework/boot/autoconfigure/web/ResourceProperties.java@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties &#123; // 可以设置与静态资源有关的设置，例如缓冲时间等1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler("/webjars/**") .addResourceLocations("classpath:/META-INF/resources/webjars/") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125;// 配置首页@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext) &#123; return new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125;// 配置喜欢的图标@Configuration@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)public static class FaviconConfiguration implements ResourceLoaderAware &#123; private final ResourceProperties resourceProperties; private ResourceLoader resourceLoader; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); // 在静态文件夹中寻找 mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler.setLocations(resolveFaviconLocations()); return requestHandler; &#125; private List&lt;Resource&gt; resolveFaviconLocations() &#123; String[] staticLocations = getResourceLocations(this.resourceProperties.getStaticLocations()); List&lt;Resource&gt; locations = new ArrayList&lt;&gt;(staticLocations.length + 1); Arrays.stream(staticLocations).map(this.resourceLoader::getResource).forEach(locations::add); locations.add(new ClassPathResource("/")); return Collections.unmodifiableList(locations); &#125;所有 /webjars/**，都去 classpath:/META-INF/resources/webjars/ 找资源；webjars：以 jar 包的方式引入静态资源；在 webjars 这个网站上可以使用 maven 导入常用 js 库的 webjar12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;“/**” 访问当前项目的任何资源，对应classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public//：当前项目根路径12345678910public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; "classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/" &#125;; /** * Locations of static resources. Defaults to classpath:[/META-INF/resources/, * /resources/, /static/, /public/]. */ private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;欢迎页面的映射页面图标映射（可能需要清除浏览器缓存 - Chrome 插件或者 Shift+F5）需要放在映射路径的根目录下才可以。By default, resources are mapped on /**, but you can tune that with the spring.mvc.static-path-pattern property. For instance, relocating all resources to /resources/** can be achieved as follows:1spring.mvc.static-path-pattern=/resources/**You can also customize the static resource locations by using the spring.resources.static-locations property (replacing the default values with a list of directory locations). The root Servlet context path, &quot;/&quot;, is automatically added as a location as well.In addition to the “standard” static resource locations mentioned earlier, a special case is made for Webjars content. Any resources with a path in/webjars/** are served from jar files if they are packaged in the Webjars format.Do not use the src/main/webapp directory if your application is packaged as a jar. Although this directory is a common standard, it works only with war packaging, and it is silently ignored by most build tools if you generate a jar.模板引擎Jsp、Thymeleaf、Velocity、Freemarker …SpringBoot 如果以 jar 的形式打包，而且由于 SpringBoot 使用的是内嵌的 Tomcat ，所以 SpringBoot 推荐使用 Thymeleaf.引入Thymeleafpom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;Thymeleaf 语法自动配置的默认规则：12345678@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html";只要把 html 放在 classpath:/templates/ 后，Thymeleaf 就会自动渲染。使用：导入 thymeleaf 名称空间：1&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt;使用语法123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;SUCCESS&lt;/h1&gt; &lt;!-- 将 div 的内容设置为... --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎数据&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;语法规则th:text 改变当前元素里面的文本内容th: 任意 html 属性，来替换原生属性的值对应的行内写法：th:text =&gt; [[]]th:utext =&gt; [()]表达式Simple expressions:（表达式语法）Variable Expressions: ${...}获取对象的属性，调用方法使用内置的基本对象#ctx : the context object.#vars: the context variables.#locale : the context locale.#request : (only in Web Contexts) the HttpServletRequest object.#response : (only in Web Contexts) the HttpServletResponse object.#session : (only in Web Contexts) the HttpSession object.#servletContext : (only in Web Contexts) the ServletContext object.使用内置的工具对象#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).Selection Variable Expressions:*{...}（选择表达式）和#{} 功能相同，补充使用：配置 th:object 使用，可以直接引用 th:object 的属性Message Expressions: #{...}获取国际化内容Link URL Expressions: @{...}定义 url，里面可以使用变量等值Fragment Expressions: ~{...}片段引用表达式Literals（字面量）Text literals: ‘one text’ , ‘Another one!’ ,…Number literals: 0 , 34 , 3.0 , 12.3 ,…Boolean literals: true , falseNull literal: nullLiteral tokens: one , sometext , main ,…Text operations:（文本操作）String concatenation: +Literal substitutions: |The name is ${name}|Arithmetic operations:（数学运算）Binary operators: + , - , * , / , %Minus sign (unary operator): -Boolean operations:（布尔运算）Binary operators: and , orBoolean negation (unary operator): ! , notComparisons and equality:（比较运算）Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )Equality operators: == , != ( eq , ne )Conditional operators:（条件运算）If-then: (if) ? (then)If-then-else: (if) ? (then) : (else)Default: (value) ?: (defaultvalue)Special tokens:Page 17 of 104No-Operation: _]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之日志]]></title>
    <url>%2Fposts%2F18e9d6ab%2F</url>
    <content type="text"><![CDATA[日志框架日志门面：日志的一个抽象层市面上的日志框架：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…**日志门面日志实现JCL（久不更新）、SLF4j、jboss-logging（不适用于普通人群）Log4j、JUL（Java 自带）、log4j2（框架好但是有些尚未适配）、Logback（与Log4j是同一个作者）左边选一个门面（抽象层），右边选一个实现；SpringBoot ：底层为 Spring框架默认选择 JCL、而 SpringBoot 选择 SLF4j、logbackSLF4j 的使用如何使用在开发时，不应直接调用日志的实现类，而是应该调用日志的抽象层的方法。导入 SLF4j 的 jar 和 logback 的 jar123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125;图示：每一个日志的实现框架都有自己的配置文件，使用 SLF4j后，配置还是做成日志实现框架的自己的配置文件。遗留问题A（SLF4j + logback）：Spring 、Hibernate、MyBatis、….. A 系统的依赖使用了其他的日志框架统一日志记录，即使是别的框架也统一使用 SLF4j 输出如何让系统中所有的日志都统一到slf4j：将系统中其他日志框架先排除出去用中间包来替换原有的日志框架导入 slf4j 其他的实现SpringBoot 与日志的关系SpringBoot 使用日志功能123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;底层依赖关系：总结：SpringBoot 底层也是使用 slf4j + logback 的方式进行日志记录的SpringBoot 把其他的日志都替换为了 slf4jMaven 排除 jar 包的方法：12345678910111213&lt;dependency&gt; &lt;groupId&gt;sample.ProjectB&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;!-- declare the exclusion here --&gt; &lt;groupId&gt;sample.ProjectC&lt;/groupId&gt; &lt;artifactId&gt;Project-C&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;!-- ... --&gt; &lt;/exclusions&gt; &lt;/dependency&gt;也可以在 idea 的 maven 依赖树里面选中不需要的依赖，右键选择 删除日志使用LogBack入门实践12345678910111213141516171819// 记录器 private Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; // 日志的级别，由低到高 ------------------- // 可以调整输出的日志的级别；日志就只会在这个级别的以后的高级别生效 // 跟踪轨迹 logger.trace("这是 trace 日志..."); // 调试信息 logger.debug("这是 debug 日志..."); // SpringBoot 默认只会输出 info 级别：root 级别 // info logger.info("这是 info 日志..."); // warning logger.warn("这是 warning 日志..."); // error logger.error("这是 error 日志..."); &#125;1234567891011logging.level.com.xuanc=trace# =========== logging.path 与 logging.file 冲突 ===========# 指定目录，创建路径的文件夹，日志输出文件名默认使用 spring.loglogging.path=/tmp/spring/log# 如果不指定路径则在当前项目下生成日志，也可以指定路径#logging.file=springboot.log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中输出的日志的格式#logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n日志输出格式：%d 表示时间日期%thread 表示线程名%-5level级别从左显示5个字符宽度%logger{50} 表示 logger 名字最长为50个字符，否则按照据点分隔%msg 日志消息%n 换行符具体的可以在 SpringBoot 的 logging 下面的文件中查看：也可以自定义日志配置，在类路径下放上每个日志框架自己的配置文件后，SpringBoot 就不使用默认的配置了。以下文件会根据你选择的日志系统进行加载：日志系统定制配置Logbacklogback-spring.xml,logback-spring.groovy,logback.xml或logback.groovyLog4jlog4j.properties或log4j.xmlLog4j2log4j2-spring.xml或log4j2.xmlJDK (Java Util Logging)logging.properties注 如果可能的话，建议你使用-spring变种形式定义日志配置（例如，使用logback-spring.xml（由 SpringBoot 完全控制）而不是logback.xml（日志框架会读取，跳过 SpringBoot））。如果你使用标准的配置路径，Spring可能不能够完全控制日志初始化。使用 -spring 还有一个优点：由 SpringBoot 来解析日志配置，可以使用 SpringBoot 的高级 Profile 功能。123&lt;springProfile name="staging"&gt; &lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;&lt;/springProfile&gt;&lt;springProfile&gt;标签可用于根据激活的Spring profiles，选择性的包含或排除配置片段。Profile片段可以放在&lt;configuration&gt;元素内的任何地方，使用name属性定义哪些profile接受该配置，多个profiles以逗号分隔。123456789101112&gt; &lt;springProfile name="staging"&gt;&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt;&gt; &lt;/springProfile&gt;&gt; &gt; &lt;springProfile name="dev, staging"&gt;&gt; &lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;&gt; &lt;/springProfile&gt;&gt; &gt; &lt;springProfile name="!production"&gt;&gt; &lt;!-- configuration to be enabled when the "production" profile is not active --&gt;&gt; &lt;/springProfile&gt;&gt;切换日志框架按照 SLF4j 的日志适配图，进行响应的转换。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之属性配置]]></title>
    <url>%2Fposts%2Fa29f8391%2F</url>
    <content type="text"><![CDATA[配置文件SpringBoot 使用一个全局的配置文件：application.propertiesapplication.yml配置文件的作用：修改 SpringBoot 自动配置的默认值。以前的配置文件：使用的大多是 xml 文件。yml 是YAML（YAML Ain’t Markup Language）语言的文件，以数据为中心，更适合做配置文件YAML 语法基本语法key: value ==&gt; 表示一对键值对（空格不能省略），且对大小写敏感。以空格的缩进来控制层级关系；只要是左对齐的一列数据都是同一层级的数据1234server: port: 8081 path: /hello# 这是注释..值的写法字面量：普通的值（数字、字符串、布尔）字面量直接写，字符串默认不用加上单引号或者双引号；“”: 不会转义字符串的特殊字符，特殊字符作为本身要表示的意思‘’：会转义特殊字符，特殊字符只是一个普通的字符串数据对象、Map（属性和值）Key: Value 对象还是键值对的形式，在下一行写对象的KV，但需要注意缩进123friends: lastName: zhangsan age: 20行内写法：1friends: &#123;lastName: zhangshan, age: 18&#125;数组（List、Set）用 - 值 表示数组中的一个元素1234pets: - cat - dog - pig行内写法：1pets: [cat, dog, pig]上面三种格式可以互相嵌套。获取配置文件值一、使用 @ConfigurationProperties配置文件12345678910111213person: lastName: zhangsan # 驼峰命名可以转化为横杠：last-name age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1, k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2Java Bean123456789101112@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;还需要导入配置文件处理器，在 pom.xml 中加入：123456&lt;!-- 配置文件处理器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;同样，在 properties文件中也可以配置，但是在里面输入中文会出现乱码（Spring Boot 是以 iso-8859 的编码方式读取 application.properties 配置文件）。解决方法：在 .properties 中加入:12345&gt; spring.http.encoding.force=true&gt; spring.http.encoding.charset=UTF-8&gt; spring.http.encoding.enabled=true&gt; server.tomcat.uri-encoding=UTF-8&gt;将 IDEA 设置中的 File Encodings 的 Transparent native-to-ascii conversion 打钩。属性名匹配规则：person.firstName：使用标准方式person.first-name：大写用 -person.first_name：大写用_PERSON_FIRST_NAME：推荐系统属性使用这种写法二、使用 @Value使用 Spring 底层注解 @Value 来实现，获取配置文件或环境变量的值，或使用 SpEL@ConfigurationProperties 和 @Value 区别Feature@ConfigurationProperties@Value功能批量注入配置文件中的属性一个个指定松散绑定（属性名匹配规则）支持不支持SpEL不支持支持JSR303数据校验支持（注入时校验数据）不支持复杂类型封装支持不支持（只支持基本类型）数据校验：123456@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; @Email private String lastName;这样，如果 lastName 不是一个有效的 email 的话会抛出异常。加载指定的配置文件使用 @PropertySource 和 @ImportResource 可以记载指定的配置文件。使用 @ConfigurationProperties 默认是从全局配置文件中获取值。@PropertySource： 加载指定的配置文件12345@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")// @Validatedpublic class Person &#123;@ImportResource：导入 Spring 的配置文件，让配置文件里面的内容生效SpringBoot 里面没有 Spring 的配置文件，自己编写的配置文件也不能自动识别，想让 Spring 的配置文件生效，加载进来，需要把 @ImportResource 标注在配置类上：123@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)@SpringBootApplicationpublic class SpringBoot02ConfigApplication &#123;SpringBoot 推荐的给容器添加组件的方式：编写配置类使用 @Bean 给容器中添加组件12345678910@Configurationpublic class MyAppConfig &#123; // bean 的 id 与方法名相同 @Bean public HelloService helloService() &#123; return new HelloService(); &#125;&#125;配置文件占位符RandomValuePropertySource：配置文件中可以使用随机数${random.value}、${random.int}、${random.long}、${random.int(10)、${random.int[1024,65536]}属性配置占位符可以在配置文件中引用前面配置过的属性（优先级前面配置过得这里都能用）${app.name: 默认值}来指定找不到属性的默认值123456789#person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/12person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,c,dperson.dog.name=$&#123;person.last-name&#125;_dogperson.dog.age=15如果属性不存在，则会将占位符当做字符串处理ProfileProfile 是 Spring 对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境多 profile 文件形式格式：application-{profile}.properties默认使用 application.properties 配置文件。YAML 文档块模式YAML 中如果使用 --- 可以将文件划分为不同的文档块，多个 profile 可以写在同一个文件中1234567891011121314151617181920212223242526272829303132# Document1server: port: 8081person: lastName: zhangsan age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1, k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2spring: profiles: active: dev # 指定激活哪一个 profile---# Document2server: port: 8011spring: profiles: dev # 指定文档块属于哪个 profile---# Document3server: port: 8022spring: profiles: prod使用其他环境的配置文件的方式：application.properties 或 application.yml 指定YAML 的优先级比 .properties 要低spring.profiles.active={profile}`spring:profiles:active: {profile}` 命令行方式（优先级较高）：idea 的 program arguments 设置 -- spring.profiles.active={profile}maven 打包后，在命令行执行并加上参数虚拟机参数idea 的 VM options: -Dspring.profiles.active={profile}配置文件的加载位置SpringBoot 启动会扫描以下位置的 application.properties或者 application.yml 文件作为 SpringBoot 的默认配置文件：（Idea 中类路径即 classpath:对应 resources 目录）file:/config/file:/classpath:/configclasspath:/以上按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置的内容会覆盖低优先级配置的内容，也可以通过配置 spring.config.location 来改变默认内容。SpringBoot 会加载上述的所有文件，只是如果配置冲突，高优先级的配置文件中的设置会覆盖低优先级配置文件的设置，低优先级的其他配置依然会生效。例如在上述四个配置文件中分别定义不同的端口号，在 /resource/application.properties 文件中定义项目的访问路径，那么运行后低优先级配置的项目访问路径仍然有效：12345server.port=8081# 配置项目的访问路径server.servlet.context-path=/springboot-demo# 新版本的配置改为：server.servlet.context-path，而不是 server.context-path指定配置文件路径项目打包好后，可以使用命令行参数的形式，在启动项目时指定配置文件的新位置，指定的配置文件和默认加载的配置文件会共同启动作用，形成互补配置。直接在上述的四个配置文件中指定 spring.config.location 并不会生效。外部配置的加载顺序官网文档中文手册上提到的外部配置的加载顺序：Spring Boot允许将配置外部化（externalize），这样你就能够在不同的环境下使用相同的代码。你可以使用properties文件，YAML文件，环境变量和命令行参数来外部化配置。使用@Value注解，可以直接将属性值注入到beans中，然后通过Spring的Environment抽象或通过@ConfigurationProperties绑定到结构化对象来访问。Spring Boot设计了一个非常特别的PropertySource顺序，以允许对属性值进行合理的覆盖，属性会以如下的顺序进行设值：（优先级从高到低，高优先级覆盖低优先级，形成互补）home目录下的devtools全局设置属性（~/.spring-boot-devtools.properties，如果devtools激活）。测试用例上的@TestPropertySource注解。测试用例上的@SpringBootTest#properties注解。命令行参数（多个参数可以用空格分隔开）来自SPRING_APPLICATION_JSON的属性（环境变量或系统属性中内嵌的内联JSON）。ServletConfig初始化参数。ServletContext初始化参数。来自于java:comp/env的JNDI属性。Java系统属性（System.getProperties()）。操作系统环境变量。RandomValuePropertySource，只包含random.中的属性。没有打进jar包的Profile-specific应用属性（application-{profile}.properties和YAML变量）。打进jar包中的Profile-specific应用属性（application-{profile}.properties和YAML变量）。没有打进jar包的应用配置（application.properties和YAML变量）。打进jar包中的应用配置（application.properties和YAML变量）。@Configuration类上的@PropertySource注解。默认属性（使用SpringApplication.setDefaultProperties指定）。自动配置的原理配置文件可配置属性的范围：官方文档自动配置原理：SpringBoot 启动时，加载主配置类，开启了自动配置功能 @EnableAutoConfiguration@EnableAutoConfiguration 作用利用 AutoConfigurationImportSelector.class 给容器中导入组件，里面的 public String[] selectImports(AnnotationMetadata annotationMetadata) { ... } 方法中，调用了 protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {...} 方法，这里面有一句代码是这样的：1List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);通过这行代码来获取候选的配置。1234567protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames( this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."); return configurations;&#125;里面的 loadFactoryNames 方法的源码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; try &#123; // 扫描所有jar包类路径下的 META-INF/spring.factories 文件 Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); // 获取 url 后对每个 url 进行遍历 while (urls.hasMoreElements()) &#123; // 把扫描到的文件内容包装为 properties 对象 URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; // 从 properties 对象中获取全类名 String factoryClassName = ((String) entry.getKey()).trim(); for (String factoryName : StringUtils. commaDelimitedListToStringArray((String) entry.getValue())) &#123; // 添加 result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException("Unable to load factories from location [" + FACTORIES_RESOURCE_LOCATION + "]", ex); &#125;&#125;// 返回 EnableAutoConfiguration.class 类protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123; return EnableAutoConfiguration.class;&#125;所以总的来说，是将 META-INF/spring.factories 里面的所有 EnableAutoConfiguration 的值加入到容器中。使用这些类来做自动配置：每一个自动配置类进行自动配置功能以 HttpEncodingAutoConfiguration 为例1234567891011121314151617181920212223242526272829303132333435@Configuration// 表示这是一个配置类@EnableConfigurationProperties(HttpProperties.class)// 启用指定类的 ConfigurationProperties 功能，将配置文件中对应的值与这个properties类绑定在一起，并把 HttpProperties 加入到 Ioc 容器中@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)// Spring 底层注解，根据不同的条件决定配置是否生效；// 判断当前应用是否为 web 应用，如果是则生效@ConditionalOnClass(CharacterEncodingFilter.class)// 判断当前项目有没有这个类(Spring MVC 解决乱码中的过滤器)@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true)// 判断在配置文件中是否启用，如果配置这个属性，也生效public class HttpEncodingAutoConfiguration &#123; // 已近与 SpringBoot 的配置文件映射了 private final HttpProperties.Encoding properties; // 只有一个有参构造器的情况下，参数的值会从容器中获取 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; // 给容器中添加组件，有些值需要从 properties 中获取 @Bean // 容器中没有这个组件时候才会执行 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding( this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding( this.properties.shouldForce(Type.RESPONSE)); return filter; &#125;根据当前不同的条件判断。决定配置类是否生效，一旦配置类生效，这个配置类就会在容器中添加各种组件，这些组件的属性是从对应的 propertie 类中获取的，而这些类的每一个属性又是和配置文件绑定的。所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类123@ConfigurationProperties(prefix = "spring.http")// 从配置文件中获取指定的值和 bean 的属性进行绑定public class HttpProperties &#123;SpingBoot 的精髓：SpringBoot 启动会加载大量的自动配置类我们需要的功能有没有 SpringBoot 默认写好的自动配置类在看这个自动配置类到底配置了哪些组件，如果有，就不需要自动配置了给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性，可以在配置文件中指定属性的值@Conditional 扩展注解@Conditional扩展注解作用（判断是否满足当前指定条件）@ConditionalOnJava系统的java版本是否符合要求@ConditionalOnBean容器中存在指定Bean；@ConditionalOnMissingBean容器中不存在指定Bean；@ConditionalOnExpression满足SpEL表达式指定@ConditionalOnClass系统中有指定的类@ConditionalOnMissingClass系统中没有指定的类@ConditionalOnSingleCandidate容器中只有一个指定的Bean，或者这个Bean是首选Bean@ConditionalOnProperty系统中指定的属性是否有指定的值@ConditionalOnResource类路径下是否存在指定资源文件@ConditionalOnWebApplication当前是web环境@ConditionalOnNotWebApplication当前不是web环境@ConditionalOnJndiJNDI存在指定项自动配置类必须在一定的条件下才能生效；查看哪些配置类自动生效：通过启用 debug 属性来打印自动配置报告：12# 开启 SpringBoot 的 debug 模式debug=true]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之环境配置]]></title>
    <url>%2Fposts%2Fcb2b0fb3%2F</url>
    <content type="text"><![CDATA[将 SpringBoot 项目打包为 Jar 包maven pom.xml 中加入如下代码：123456789&lt;build&gt; &lt;!-- 插件作用：将应用打包为可执行的 jar 包 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;使用 mvn package 就可以将应用打包。在终端里 cd 到 jar 的位置后，java -jar (jar包名称或路径） 就可以运行项目，而且不需要配置 tomcat 环境，因为 SpringBoot 集成了 tomcat。POM 文件解析父项目123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;父项目作用：依赖管理这个父项目还有一个父项目：123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;这个父项目才是真正管理 Spring Boot 应用里面的所有的依赖管理的，其 &lt;properties&gt; 属性规定了常用包的版本号。所以导入以及规定版本的包是不需要写版本号的。导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;spring-boot-starter-web: spring-boot 场景启动器，导入了 web 模块正常运行需要的依赖Sping Boot 将所有的功能场景都抽取出来，做成一个 starters，只需要在项目里面引入这些 starter 相关的场景依赖都会自动导入进来。主程序类1234567891011@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring 应用启动起来 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125;@SpringBootApplication 说明被注解标注的类是 SpringBoot 的主配置类，SpringBoot 应该运行这个类的 main 方法来启动 SpringBoot 应用。注解部分源码：12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;@SpringBootConfiguration : 表示被标注的类是 SpringBoot 的配置类，配置类也是容器中的一个组件@EnableAutoConfiguration：开启自动配置的功能自动配置的原理：注解部分源码：1234&gt; @AutoConfigurationPackage&gt; @Import(&#123;AutoConfigurationImportSelector.class&#125;)&gt; public @interface EnableAutoConfiguration &#123;&gt;@AutoConfigurationPackage : 自动配置包，使用 @Import({Registrar.class}) 这个 Spring 底层注解来实现，给容器中导入一个组件。12&gt; &gt; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;&gt; &gt;将主配置类 （@SpringBootApplication 标注的类）的所在包下面的所有子包里面的所有组件扫描到 Spring 容器@Import({AutoConfigurationImportSelector.class}): 给容器中导入组件将所有需要导入的组件以全类名的方式返回，添加到容器中。会给容器中导入非常多的自动配置类（xxxAutoConfiguration），就是给容器中导入这个场景所需要的所有组件，并配置好这些组件。AutoConfigurationImportSelector 类部分代码：12345678910&gt; &gt; public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;&gt; &gt; if (!this.isEnabled(annotationMetadata)) &#123;&gt; &gt; return NO_IMPORTS;&gt; &gt; &#125; else &#123;&gt; &gt; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);&gt; &gt; AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);&gt; &gt; return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&gt; &gt; &#125;&gt; &gt; &#125;&gt; &gt;方法 getAutoConfigurationEntry 中的 List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations 数组就是容器中需要导入的组件。SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());从类加载器中获取资源，将资源作为 properties 配置文件，从中拿出工程的名字：factoryClass.getName()。从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中。有了自动配置类，就免去了手动编写而配置注入功能组件等的工作。J2EE 的整体解决方案和自动配置都在 spring-boot-autoconfigure-xxx.RELEASE.jar;使用 Spring Initializr 快速创建项目Idea 或者官网的 Spring Initialzr 可以快速创建项目。默认生成的 Spring Boot 项目：主程序、测试文件生成好了resource 文件夹的目录结构static: 保存所有的静态资源：js、css、images；templates: 保存所有的模板页面；（由于使用嵌入式的 Tomcat，默认不支持 JSP）application.properties: Spring Boot 应用的配置文件，可以修改默认设置；]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet请求转发]]></title>
    <url>%2Fposts%2Fe0aa16fa%2F</url>
    <content type="text"><![CDATA[在 Servlet 中请求转发的方法无非两种：使用 RequestDispatcher 来调派请求使用 include() 来将另一个 Servlet 的操作流程包括至目前的操作流程中使用 forward() 方法将请求处理转发给其他的 Servlet使用 HttpServletResponse 的 sendRedirect() 方法要求浏览器重新请求另一个 URL如果要调用 forward() 和 sendRedirect() 方法，那么目前的 Servlet 不能有任何响应确认，否则会抛出异常。调用 forward() 方法时需要传入请求与响应对象，由于传递的是同一个 request，所以在转发过程中可以使用请求范围属性来传递一些属性。但 forward() 转发的这个动作是在 Web 容器中进行的，浏览器不知道请求被转发，地址栏也不会发生变化，转发也限制只能转发到服务器的另一个资源。而在整个转发过程中，都还是在同一个请求周期中。当浏览器请求 Servlet1 后，Servlet1 将请求转发给了 Servlet2，之后 Servlet2 对浏览器进行响应，全程浏览器都不知道发送的请求已被转发。这样会存在的一个问题：当我刷新页面后，不过不加以处理会导致数据被重复提交。比如现在有如下代码：123456789101112131415161718&lt;%@page pageEncoding="UTF-8" contentType="text/html; UTF-8" %&gt;&lt;!doctype html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="testServlet" method="post"&gt; 用户名&lt;input type="text" name="username"&gt;&lt;br/&gt; 消息&amp;emsp;&lt;input type="text" name="message"&gt;&lt;br/&gt; &lt;input type="submit" value="上传"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;1234567891011121314151617181920212223242526272829303132333435363738package xuac;import java.io.*;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;/** * ClassName ServletTest-ServletOne * Description forward() * @author xuanc * @version 1.0 * @date 19-3-17 下午2:04 */@WebServlet("/testServlet")public class ServletOne extends HttpServlet&#123; private void processRequest(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; System.out.println("forward() 测试 ----------------------"); String username = request.getParameter("username"); String message = request.getParameter("message"); System.out.println("Username: " + username + "\n" + "Message: " + message); request.getRequestDispatcher("index.jsp").forward(request, response); System.out.println("after forward()......................"); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; processRequest(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; processRequest(request, response); &#125;&#125;提交表单后在输出了表单内容。而当刷新一次后：浏览器会提醒重复提交表单当确认后发现内容被重复提交：sendRedirect() 方法顾名思义，是重定向而非转发。可以让浏览器重新请求另一个 URL，请求的资源也可以是其他服务端的资源。与 forward() 不同，重定向实际上是两次请求，浏览器请求 Servlet1 时，Servlet1 将浏览器重定向到 Servlet2，然后浏览器向 Servlet2 发出请求，之后则由 Servlet2 做出响应或者其他的操作。这样的重定向浏览器是可以知道的，地址栏也会发生变化。上面的例子中，解决刷新重复提交表单的方法之一就是使用重定向而不是转发（forward()）。另一种方法是使用 token，通过它来判断是否是重复提交，进而进行处理。由于在重定向的过程中，并没有使用同一个 HttpRequest 对象，所以想要传递属性只能通过 Session 来处理。而且因为是两次请求，需要额外的往返行为，所以相比 forward() 来说重定向会慢一些。在上面的例子中我们也可以看到，调用 forward 或 sendRedirect 不会停止执行方法中的其余代码。所以如果转发和重定向之后还有可能会执行其他语句的话应该加上 return。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记－疯狂Java讲义[4]]]></title>
    <url>%2Fposts%2F603dd0d7%2F</url>
    <content type="text"><![CDATA[第四章 流程控制与数组1.流程控制switch&emsp;&emsp;switch 语句后面控制表达式的数据类型只能是byte、short、char、int、枚举类型和java.lang.String类型。switch中其他类型会隐式向上转换为int，long比int范围大，转换可能会损失精度，Java通过string的hash()值把string也转换为int。控制循环结构&emsp;&emsp;Java没有提供goto语句，与C类似，也有continue、break语句。不同的是，break和continue后可以紧跟标签来使得可以结束或直接跳到外层循环。&emsp;&emsp;标签是一个紧跟英文冒号的标识符，Java中的标签只有放在循环语句前才有用。代码清单12345678910111213public class HelloWorld&#123; public static void main(String []args)&#123; outer: for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; System.out.println("Hello ~"); if (j == 1) &#123; break outer; &#125; &#125; &#125; &#125;&#125;2.数组&emsp;&emsp;数组也是一种数据类型，属于引用类型。数组用来存储一组具有相同数据类型的元素。Java中类与类可以继承，会造成一个数组中有多个类型的假象，但归根到底元素都属于同一种类型。数组一旦初始化完成后，其长度将固定不变。&emsp;&emsp;数组是一种引用类型，定义一个数组后相当于只定义了一个指针，这个指针还没指向任何有效内存。所以定义数组的时候不能指定数组的长度。数组的定义12type[] arrayName; type arrayName[];&emsp;&emsp;为了更好的可读性，推荐使用第一种定义方式。数组的初始化&emsp;&emsp;初始化，即为数组的数组元素分配内存空间，并给每个数组元素赋值，数组的定义和初始化可以同时完成。初始化的两种方式：静态初始化初始化时显式指定数组元素的初值，长度由系统决定（指定长度会报错）。语法格式：123arrayName = new type[] &#123;element1, element2, ..., elementn&#125;;// 数组的定义和静态初始化同时完成可以省略 new type[]// type[] arrayName = &#123;element1, element2, ...&#125;;初始化时type类型以及元素的类型要与定义数组时指定的类型一致（相同或为定义时指定类型的子类），元素以逗号分隔开。动态初始化初始化时只指定数组的长度，系统为数组元素分配初值。语法格式：1arrayName = new type[length];type类型要求同上。length可以是已初始化的变量。系统默认分配的初值为：整数类型：0浮点类型：0.0字符类型：’\u0000’布尔类型：false引用类型：null数组的使用数组可以通过索引的方式去除数组元素或对其进行赋值如果索引超出数组大小范围在运行时会抛出异常：java.lang.ArrayIndexOutOfBoundsException: N，N的值即为非法的数组索引。数组的长度可以通过其length属性获得Java5之后，Java提供了更简单的循环：foreach循环，可以自动遍历数组和集合的每个元素。123for(type variableName : array | collection) &#123; // variableName 自动访问每个元素&#125;foreach循环中的循环变量variableName是一个临时变量，改变他并不能改变数或集合中元素的值数组的实质&emsp;&emsp;数组引用变量只是一个引用，数组元素和数组变量在内存里分开存储。而引用变量是访问真实对象的根本方式，只能通过数组的引用变量才能访问数组对象本身。&emsp;&emsp;实际的数组对象存储在堆中，如果引用数组对象的数组引用变量是局部变量，它被存储在栈中，如果堆中的对象不在有任何变量指向它，会被JVM的垃圾回收机制回收。&emsp;&emsp;通过对数组的重新赋值，产生数组长度可变的错觉，但实际堆中实际的数组对象并不可变。程序清单123456789101112131415public class ArrayInRam &#123; public static void main(String[] args) &#123; int[] a = &#123;5, 7, 20&#125;; int[] b = new int[4]; System.out.println("b 数组的长度" + b.length); for (int temp : a) &#123; System.out.println(temp); &#125; for (int temp : b) &#123; System.out.println(temp); &#125; b = a; System.out.println("b 数组的长度" + b.length); &#125;&#125;多维数组&emsp;&emsp;Java支持多维数组，但从本质上来说并没有多维数组。多维数组实质上其元素也是引用变量。代码清单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TwoDimensionTest &#123; public static void main(String[] args) &#123; // 定义一个二维数组 int[][] a; // 初始化数组，数组a有四个元素，每一个元素都是int[]类型 a = new int[4][]; // Error! // a = new int[][4]; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; System.out.println("-----------"); a[0] = new int[2]; a[0][1] = 6; for (int i = 0; i &lt; a[0].length; i++) &#123; System.out.println(a[0][i]); &#125; System.out.println("==========="); // 初始化的多种方式 // One // int[][] b = new int[][] &#123; // new int[]&#123;1&#125;, // new int[]&#123;1, 2&#125;, // new int[]&#123;1, 2, 3&#125; // &#125;; // Two int[][] b = &#123; &#123;1&#125;, new int[2], new int[]&#123;1, 2, 3&#125; &#125;; // foreach() for (int[] tempArray : b) &#123; for (int tempValue : tempArray) &#123; System.out.println(tempValue); &#125; &#125; System.out.println("==========="); // Error! // int[][] c = new int[2][] &#123; // 1, 2, 3, 4, 5, 6 // &#125;; int[][] c = new int[2][4]; &#125;&#125;使用Arrays类&emsp;&emsp;Java中Arrays类中的一些static方法可以直接操作数组，使用这些方法需要导入java.util.Arrays类(import java.util.Arrays)，static方法可以直接通过类名调用。int binarySearch(type[] a, type key)使用二分法在数组a中查询值为key的元素，返回其索引，查找失败返回负数。要求数组为升序排列。int binarySearch(type[] a, int fromIndex, int toIndex, type key)与上一个类似，只是限定查找索引范围为fromIndex到toIndex。type[] copyOf(type[] original, int length)将original复制为一个新的数组，新数组长为length，如果length大于原数组的长度，后面元素补充为0、false或null。type[] copyOfRange(type[] original, int from, int to)只复制数组的from索引到to索引的元素boolean equals(type[] a, type[] a2)判断两个数组是否相等（长度+数组对应元素）void fill(type[] a, type val)将数组的所有元素设为valvoid fill(type[] a, int fromIndex, int toIndex, type val)与上一个相同，只是限制了赋值的索引范围void sort(type[] a)对数组元素排序（自定义排序方法涉及到重载）void sort(type[] a, int fromIndex, int toIndex)作用同上，只限制了排序的范围String toString(type[] a)将一个数组转换为字符串代码清单12345678910111213141516171819import java.util.Arrays;public class TwoDimensionTest &#123; public static void main(String[] args) &#123; String names[] = new String[]&#123; "人生苦短", "来杯Java" &#125;; String namesCopy[] = Arrays.copyOf(names, names.length); System.out.println(Arrays.toString(namesCopy)); names[0] = "HelloWorld"; System.out.println(Arrays.toString(names)); System.out.println(Arrays.toString(namesCopy)); &#125;&#125;// output------------------------------------------------------// [人生苦短, 来杯Java]// [HelloWorld, 来杯Java]// [人生苦短, 来杯Java]]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter7-使用JSTL]]></title>
    <url>%2Fposts%2F2f1b8bf3%2F</url>
    <content type="text"><![CDATA[JSTL 简介JSTL 提供了与页面呈现相关的逻辑判断标签，也提供了对应 JSP 标注标签的扩展标签和更多的功能标签，可以分为五类：核心标签库：提供条件判断、属性访问、URL 处理及错误处理等I18N 兼容格式标签库：提供数字、日期等的格式化和区域、编码处理等功能SQL 标签库XML 标签库：提供 XML 解析、流程控制、转换等功能函数标签库：提供常用字串处理的已定义 EL 标签库idea 使用 JSTL 标签库：在 JSTL 中下载最新的 zip 文件，解压。idea 中打开设置，搜索 Schemas and DTDs，点右边的 +，URL中输入 http://java.sun.com/jsp/jstl/core，浏览文件选择刚才解压后文件夹中的 tld 目录下的 c.tld 文件。将 zip 文件夹中的 lib 里的文件复制到项目中的 WEB-INF 的 lib 目录下，或者在 Project Setting -&gt; Libraries 中点＋，选择 lib 文件夹里面的文件。核心标签库流程处理标签1234&lt;c:if test="$&#123;param.name == 'momor'&amp;&amp; param.password == '1234'&#125;"&gt; &lt;h1&gt;$&#123;param.name&#125; 登录成功 &lt;/h1&gt;&lt;/c:if&gt;&lt;%-- JSTL中可以使用EL表达式--%&gt;如果 test 属性为 true，才会输出 &lt;c:if&gt; 标签中的语句。123456789101112&lt;c:choose&gt; &lt;c:when test="$&#123;user.valid&#125;"&gt; &lt;jsp:getProperty name="user" property="name"/&gt; 登录成功 &lt;%-- * 属性的名称就是get/set方法去除get/set后 ,再把首字母小写 * boolean的方法可以是is开头 --%&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h1&gt; 登录失败 &lt;/h1&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt;当 &lt;c:when&gt; test 为 true 时，只会输出这个标签中的 Body 内容。否则继续判断下一个 &lt;c:when&gt; 标签中的 test，如果所有的 &lt;c:when&gt; 都不满足，就输出 &lt;c:otherwise&gt; 的内容（如果有这个标签）。123456&lt;c:forEach var="message" items="$&#123;messageService.messages&#125;"&gt; &lt;tr&gt; &lt;td&gt;$&#123;message.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.text&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;类似 Java 中的 forEach 循环，items 属性可以是数组、Collection、Iterator、Enumeration、Map 与字符串。每次会从 items 中取出元素，指定给 var 属性设置的变量。items 属性是 Map :&emsp;&emsp;设置给 var 的对象是 Map.Entry ，有 getKey() getValue() 方法取得键与值。items 属性是字符串：&emsp;&emsp;以逗号来切割字符串，如果要自定义切割依据可以使用&lt;c:forTokens&gt;123&lt;c:forTokens var="token" delims=";" items="a;b;c;d;e"&gt; &lt;%-- ... --%&gt;&lt;/c:forTokens&gt;错误处理标签错误发生时，在当前网页捕捉异常并显示相关信息。使用 &lt;c:catch&gt; 标签。1234567&lt;c:catch var="error"&gt; $&#123;param.a&#125; + $&#123;param.b&#125; = $&#123;param.a + param.b&#125;&lt;/c:catch&gt;&lt;c:if test="$&#123;error != null&#125;"&gt; &lt;br&gt;&lt;span style="color: red;"&gt;$&#123;error.message&#125;&lt;/span&gt; &lt;br&gt;$&#123;error&#125;&lt;/c:if&gt;用 &lt;c:catch&gt; 标签将可能产生异常的部分包起来，如果有异常会给 var 设值。所有的异常都是 Throwable 的子类，都有 getMessage() 方法。网页导入、重定向、URL处理标签包含其他 JSP 网页到当前网页的几种方式：&lt;%@include file=&quot;/....&quot; %&gt;使用 &lt;jsp:include&gt; 标签，动态包含，还可传递参数JSTL 中有一个 &lt;c:import&gt; 标签，也可以在运行时动态导入到另一个网页。1234567&lt;c:import url="add.jsp"&gt; &lt;c:param name="a" value="1" /&gt; &lt;%-- 用 &lt;c:param&gt; 标签传递参数--%&gt;&lt;/c:import&gt;&lt;c:import url="https://...." charEncoding="BIG5" /&gt;&lt;%--导入外部网页，如果编码不同需指定具体编码--%&gt;&lt;%--没有使用参数--%&gt;&lt;c:redirect&gt; 标签，可以重定向网页，类似 Servlet 中的 HttpServletResponse.sendRedirect() 方法，可以使用 &lt;c:param&gt; 标签在重定向时指定参数。之前利用 response.encodeURL() 方法来作 URL 重写，以在关闭 Cookie 后正常维持 Session 进行会话管理，现在可以用 &lt;c:url&gt; 标签达到同样的目的。属性处理与输出标签可以用 JSTL 设置属性：12345&lt;c:set var="p1q1" value="$&#123;param.p1q1&#125;" scope="session" /&gt;&lt;%--属性值太长可以用 Body 形式--%&gt;&lt;c:set var="p1q2" scope="session"&gt; some....&lt;/c:set&gt;var 用来设置属性名，value 设置属性值（可以用 EL 表达式），如果不设置 scope ，会从 page 、request 、session、application 的范围中查找属性名称，如果找到就在该范围设置，找不到就在page 范围新建。移除属性：&lt;c:remove var=&quot;login&quot; scope=&quot;session&quot;/&gt;&lt;c:set&gt; 可以设置 JavaBean 的属性或 Map 对象的键/值，需要使用 target 属性进行设置。&lt;c:set target=&quot;${pageContext.request}&quot; property=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;如果 target 属性是 JavaBean，就用 JavaBean 的 setXXX 方法为 property 设值。如果是 Map 对象，则会以 property 为键，以 value 为值。&lt;c：out&gt; 标签可以输出内容，并用合适的字符替换 &lt;、&gt;、”等字符。eg.&lt;c:out value=&quot;some&quot;&gt;如果不想取代字符，可以设置属性 escapeXml 为 false （默认为 true），如果输出内容的 EL 表达式结果为 null 时，不会显示任何内容，也可以加上 default 属性设置为null时的默认值。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter6-使用jsp]]></title>
    <url>%2Fposts%2F2bd95d05%2F</url>
    <content type="text"><![CDATA[指示元素JSP指示元素主要是为了表示容器将 JSP 转译为 Servlet 源代码时所必须遵守的信息。 语法为：&lt;%@ 指示类型 [属性=&quot;值&quot;]* %&gt;，指示元素可以有多对的属性/值 JSP 常用的三种指示类型为：page 、include、taglib page： 告知容器如何转译当前的JSP网页 include： 告知容器将别的JSP页面包括进来进行转译 taglib： 告知容器如何转译这个页面的标签库 12&lt;%@page import="java.util.Date" %&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8"%&gt; 1：告知容器转译时要包括import属性中的值的包，即 Servlet 要有import java.uutil.Date;，如果有多个包要包含，可以用逗号分割开：... import=&quot;java.util.Date, java.util.io*, ...&quot; 2：contenType属性对应转译后的response.setContentType(&quot;...&quot;)，pageEncoding告诉容器这个网页的编码 include类型的范例： 12345&lt;!-- includeDemo.jsp --&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@include file="/WEB-INF/jspf/header.jspf"%&gt; &lt;h1&gt;这是本尊&lt;/h1&gt;&lt;%@include file="/WEB-INF/jspf/foot.jspf"%&gt; 12345678910&lt;!--header.jspf--&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8" %&gt;&lt;!doctype html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;示范开头&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是开头&lt;/h1&gt; 12345&lt;!--foot,jspf--&gt;&lt;%@page pageEncoding="UTF-8" %&gt; &lt;h1&gt;这是结尾&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; includeDemo.jsp 第一次执行时会将上面两个文件的内容包括起来，然后进行转译，所以最终会生成一个Servlet，这是一种静态的包括方式。&lt;jsp:include&gt;标签是运行时动态包括别的网页执行流程进行响应的方式，会各自生成独立的 Servlet。 同时也可以看到，包含的两个文件的后缀名是 .jspf，.jspf 文件通常是通过include伪指令包含在.jsp文件中的文件。’f’代表’fragment’，因为这些文件本身可能并不是完整的JSP，而是JSP的片段。类似这样的后缀名还有一个 .jspx。 同样，关于一些JSP的设置也可以在 web.xml 中更改，例如网页编码、内容类型等等 1234567891011&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;page-encoding&gt;UTF-8&lt;/page-encoding&gt; &lt;default-content-type&gt;text/html&lt;/default-content-type&gt; ... &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; 也可以声明指定的JSP文件的开头和结尾所要包括的网页 123456789... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;include-perlude&gt;some...&lt;/include-perlude&gt; &lt;include-coda&gt;some...&lt;/include-coda&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;... 在编写JSP网页时，换行字符不会忽略，所以最后产生的换行字符也会输出，如果要忽略，可以在 web.xml 中的&lt;jsp-property-group&gt;标签中加上 &lt;trim-directive-whitespaces&gt;true&lt;/...&gt; 声明、Scriptlet 与表达式元素JSP 中可以使用 声明、Scriptlet 元素和表达式来指定转译后 Servlet 类中包括的类成员、方法声明和语句。 声明元素的语法：&lt;@! 类成员声明或方法声明 %&gt; Scriptlet 的语法：&lt;% Java 语句 %&gt; 在 JSP 中的编写的 HTML，都会变成 out 语句所输出的内容，而 Scriptlet 出现的顺序在转译为 Servlet 后，会按顺序出现在 _jsoService() 中。 表达式元素的语法：&lt;%= Java表达式 %&gt; 表达式的运算结果将直接输出为网页的一部分，但表达式语句不能加上分号，因为在转译后，表达式语句的表达式会转译为 out 对象输出时的指定内容。 由于&lt;%和%&gt;在 JSP 中用来作为一些元素的开头和结尾，所以如果要在 JSP 网页中输出这两个符号要换成其他字符：&lt;% –&gt; &amp;lt;%，%&gt; –&gt; %&amp;gt;或%\&gt; （HTML输出&amp;用&amp;amp）。 一个网页通过适当的规划、切割业务逻辑与呈现逻辑，JSP 网页可以通过标准标签、EL 或 JSTL 自定义标签等消除网页上的 Scriptlet。 注释元素使用 &lt;%-- JSP注释 --%&gt;，写出网页注释会输出到网页上。 隐式对象JSP 隐式对象| 隐式对象 | 说明 || :———- | ———————————————————— || out | 转译后对应 JspWriter 对象，其内部关联一个 PrintWriter 对象 || request | 转译后对应 HttpServletRequest 对象 || response | 转译后对应 HttpServletResponse 对象 || config | 转译后对应 ServletConfig 对象 || applicaton | 转译后对应 ServletContext 对象 || session | 转译后对应 HttpSession 对象 || pageContext | 转译后对应 pageContext 对象，提供了 JSP 页面资源的封装，可设置页面范围属性 || exception | 转译后对应 Throwable 对象 ，代表其他 JSP 页面抛出的异常对象，只会出现于 JSP 错误页面 || page | 转译后对应 this | 隐式对象只能在&lt;%和%&gt;或&lt;%=和%&gt;之间使用。隐式对象转译后是_jspService()中的局部变量。 JspWriter 主要模拟了 BufferedWriter 与 PrintWriter 的功能，内部也是用 PrntWriter 来输出，但 JspWriter 具有缓冲区功能，使用 print() 和 println() 响应输出时，如果 JSP 页面没有缓冲或清楚缓冲时，才会直接创建 printWriter() 对象进行输出。 page 指示元素的 buffer 属性来设置缓冲区的大小，默认是8kb，autoFlush 属性决定缓冲区已满后的行为，默认值是 true ，表示慢了就清除，如果设置为 false，要自行调用 JspWriter 的 flush() 方法来清除，否则调用 println() 会抛出 IOException 异常。 所有的隐式对象都可以通过 pageContext 的 getXXX() 方法来取得，pageContext 也可以设置页面范围属性，类似 Servlet 中的几个对象，可以使用 setAttribute()、getAttribute()、removeAttribute() 来设置。页面范围属性的作用范围仅仅局限于同一页面中。 pageContext 提供了单一的 API 来设置四种范围属性： 123getAttribute(String name, int scope);setAttribute(String name, Object value, int scope);removeAttribute(String name, int scope); scope 的取值所代表的范围： pageContext.PAGE_SCOPE: 页面 pageContext.REQUEST_SCOPE : 请求 pageContext.SESSION_SCOPE: 会话 pageContext.APPLICATION_SCOPE : 应用程序范围 如果不知道属性范围的名称，可以用 pageContext 的 findAttribute() 方法依序从页面、请求、会话、应用程序范围中寻找，先找到就返回。 错误处理JSP 发生错误按时段分为三种： JSP 转换为 Servlet 源代码 Servlet 源代码编译时 Servlet 载入容器进行服务但发生运行时错误时 可以自定义运行时异常发生时的处理页面，需要用 page 指示元素，设置 errorPage 属性来指定错误处理的页面。 12&lt;%--add.jsp--%&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8" errorPage="error.jsp" %&gt; 12&lt;%--error.jsp--%&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8" isErrorPage="true" %&gt; exception 对象是 JSP 的隐式对象，只有 isErrorPage 设置为 true 的页面才可以使用这个对象。如果没有处理，会由容器默认处理，直接显示异常信息和堆栈跟踪信息。 123456789101112&lt;web-app ...&gt; &lt;!--容器收到某个类型的异常对象时进行转发--&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.NullPointerException&lt;/exception-type&gt; &lt;location&gt;/report.view&lt;/location&gt; &lt;/error-page&gt; &lt;!--基于HTTP错误状态码转发至处理页面--&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt; 标准标签JSP 规范中提供了一些标准标签，所有容器都支持，可协助编写 JSP 是减少 Scriptlet 的使用，所有的标签都以 jsp: 为前缀。 &lt;jsp:include>、&lt;jsp:forward>标签&lt;jsp:include&gt; 和 &lt;jsp:forward&gt;标签在转译后，底层是取得 RequestDispatcher 对象，并执行对应的 forward() 方法和 include() 方法。 123&lt;jsp:include page="add.jsp"&gt; &lt;jsp:param name="a" value="1"/&gt;&lt;/jsp:include&gt; &lt;jsp:param&gt; 指定了动态包括 add.jsp 时需要给页面的请求参数。 &lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt;JavaBean 元件具有的条件： 必须实现 java.io.Serializable 接口 没有公开的类变量 具有无参数的构造器 具有公开的设值(setXXX)和取值(getXXX)方法 &lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt; 这三个标准标签就是搭配 JavaBean 元件的。 12&lt;jsp:useBean id="user" class="User"/&gt;&lt;jsp:setProperty name="user" property="*"/&gt; 1.用来取得或创建 JavaBean id 指定 JavaBean 的实例名，之后可使用这个指定的名称设值和取值。 class 属性指定要实例化哪个类。 还有一个属性 scope （默认为 page 范围）指定先查找设定的属性范围是否有名为id 指定值的 JavaBean 的属性存在，如果找到就直接使用，没有找到就会新建新的对象。 type 属性，指定声明 JavaBean 的类型，可以是一个抽象类、也可以是一个接口。但如果只设置了 type 而没有 class , 如果指定范围内找不到对象会抛出异常。 2.设置 JavaBean 的属性值 name 指定要使用哪个名称来使用 JavaBean 实例，property 表示要设置的 JavaBean 属性，这两个属性在这个标签中必需的。 value 和 param 两个属性可选，找到 JavaBean 后，如果指定了 value 元素，会将value的值转换为合适的基本类型赋值给指定的 JavaBean 属性。有 param 属性的话会将指定的参数的值转化会合适的基本类型赋给 JavaBean 属性。 如果value 和 param 都省略，可以用 JSP 的自省机制判断是否有 property 值相同的请求参数，有的话就赋给 JavaBean。 最有弹性的写法是示例代码第二行所示，标签中只有必要元素，property 值设为 *，代表将请求参数名称和 JavaBean 属性名交给自省机制自动匹配。自省机制可以自动转换基本类型。 有两种很容易混淆的写法： 12&lt;jsp:useBean id="user" class="User"/&gt;&lt;jsp:setProperty name="user" property="*"/&gt; 这种写法无论如何都会使用设值。 123&lt;jsp:useBean id="user" class="User"&gt; &lt;jsp:setProperty name="user" property="*"/&gt;&lt;/jsp:useBean&gt; 这种只有找不到 JavaBean 对象的时候，才会新建对象并设置值。 &lt;jsp:getProperty&gt; 只有一种使用方法：&lt;jsp:getProperty name=&quot;JavaBean 对象实例名&quot;, property=&quot;JavaBean 对象属性名&quot;&gt; ，然后用 pageContext 的 findAttribute()依次查找。 表达式语言（EL）JSP 中一些简单的属性、请求参数、标头和 Cookie 等信息可以用 EL 来处理，更加简便。 EL 是使用 ${ 与 } 来包括要处理的表达式。EL 处理了null值的情况，对 null 值直接以空字符串显示，运算时不会因此发生错误而抛出异常。 由于某些时候网页使用了模板等有类似EL表达式的语法存在，可以设置 JSP 网页是否使用 EL. web.xml 中修改 123456789&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; page 指示元素的属性 isELIgnored (default: false) 如果在 page 中设置了属性，以 page 中的设置为主。 隐式对象EL 中，可以用 EL 隐式对象指定范围来存取属性。如果不指定属性的范围，以 page、request、session、application 的顺序依次查找。 EL 中有11个隐式对象，只有 pageContext 隐式对象对应 PageContext ，其他都对应 Map 类型 pageContext PageContext 本身是 JavaBean 对象，所以只要是 getXXX() 方法，就可以使用 ${pageContext.xxx} 来取得。也可以使用点运算符连续存取对象。 属性范围相关隐式对象 表示作用范围，pageScope, requestScope, sessionScope, applicationScope 分别可以取得使用对应 JSP 隐式对象的 setAttribute() 方法所设置的属性对象。 请求参数相关隐式对象：param 和 paramValues ${param.user} 想当于 &lt;%= request.getParameter(&quot;user&quot;)%&gt; paramValues 相当于 request.getParameterValues() ，因为返回的可能是多个值，可以用 [] 运算符指定取得的是那个元素。 标头相关隐式对象：header 和 headersValues， ${header[&quot;User-Agent&quot;]} reqest.getHeader(&quot;User-Agent&quot;) Cookie 隐式对象：cookie 用来取得用户 Cookie 设置值。 初始参数隐式对象：initParam 可以取得 web.xml 中设置的 ServletContext 初始参数 取得元素的方式可以用 . 和 [] 来取得属性中的元素： . 运算符：左边可以是 JavaBean 或 Map 对象（Map 建议用 [] 运算符） [] 运算符：左边可以是 JavaBean 属性，Map，数组或 List 对象 [] 在指定索引是使用双引号，就是作为键名或索引来使用，不加双引号会先尝试运算。 运算符 算数运算符：+, -, *(mod), /(div), %(mod), ? : 逻辑运算符：and, or, not 关系运算符：&lt;(lt), &gt;(gt), &lt;=(le), &gt;=(ge), ==(eq), !=(ne) 自定义函数第一步：编写类，公开类，且调用的方法是公开且为静态方法 第二步：编写 TLD（标签程序描述）文件（xml文件，以 .tld 为后缀），告诉容器如何将类中的方法作为 EL 函数 第三步：将文件放在 WEB-INF 文件夹下或 JAR 文件中]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5 Servlet 进阶API,过滤器与监听器]]></title>
    <url>%2Fposts%2Ffd419a6b%2F</url>
    <content type="text"><![CDATA[使用 ServletContext你可以把它想象成一个公用的空间，可以被所有的客户访问，也就是说A客户端可以访问D，B客户端可以访问D，C客户端也可以访问D。WEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext，它代表当前Web应用。并且它被所有客户端共享。ServletContext对象可以通过ServletConfig.getServletContext()方法获得对ServletContext对象的引用，也可以通过this.getServletContext()方法获得其对象的引用。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。公共聊天室就会用到它。当web应用关闭、Tomcat关闭或者Web应用reload的时候，ServletContext对象会被销毁作者：KLeonard来源：CSDN原文：https://blog.csdn.net/gavin_john/article/details/51399425版权声明：本文为博主原创文章，转载请附上博文链接！当整个Web应用程序加载Web容器后，容器会生成一个ServletContext对象作为整个应用程序的代表，可以通过ServletConfig的getServletContext()方法就可以取得ServletContext对象．ServletContext接口定义了运行Servlet的应用环境的一些行为，可以使用该接口的实现对象来取得所请求资源的URL，设置和存储属性，应用程序初始参数等．getRequestDispatcher()用来取得RequestDispatcher()实例，路径必须是绝对路径，即以＂/＂开头（代表应用程序根目录）．HttpServletRequest.getRequestDispatcher(String)既可以使用相对路径也可以使用绝对路径，但是实际上在实现时，如果是环境相对路径则直接委托给ServletContext的getServletContext()，如果是请求相对路径则转换为环境相对路径后，再委托．]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter4 会话管理基本原理]]></title>
    <url>%2Fposts%2Fb2e1ccaf%2F</url>
    <content type="text"><![CDATA[会话管理的基本原理Web应用程序中有些功能需要多次请求才能完成，所以需要某些方式来记得此次请求与之后请求之间的关系，这类方式称之为会话管理．会话管理的基本方式有：隐藏域（Hidden Field），Cookie，URL重写等使用隐藏域在HTTP协议中，服务器并没有记忆功能，那么可以让浏览器在每次请求时＂主动告知＂服务器多次请求间的必要信息，服务器只需单纯处理请求中的信息就好．隐藏域就是主动告知服务器多次请求间必要信息的方式之一．使用隐藏域的缺点：&emsp;&emsp;关掉网页后会丢失之前的信息，仅适合简单的状态管理，查看网页源码可以看到隐藏的信息，不适合用于隐秘性较高的数据．隐藏域不是Servlet/JSP实际管理会话时的机制，实现Web应用程序会话的基本原理是由浏览器主动告知必要的信息．使用 CookieCookie 是在浏览器存储信息的一种方式，服务器可以响应浏览器 set-cookie 标头，浏览器收到标头与数值后会以文件的形式存储在计算机上，即 Cookie.Cookie 可以设置存活期限．Servlet可以通过Cookie类的getMaxAge()方法获取Cookie的有效期；Servlet可以通过设置Cookie类的setMaxAge( int expiry );//expiry默认值为 -1；1.如果expiry大于0，则保存有效期为expire时间长度，单位毫秒；2.如果expiry等于0，则指示浏览器删除当前cookie；3.如果expiry小于0，则指示浏览器不保存该cookie到硬盘，就保存在内存中，浏览器关闭就消失；创建Cookie:12345Cookie cookie = new Cookie("user", "caterpillar");cookie.setMaxAge(7 * 24 * 60 * 60); // 以秒为单位// 创建cookie及其存活期限response.addCookie(cookie);// 将cookie加入响应之中获取Cookie12345678910111213Cookie[] cookies = request.getCookies();// 取得 Cookieif(cookies != null) &#123; for (Cookie cookie : cookies) &#123; String name = cookie.getName(); // 获取Cookie名称 String value = cookie.getValue(); // 获取Cookie数值 if ("user".equals(name) &amp;&amp; "caterpillar".equals(value)) &#123; request.setAttribute(name, value); request.getRequestDispatcher("/user.view").forward(request, response); return; &#125; &#125;&#125;Servlet 3.0 中，Cookie增加了setHttpOnly()方法，将Cookie标示为仅用于HTTP，如果浏览器支持，这个Cookie不会被客户端脚本读取，可以用isHttpOnly()方法判断是否被标示使用 URL 重写URL重写就是GET请求参数的应用，当服务器响应浏览器的上一次请求时，将某些相关信息以超链接的方式响应给浏览器，超链接包括请求参数信息．由于URL重写是在超链接之后附加信息，所以必须以GET方式发送请求．通常URL重写是用在一些简单的客户端信息保留，或者辅助会话管理．HttpSession 会话管理Servlet/JSP中会话管理的机制：HttpSession使用 HttpSession获得HttpSession实例：12345HttpSession session = request.getSession();// getSession()有两个版本// 另一个可以传入布尔值作为参数, // 默认为true，表示尚未存在HttpSession对象时, 直接创建一个新的对象// 如果是false，如不存在实例返回null默认在浏览器关闭前，HttpSession都是相同的实例，如果想要让目前的HttpSession失效可以调用HttpSession的invalidate()方法，执行这个方法后，容器会销毁回收HttpSession对象，再调用getSession()取得的对象是另一个新对象.设置与获得属性：setAttribute()：设置属性getAttribute()：获得属性HttpSession不是线程安全，需要注意属性设定的共享存取问题HttpSession 会话管理原理尝试运行HttpSession的getSession()方法时，Web容器会创建HttpSession对象，每个对象都有一个特殊的ID: Session ID，可以用HttpSession的getId()来取得Session ID，ID默认使用Cookie存储在浏览器中．HttpSession中存放的属性也存放在服务端的Web容器里，当浏览器请求应用程序时，会将Cookie中的Session ID 一同发送给应用程序里，Web容器会根据得到的ID找到对应的Session对象，这样就可以取得各浏览器的各自的会话数据．Web容器存储Session ID的Cookie默认设置当浏览器被关闭就失效，浏览器重新启动后由于ID失效，尝试getSession()后，容器会产生新的HttpSession对象，如果不使用invalidate()使对象立即失效，对象会等到设定的失效期间过后才会被销毁回收．设置HttpSession对象失效时间的方法：调用该对象的setMaxInactiveInterval()方法，设定浏览器多久没请求应用程序的话就自动失效，单位为秒；也可以在web.xml中修改，设定的单位是分钟123456&lt;web-app...&gt; ... &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt;HttpSession的属性中尽量不要存储耗资源的对象，必要时将属性移除（public void removeAttribute(String name)），或者让其失效．Servlet 3.0 中新增了SessonCookieConfig接口，可以通过ServleContext的getSessionCookieConfig()取得该接口的对象，通过这个接口的实现对象可以设定存储Session ID的Cookie相关的信息，设定必须在ServletContext初始化之前在web.xml中设定实现ServletContextListenerHttpSession 与 URL 重写因为HttpSession默认使用Cookie来存储ID，如果浏览器禁用Cookie，还想使用HttpSession来进行会话管理的话，可以搭配URL重写，向浏览器响应一段超链接，超链接URL附加上Session ID，单击超链接后将Session ID以GET请求发送给Web应用程序．如果要使用URL重写的方式发送Session ID，可以使用HttpServletResponse的encodeURL()协助产生需要的URL，如果Cookie可用，将URL本身输出，如果不可以会自动产生带有Session ID的URL重写．]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter3 请求与响应]]></title>
    <url>%2Fposts%2F2b70cf0d%2F</url>
    <content type="text"><![CDATA[从容器到 HttpServletweb 容器做了什么当浏览器请求来到HTTP服务器, HTTP服务器转交给容器, 容器会创建一个代表本次请求的HttpServlet对象, 并传给请求的相关信息, 同时会创建一个HttpServletResponse对象, 作为稍后要对客户端进行响应的Java对象.然后, 容器会根据@WebServlet标注或web.xml的设置, 找到处理该请求的Servlet, 调用它的service()方法, 传入容器在之前所创建的两个对象, 在service()方法中会根据HTTP请求的方式来调用对应的doXXX()方法.最后容器将HttpServletRequest对象和HttpServletResponse对象销毁回收, 结束本次响应.doXXX() 方法Servlet接口的service()方法中, 实际接受的参数是ServletRequest, ServletResponse, 在定义Servlet时, 期待Servlet不止用于HTTP, 与HTTP相关的行为由两者的子接口HttpServletRequest, HttpServletResponse 定义.关于 HttpServletRequest处理请求参数与标头HttpServletRequest中定义了取得通用请求信息的方法getParameter(): 指定请求参数名称来取得对应的值1String username = request.getParameter("name");返回String对象, 如果请求中没有指定的参数名称, 返回nullgetParameterValues(): 若同一个请求参数名称有多个值, 可以使用这个方法1String[] values = request.getParameterValues("param");返回一个存储了参数的值的String数组getParameterNames(): 获取请求中所有的请求参数名称, 返回Enumeration对象12345Enumeration&lt;String&gt; e = req.getParameterNames();while (e.hasMoreElements()) &#123; String name = e.nextElement(); // ...&#125;getParameterMap(): 将请求参数以Map对象返回, 键为请求参数名(String), 值为请求参数值(String[])获取HTTP标头信息getHeader(): 与getParameter()类似, 指定标头名称返回标头信息getHeaders(): 与getParameterValues()类似, 指定标头名称返回Enumeration对象, 元素为字符串getHeaderName(): 与getParameterNames()类似, 取得所有标头名称, 返回Enumeration请求参数编码处理POST如果客户端没有在 Content-Type 标头中设置字符编码, 使用HttpSerletRequest的getCharacterEncoding()返回值是null可以使用HttpServletRequest的setCharacterEncoding()方法指定取得POST请求参数时使用的编码, 只有在取得参数前执行才有用.GET如果是GET, 上述的方法设置编码无用.另一种处理编码的方式: 通过String 的 getBytes()指定编码来取得字符串的字节数组, 然后再重新构造为正确编码的字符串.1234String name = req.getParameter("name");// 假设浏览器使用UTF-8, web容器使用ISO-8859-1name = new String(name.getBytes("ISO-8859-1"), "UTF-8");// public String(byte[] bytes, String charsetName);Tomcat8URI默认编码为“UTF-8”，而Tomcat7URI默认编码为“ISO-8859-1”原书为繁体, 如果要使结果正常需要使用Tomcat7环境, form-get.html, form-post.html两个网页用繁体(编码为Big5), 或者简体(编码为GBK)参考资料: (转)Java 正确的做字符串编码转换那么，如何利用getBytes 和 new String() 来进行编码转换呢？ 网上流传着一种错误的方法:GBK–&gt; UTF-8: new String( s.getBytes(“GBK”) , “UTF-8); ,这种方式是完全错误的，因为getBytes 的编码与 UTF-8 不一致，肯定是乱码。但是为什么在tomcat 下，使用 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 却可以用呢？ 答案是：tomcat 默认使用iso-8859-1编码， 也就是说，如果原本字符串是GBK的，tomcat传输过程中，将GBK转成iso-8859-1了，默认情况下，使用iso-8859-1读取中文肯定是有问题的，那么我们需要将iso-8859-1 再转成GBK， 而iso-8859-1 是单字节编码的，即他认为一个字节是一个字符， 那么这种转换不会对原来的字节数组做任何改变，因为字节数组本来就是由单个字节组成的，如果之前用GBK编码，那么转成iso-8859-1后编码内容完全没变， 则 s.getBytes(“iso-8859-1”) 实际上还是原来GBK的编码内容则 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 就可以正确解码了。 所以说这是一种巧合。getReader(), getInputStream() 读取 Body 内容HttpServletRequest上有getReader()方法, 可以取得BufferedReader对象, 通过这个对象可以读取请求的 Body 数据.12345678910private String readBody(HttpServletRequest request) throws IOException &#123; BufferedReader reader = request.getReader(); // 取得 BufferedReader 对象, 通过该对象可以读取请求的 Body 数据 String input = null; String requestBody = ""; while ((input = reader.readLine()) != null) &#123; requestBody = requestBody + input + "&lt;br&gt;"; &#125; return requestBody;&#125;输出:1user=%E5%BC%A0%E4%B8%89&amp;passed=1234567&amp;login=%E9%80%81%E5%87%BA如果要上传文件, \&lt;form> 标签需要设置enctype属性为: multipart/form-datagetPart() , getParts() 取得上传文件在Servlet3.0之后, 新增了Part接口, 可以方便的进行文件上传处理, 可以通过HttpServletRequest的getPart()方法并指定名称才能取得Part实现对象.Servlet中要设置@MultipartConfig标注才能取得Part对象, 否则会得到null, 仅仅标注@MultipartConfig表示相关属性使用默认值:fileSizeThreshold: 0整数值, 若上传文件大小超过设置的值, 会先写入缓存文件loaction: 空字符串 “”设置写入文件时的目录maxFileSize: -1L 不限制大小限制上传文件的大小maxRequestSize: -1L 不限制请求个数限制 multipart/form-data请求个数也可以使用getParts()来上传多个文件, 该方法返回一个Collection&lt;Part&gt;123456789// ... for (Part part : req.getParts()) &#123; if(part.getName().startsWith("file")) &#123; // 使用getName()获取名称, startsWith()判断名称是否以file开头 String filename= getFilename(part); part.write(filename); &#125; &#125;// ...在 web.xml 中也可以设置@MultipartConfig属性:123456789...&lt;servlet&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;UploadServlet&lt;/servlet-class&gt; &lt;multipart-config&gt; &lt;location&gt;/tmp/&lt;/location&gt; &lt;/multipart-config&gt;&lt;/servlet&gt;...使用 RequestDispatcher 调派请求在 Web 应用程序中, 经常需要多个 Servlet 来完成请求, 这时可以使用HttpServletRequest的getRequestDispatcher()方法取得RequestDispatcher接口的实例, 调用时只需指定转发或包含相对的URL网址.使用 include() 方法RequestDispatcher 的 include() 方法可以将另一个 Servlet 的操作流程包括至目前 Servlet 操作流程之中.12RequestDispatcher dispatcher = req.getRequestDispatcher("other.view");dispatcher.include(req, resp);在取得RequestDispatcher时也可以包括查询字符串, ...(&quot;other.view?data=123456&quot;);请求范围属性在include()或forward()时如果包括请求参数的做法只适用于传递字符串给另一个Servlet, 在调派请求中, 如果有必须共享的对象, 可以设置请求范围属性HttpServletRequest上与请求范围属性有关的方法:setAttribute(): 指定名称与对象设置属性getAttribute(): 指定名称取得属性getAttributeNames(): 取得所有属性名称remoteAttribute(): 指定名称移除属性以java., javax.开头的名称通常保留, 用于表示一些特定的意义:javax.servlet.include.request_urijavax.servlet.include.context_pathjavax.servlet.include.servlet_pathjavax.servlet.include.path_infojavax.servlet.include.query_string在被包含的 Servlet 中分别表示上一个 Servlet 的 Request URI, Context path, Servlet path, Path info 和取得RequestDispatcher时给定的参数使用 forward() 方法调用时同样也要传入请求和响应对象, 表示要将请求处理转发给别的 Servlet , 对客户端的响应同时转发给另一个 Servlet如果要调用forward()方法, 当前的Servlet中不能有任何响应确认, 如果通过响应对象设置了响应但未确认, 响应设置会全部被忽略, 如果有响应确认了仍调用这个方法, 会抛出IllegalStateException]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter2 编写与设置Servlet]]></title>
    <url>%2Fposts%2F92aa08ef%2F</url>
    <content type="text"><![CDATA[在 HelloServlet 之后关于 HttpServletServlet 需要的包：1234567// 与 Servlet 定义相关的类或接口都位于 javax.servlet 包中// 与 HTTP 定义先关的类与接口都位于 javax.servlet.http 包中import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletRequest;当请求到来时，Web容器会调用 Servlet 的 service() 方法．HttpServlet 的 service() 方法的流程：123456789101112protected void servlet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); // 取得请求的方法 if (method.equals(METHOD_GET)) &#123; // ... doGet(req, resp); // ... &#125; else if (method.equals(METHOD_HEAD)) &#123; // ... doHead(req, resp); // ... &#125; else ...&#125;使用@WebServlet在Servlet3.0中，可以使用标注来告诉容器哪些Servlet会提供服务和额外的信息.123@WebServlet("/hello.view")public class HelloServlet extends HttpServlet &#123;// 告诉容器请求的URL如果是＂/hello.view＂，就由 HelloServlet 的实例来提供服务1234567891011@WebServlet( name = "Hello", // 告诉容器这个 Servlet 的名称为 Hello, 默认为 Servlet 类的完整名称 urlPatterns = &#123;"/hello.view"&#125;, // 如果客户端的请求的URL是/hello.view，由这个Servlet的实例来处理 loadOnStartup = 1 // 默认值: -1 // 容器在首次处理某个Servlet服务时才会初始化对应的Servlet实例， // 如果希望应用程序启动时就将Servlet类载入, 实例化并初始化 // 可以用loadOnStartup设置为大于0的值, 数字小的初始化, 相同的值由容器自定义行为)使用Web.xmlServlet3.0 之前, 必须通过web.xml来定义Servlet的相关信息, Servlet3.0中也可以用他来定义相关的信息.web.xml 中的设置会覆盖 Servlet 中定义的值（name 值要相同）.123456789101112131415&lt;!--...--&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--名字--&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;!--Servlet 是 servlet-class 指定类的实例--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!--设置何时初始化, 值相同按照在web.xml中设置的顺序初始化--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloUser.view&lt;/url-pattern&gt; &lt;!--如果客户端请求的URL是/helloUser.view, 则由HelloServlet这个Servlet来处理--&gt; &lt;/servlet-mapping&gt;&lt;!--...--&gt;文件组织与部署Web程序应用程序文件组织:123456789├── other│ └── \......└── web ├── index.jsp └── WEB-INF ├── classes │ └── HelloServlet.class ├── lib └── web.xmlWEB-INF: 目录名称固定, 该目录对外界封闭, 客户端无法使用HTTP的任何方式直接访问该目录下的文件及目录web.xml: 放在WEB-INF根目录下, 名称固定, Web应用程序部署描述文件lib: 放置JAR文件的目录, 放在WEB-INF根目录下, 名称固定classes: 放置编译后的.class文件的目录, 位于WEB_INF根目录下, 名称固定, 编译后的类文件, 必须有与包名称相符的目录结构在部署Web应用程序时, 会将Web应用程序封装为WAR文件, 如过服务器使用Tomcat, 可以将war文件放置在tomcat安装目录的webapps目录中, 然后重启Tomcat服务.然后可以用: http://(服务器ip或域名):(端口号)/(war文件名)/ 来访问进阶部署设置…]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程初探]]></title>
    <url>%2Fposts%2F906de7a0%2F</url>
    <content type="text"><![CDATA[[1] 线程线程线程是计算机独立运行(操作系统分配CPU时间的基本单位)的最小单位，运行时占用很少的系统资源单cpu单核：多个线程是交替执行的 多cpu多核：多个线程可以同时运行同一进程内的多个线程共享进程的地址空间线程之间的切换速度比进程的切换快很多进程通信要以专门的通信方式、一个线程的数据可以直接供同一进程的其他线程使用线程节约资源、节约时间、可以提高应用程序的响应速度、可以提高多处理器效率、改善程序的结构线程在进程内部共享的资源：地址空间、打开的文件描述符等待线程的私有数据：线程号寄存器（程序计数器、堆栈指针）栈信号掩码优先级私有的存储空间自己的错误返回码线程有自己的栈但是共享 堆(heap)We talked about the two types of memory available to a process or a thread, the stack and the heap. It is important to distinguish between these two types of process memory because each thread will have its own stack, but all the threads in a process will share the heap.——————————————— What’s the Diff: Programs, Processes, and ThreadsA thread in execution works withthread IDRegisters (program counter and working register set)Stack (for procedure call parameters, local variables etc.)A thread shares with other threads a process’s (to which it belongs to)Code sectionData section (static + heap)PermissionsOther resources (e.g. files)来源2关于线程的具体信息可以看这篇博客 Linux 线程的实质[2] 创建线程在主线程里创建线程后，程序会在创建线程的地方产生分支，变成两个程序来执行，一段代码可以被多个线程执行，线程在地位上是同等的，不存在父线程和子线程的概念创建线程的函数：123#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);参数意义：thread : 指向线程标识符的指针attr : 可指定线程的属性，如过是NULL则为默认属性start_routinez : 是一个函数指针，指向线程创建后要运行的函数，称为线程函数arg : 指向要传递给线程函数的参数返回值：线程创建成功返回0失败则返回出错编号其他的系统调用：12345678#include &lt;pthread.h&gt;pthread_t pthread_self(void); // 获取本线程的线程IDint pthread_equal(pthread_t t1, pthread_t t2); // 比较线程ID// 如果两个线程为同一线程返回非0值，否则返回0int pthread_once(pthread_once_t *once_control,void (*init_routine)(void)); // 保证线程函数只执行一次pthread_once_t once_control = PTHREAD_ONCE_INIT;// 成功完成后，pthread_once（）将返回零; 否则，返回错误编号以指示错误。[实例1]12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;int * thread(void * arg)&#123; pthread_t newthid; newthid = pthread_self(); // 返回新创建线程的ID printf("this is a new thread, thread ID = %u\n", newthid); return NULL;&#125;int main(int argc, char const *argv[])&#123; pthread_t thid; printf("main thread, ID is %u\n", pthread_self()); // 打印主线程ID if (pthread_create(&amp;thid, NULL, (void *)thread, NULL) != 0) // 创建一个线程, 创建成功返回 0 &#123; printf("thread creation failed\n"); exit(1); &#125; sleep(1); return 0;&#125;编译时需要链接 libpthread.a , gcc createthread.c -lpthread在某些情况，只需要执行一次函数，这时就需要用到 pthread_once()函数原型中的控制变量once_control必须初始化为 PTHREAD_ONCE_INIT(0), 否则线程函数不会执行123/* This is similar to a lock implementation, but we distinguish between three states: not yet initialized (0), initialization in progress, and initialization finished; If in the first state, threads will try to run the initialization by moving to the second state; the first thread to do so via a CAS on once_control runs init_routine, other threads block.*/[实例2]12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;pthread_once_t once = PTHREAD_ONCE_INIT;// 使用初值为PTHREAD_ONCE_INIT的once_control变量保证// 函数在本进程执行序列中仅执行一次。void run(void)&#123; printf("Function run is running in thread %u\n", pthread_self());&#125;void * thread1(void * arg)&#123; pthread_t thid = pthread_self(); printf("Current thread's ID is %u\n", thid); pthread_once(&amp;once, run); printf("thread1 ends\n");&#125;void * thread2(void * arg)&#123; pthread_t thid = pthread_self(); printf("Current thread's ID is %u\n", thid); pthread_once(&amp;once, run); printf("thread2 ends\n");&#125;int main()&#123; pthread_t thid1, thid2; pthread_create(&amp;thid1, NULL, thread1, NULL); pthread_create(&amp;thid2, NULL, thread2, NULL); sleep(3); printf("main thread exit!\n"); exit(0);&#125;在多线程编程环境下，如果pthread_once()调用出现在多个线程中，init_routine()函数仅执行一次，但究竟在哪个线程中执行是由内核调度来决定的。两种情况：线程属性线程创建函数的第二个参数的类型为: pthread_attr_t, 结构体定义为:123456789101112typedef struct&#123; int detachstate; // 线程的分离状态 int schedpolicy; // 线程的调度策略 int schedparam; // 线程的调度参数 int inheritsched; // 线程的继承性 int scope; // 线程的作用域 int guardsize; // 线程栈末尾的警戒缓冲区大小 int stackaddr_set; // 堆栈地址集 int stackaddr; // 堆栈的大小 int stacksize; // 堆栈的大小&#125;pthread_attr_t;如果第二个参数为空，线程会采用默认的属性，绝大多数情况下不需要为线程特殊指定其属性。线程的属性只能在线程创建的时候指定，线程创建完成之后其属性不能被更改。默认属性:属性值结果scopePTHREAD_SCOPE_PROCESS新线程与进程中的其他线程发生竞争。detachstatePTHREAD_CREATE_JOINABLE线程退出后，保留完成状态和线程 ID。stackaddrNULL新线程具有系统分配的栈地址。stacksize0新线程具有系统定义的栈大小。priority0新线程的优先级为 0。inheritschedPTHREAD_INHERIT_SCHED新线程继承父线程调度优先级。schedpolicySCHED_OTHER新线程对同步对象争用使用 Solaris 定义的固定优先级。线程将一直运行，直到被抢占或者直到线程阻塞或停止为止。由于线程的属性是不透明的，所以不能直接修改，而需要使用一系列的函数来初始化、配置、销毁。参考资料：[1]Creating a (Default) Thread[2]多线程编程指南 &gt; 第 3 章 线程属性 &gt; 属性对象初始化/销毁线程属性1234567#include &lt;pthread.h&gt;pthread_attr_t tattr;int ret;/* initialize an attribute to the default value */ret = pthread_attr_init(&amp;tattr);int pthread_attr_destroy(pthread_attr_t *attr);// 如果成功会返回0, 失败返回非0的错误代码初始化线程属性的时候系统会给属性对象分配内存，为了避免内存泄漏，当线程属性不再使用后应当调用pthread_attr_destroy()来释放分配的内存，销毁线程属性并不会影响创建时候使用了该线程属性的线程。当线程属性被销毁之后可以重新初始化它，但对已销毁的线程属性对象的任何使用的结果都是未定义的。线程栈大小12int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);默认情况下由系统设定栈的大小，可以用命令来查看系统的默认设置 ulimit -s设置栈的大小不是可移植的线程分离属性1234// set/get detach state attribute in thread attributes objectint pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); // On success, these functions return 0; on error, they return a nonzero error number.pthread_attr_setdetachstate()中detachstate的值有两种：PTHREAD_CREATE_DETACHEDPTHREAD_CREATE_JOINABLE(默认属性)如果是PTHREAD_CREATE_JOINABLE，需要调用 pthread_join 或 pthread_detach来释放资源(线程的描述信息和stack)。调用pthread_detach的过程是不可逆的。可连接和分离的线程 | Joinable and Detached Threads线程栈溢出保护区大小12int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize); int pthread_attr_getguardsize(pthread_attr_t *attr, size_t *guardsize);当我们使用线程栈超过了设定大小之后，系统还会使用部分扩展内存(guardsize大小)来防止栈溢出。如果没有guardsize，当一个线程的栈溢出到其他的区域，该区域又是可写的，会造成不可预料的后果，而且覆盖了那部分内存之后也不会产生任何错误或者是信号。这种情况很难确定应该为栈分配多大的内存。当设置了guardsize之后，如果栈溢出后尝试写入这部分内存，会给进程发送信号并且终止它。What is guard size in Posix?线程竞争CPU的范围12int pthread_attr_getscope(const pthread_attr_t *attr,int *contentionscope); int pthread_attr_setscope(pthread_attr_t *attr, int contentionscope);POSIX 定义了两个值:PTHREAD_SCOPE_SYSTEM: 与系统中的所有线程一起竞争PTHREAD_SCOPE_PROCESS:只与同进程的线程竞争线程调度策略12int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy); int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);进程的调度策略和优先级属于主线程，设置进程的调度策略和优先级只会影响主线程的调度策略和优先级。每一个对等线程能够拥有它自己的独立于主线程的调度策略和优先级。在 Linux 系统中，进程有三种调度策略：SCHED_FIFO(实时、先入先出)、SCHED_RR(实时、轮转) 和 SCHED_OTHER（正常、非实时）（默认属性）。线程继承的调度策略12int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inheritsched); int pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched);在 pthread 库中，提供了一个函数，用来设置被创建的线程的调度属性：是从创建者线程继承调度属性（调度策略和优先级以及竞争范围），还是从属性对象设置调度属性。该函数就是：123456int pthread_attr_setinheritsched (pthread_attr_t * attr, int inherit) 当中，inherit 的值为下列值中的其一：enum&#123; PTHREAD_INHERIT_SCHED, //线程调度属性从创建者线程继承（默认属性） PTHREAD_EXPLICIT_SCHED //线程调度属性设置为 attr 设置的属性&#125;;假设在创建新的线程时，调用该函数将參数设置为 PTHREAD_INHERIT_SCHED 时，那么当改动进程的优先级时。该进程中继承这个优先级而且还没有改变其优先级的所有线程也将会跟着改变优先级。线程调度參数123456int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param); int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param); //sched_param结构体 struct sched_param &#123; int sched_priority; /* Scheduling priority */ &#125;;sched_priority 仅当调度策略为(SCHED_RR 或 SCHED_FIFO)时才有效，默认为0[3] 线程终止有两种终止线程的方式：通过 return 从线程返回调用函数 pthread_exit() 使线程退出pthread_exit()123// pthread_exit - terminate calling thread#include &lt;pthread.h&gt;void c(void *retval);两种特殊情况：如果从 main() 函数返回或调用了 exit 函数退出了主线程，则整个进程将会终止，进程终端所有线程也会终止，故主线程不能过早的从 main 函数返回。如果主线程调用了 pthread_exit 函数，仅仅是主线程消亡，进程不会结束，进程内的其他线程也不会结束直至所有的线程结束线程的取消线程可以创建也可以取消，一个线程可以向另一个线程发送结束请求，实现这种机制用到了一个函数：123// pthread_cancel - send a cancellation request to a thread#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);函数执行成功返回0,失败返回非零的错误码。函数执行成功并不意味着所要请求的线程会被取消，另一个线程接受到取消的请求后，具体行为依赖于线程的类型和状态(tyep and state)。线程的state和type可以通过下面两个函数来设置：123#include &lt;pthread.h&gt;int pthread_setcancelstate(int state, int *oldstate);int pthread_setcanceltype(int type, int *oldtype);stateenabled(默认)[PTHREAD_CANCEL_ENABLE]如果是这种状态，线程会取消，但何时取消依赖于type的值disabled[PTHREAD_CANCEL_DISABLE]线程会继续执行type:deferred(默认)[PTHREAD_CANCEL_DEFERRED]－－同步state如果为enabled，线程会继续执行，当遇到取消点的时候退出POSIX 标准规定了一些函数作为取消点，当线程调用这些函数的时候就会结束，具体函数可以查看 man 7 pthreadsasynchronous[PTHREAD_CANCEL_ASYNCHRONOUS]－异步state为enabled的情况下，type为这个值意味着线程可以在任何时候取消，当线程收到取消请求后，通常会立即退出临界资源的释放虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。 对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。临界资源在一段时间内只能被一个线程所持有，当线程要访问临界资源的时候需要提出请求，如果该资源没有被使用则申请成功，否则等待。临界资源使用完后需要释放以供其他线程使用。当一个线程终止时，如果不释放线程所占有的临界资源，则该资源还会被认为被使用中，如果另一个线程在等待使用这个临界资源，那它可能会无限等待下去，形成了死锁。Linux 系统提供了一对函数：pthread_cleanup_push()、pthread_cleanup_pop() 来自动释放资源，两个函数以宏定义提供，所以两个程序必须成对出现且位于同一代码段才能通过编译。pthread_cleanup_push()/pthread_cleanup_pop()采用先入后出的栈结构管理，void routine(void *arg)函数在调用pthread_cleanup_push()时压入清理函数栈，多次对pthread_cleanup_push()的调用将在清理函数栈中形成一个函数链，在执行该函数链时按照压栈的相反顺序弹出。execute参数表示执行到pthread_cleanup_pop()时是否在弹出清理函数的同时执行该函数，为0表示不执行，非0为执行；这个参数并不影响异常终止时清理函数的执行。如果线程处于PTHREAD_CANCEL_ASYNCHRONOUS状态，上述代码段就有可能出错，因为CANCEL事件有可能在pthread_cleanup_push()和pthread_mutex_lock()之间发生，或者在pthread_mutex_unlock()和pthread_cleanup_pop()之间发生，从而导致清理函数unlock一个并没有加锁的mutex变量，造成错误。因此，在使用清理函数的时候，都应该暂时设置成PTHREAD_CANCEL_DEFERRED模式。Posix线程编程指南(4)等待线程的结束函数pthread_join()用来等待线程的结束，其函数原型为：123// pthread_join - join with a terminated thread#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);pthread_join() 的调用者会被挂起睡眠，等待thread线程的结束，如果retval不为NULL，则这个值即为调用pthread_exit()的参数，如果线程是被取消的，retval的值是PTHREAD_CANCELED。测试了一下如果线程是return返回的话retval的值为0;一个线程只允许一个线程使用pthread_join来等待他的结束，否则第一个接收到的线程成功返回，其他调用这个函数的线程返回错误代码 ESRCH.thread 这个线程的状态必须是可join的。1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void assisthread(void * arg)&#123; printf("I am helping to do some jobs\n"); sleep(3); pthread_exit(0);&#125;int main(void)&#123; pthread_t assistthid; int status; pthread_create(&amp;assistthid, NULL, (void*) assisthread, NULL); pthread_join(assistthid, (void* )&amp;status); printf("assisthread's exit is caused %d\n", status); return 0;&#125;]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>Linux C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[readline库的简单使用]]></title>
    <url>%2Fposts%2F3faf94c3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这周要实现一个简单的 shell, 平时使用bash, zsh这些shell的时候, 如果文件名或命令太长，又或者要频繁执行几条命令的话，最常用的应该就是tab键补全和上下键切换历史命令了。&emsp;&emsp;想要在自己的shell里面实现这两个功能很困难，但有一个Ｃ语言库集成了这些功能，只需要调用几个函数就可以实现这两个功能。&emsp;&emsp;The GNU Readline Library&emsp;&emsp;可以在这里找到有关 readline 库的相关资料和下载地址，软件包里面也提供了很多手册和示例。&emsp;&emsp;实现shell用到的函数不是很多，tab键补全，上下键切换历史命令，添加历史命令等等readline()&emsp;&emsp;在 readline.h 里可以找到关于他的定义：123/* Readline functions. *//* Read a line of input. Prompt with PROMPT. A NULL PROMPT means none. */extern char *readline PARAMS((const char *));&nbsp;&nbsp;&nbsp;&nbsp;readline() 的参数是一个字符串，调用函数的时候会在屏幕上输出，这个函数会读取一行输入，然后返回一个指向输入字符串的指针，readline 会为输入的字符串动态分配内存，所以使用完之后需要free掉。&emsp;&emsp;下面举一个简单的例子1234567891011#include &lt;stdlib.h&gt;#include &lt;readline/readline.h&gt;int main(void)&#123; while (1) &#123; char * str = readline("Myshell $ "); free(str); &#125;&#125;&nbsp;&emsp;&emsp;由于readline是一个动态库，编译的时候需要加上 -lreadline，不然会找不到相关的函数当我们按下tab键之后发现就可以实现bash里面的补全功能了。&emsp;用惯了zsh后发现黑白的提示符好难看，于是也想着给里面的参数加上颜色。C语言中输出有颜色的字符printf就可以实现，模板类似这样printf(&quot;\033[47;31m string \033[0m&quot;);&emsp;&emsp;47是背景色，31是字符的颜色，string 是要输出的字符串，\033[5m 是ANSI控制码，意思是关闭输出的属性，不然以后的输出都会是之前设置的颜色。相关的内容网上有很多可以自行查阅。&emsp;&emsp;为了方便使用，加上了这些宏定义123#define CLOSE "\033[0m" // 关闭所有属性#define BLOD "\033[1m" // 强调、加粗、高亮#define BEGIN(x,y) "\033["#x";"#y"m" // x: 背景，y: 前景&emsp;&emsp;在修改一下readline()这个函数1char * str = readline(BEGIN(49, 34)"Myshell $ "CLOSE);&emsp;&emsp;然后编译运行：&emsp;&emsp;似乎一切完美，但当我们输入很长很长的字符串之后：&emsp;&emsp;&emsp;&emsp;emmmm……………输入太多会导致提示符被输入覆盖，写个shell出现这种状况岂不是贼尴尬&emsp;&emsp;查资料查了很久才找到解决方法：这个bug需要在非打印字符前后加上 \001 和 \002 才能解决&emsp;&emsp;其实头文件就有提到&emsp;&emsp;在之前定义的宏里面加上这两个字符之后终于解决了&emsp;&emsp;最后的代码为：12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;readline/readline.h&gt;#define CLOSE "\001\033[0m\002" // 关闭所有属性#define BLOD "\001\033[1m\002" // 强调、加粗、高亮#define BEGIN(x,y) "\001\033["#x";"#y"m\002" // x: 背景，y: 前景int main(void)&#123; while (1) &#123; char * str = readline(BEGIN(49, 34)"Myshell $ "CLOSE); free(str); &#125;&#125;&emsp;&emsp;readline使用的时候默认了tab补全，但是我们平时用到的shell不但可以补全文件名，还可以补全命令。readline库当然也提供了这个功能，具体如何使用可以看这篇博客。&emsp;&emsp;GNU Readline 库及编程简介&emsp;&emsp;单独的使用readline()并没有上下键切换补全的功能，实现这个需要用到另一个函数 - add_history()history.h&emsp;&emsp;上下键切换需要我们把输入的字符串加入到历史命令中，需要调用123/* Place STRING at the end of the history list. The associated data field (if any) is set to NULL. */extern void add_history PARAMS((const char *));&emsp;&emsp;函数接受一个字符串作为参数存入到历史文件中，函数的定义在history.h中，使用的时候需要包含头文件 &lt;readline/history.h&gt;&emsp;&emsp;我们在代码中加入这个函数的调用就可以使用上下键切换历史命令了123char * str = readline(BEGIN(49, 34)"Myshell $ "CLOSE);add_history(str);free(str);&emsp;&emsp;编译后测试了一下发现功能完美运行。&emsp;&emsp;但是关掉程序在尝试一下发现，诶？我不能切换到上一次运行程序的历史命令，只能记录本次运行中输入的命令。然后开始查看头文件的内容，发现了不少和history有关的函数。&emsp;&emsp;其中有两个正好用的上12345678/* Add the contents of FILENAME to the history list, a line at a time. If FILENAME is NULL, then read from ~/.history. Returns 0 if successful, or errno if not. */extern int read_history PARAMS((const char *));/* Write the current history to FILENAME. If FILENAME is NULL, then write the history list to ~/.history. Values returned are as in read_history (). */extern int write_history PARAMS((const char *));&emsp;&emsp;read_history()和write_history()都接受一个字符串做参数，成功返回０，错误则把相应的错误码赋值给errno。&emsp;&emsp;两个函数接受的参数都是一个文件名，read_history() 从指定的文件中读取历史记录，write_history() 将历史记录存入指定的文件。如果参数为NULL默认的文件是：~/.history&emsp;&emsp;有了这个函数，我们只要在程序最开处加上read_history(NULL), add_history(str)之后加上 write_history() 就可以了。&emsp;&emsp;这样下次运行程序的时候我们就可以找到上次运行的历史命令了。&emsp;&emsp;shell 的内置命令不多，cd 是一个, history也是一个shell内置的命令。&emsp;&emsp;readline既然可以把输入加入历史，读入和写进历史，那么自然可以读取历史文件列表，头文件中我们可以找到这样一个函数：12/* Return a NULL terminated array of HIST_ENTRY which is the current input history. Element 0 of this list is the beginning of time. If there is no history, return NULL. */extern HIST_ENTRY **history_list PARAMS((void));&emsp;&emsp;这个函数可以查看存储的 history 列表，HIST_ENTRY 是一个结构体类型，存储了很多信息：&emsp;&emsp;&emsp;&emsp;我们要的历史内容就存储在 data 元素里面。&emsp;&emsp;这个函数返回一个数组，以空指针为结束标志，我们简单封装一下就可以实现一个自己 shell 内置的 history 函数了。1234567891011void ShowHistory()&#123; int i = 0; HIST_ENTRY ** his; his = history_list(); while(his[i] != NULL) &#123; printf("%s\n", his[i]-&gt;line); i++; &#125;&#125;&emsp;&emsp;history.h 里面提供了很多函数，我们的要实现一个简单的shell用到的函数上面都提到过，更多的函数可以在官方文档里面查看。&emsp;&emsp;realine 这个库很强大，现在只是发现了他的冰山一角，提供的功能远远超过上述所说的。]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>readline</tag>
        <tag>Linux C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现简单ls命令遇到问题的总结]]></title>
    <url>%2Fposts%2Fe262bfcf%2F</url>
    <content type="text"><![CDATA[这周要写一个小项目，利用《linux C 编程实战》第6章的内容实现一个简单的 ls 命令，写的时候出现很多问题，现在将问题总结一下。要实现的ls命令需要实现 -l, -a , -A 等参数。我们在终端测试一下系统的ls命令:可以发现系统的ls可以根据终端的宽度来调整输出列数，而不至于输出的内容由于终端大小的限制显示不全。如果想要实现类似的功能，首先需要获取终端的宽度，然后计算输出文件列表的最大列数，最后按列将文件输出到屏幕上。终端宽度的获取查了很多，发现书上提到的 int ioctl(int fd, int cmd, ...)可以实现这个功能, 先放出代码：1234567// 获取终端宽度int get_ter_size (void)&#123; struct winsize w; ioctl(STDOUT_FILENO, TIOCGWINSZ, &amp;w); return w.ws_col;&#125;ioctl 可以控制特殊设备文件的属性，第一个参数是一个以及打开的文件描述符，STDOUT_FILENO 是标准输出的POSIX 名称，他的文件描述符是1，可以在 unistd.h 找到它的宏定义。使用man 2 ioctl_tty 可以查询到其他两个参数的信息：TIOCGWINSZ 是一个获取终端大小的命令，w是一个struct winsize ，其中的 w.ws_col 就存储了我们想得到的终端宽度。计算输出列表的最大列数没想出来有什么比较好的方法来通过已经给定的一系列字符串和一个限制宽度来求出在这个宽度限制内输出的最大列数。所以最后决定暴力穷举，将列数从大到小一个一个的尝试。12345678910111213141516171819202122232425262728293031323334353637int Cal_Print(char b[][NAME_MAX + 10], int a[], int n) // 暴力运算, 求出打印的列数&#123; // b 是一个二维数组，存储了要计算宽度的文件名 int t = get_ter_size(); // 终端宽度 int i = n &lt; MAX_C ? n : MAX_C; // 设定最大列数初始值 int length; // 计算字符串长度 for (int j = 0; j &lt; n; j++) a[j] = strlen(b[j]); for (; i &gt;= 1; i--) &#123; int c = n % i ? (n / i + 1) : (n / i); if ((i - 1) * c &gt;= n) continue; length = 0; int max_len[MAX_C] = &#123;0&#125;; for (int j = 0; j &lt; i; j++) &#123; int k = j * c; for (int m = 0; m &lt; c &amp;&amp; k &lt; n; m++, k++) if (a[k] &gt; max_len[j]) max_len[j] = a[k]; length += max_len[j]; if (j != i - 1) length += 2; &#125; if (length &lt; t) return i; i--; &#125; if (!i) i = 1; return i;&#125;得到终端宽度后，在代码中我限制了最大宽度为25(MAX_C), 这个数差不多足够了，之后如果文件的总数小于最大宽度，那么就从文件的总数n开始穷举（毕竟最多也就一个文件名放一列）。有了总数n和列i之后，很简单就能计算出行。计算每一列字符串最大的长度后加起来，再算上分割列之间的 （i-1)×2 的空格，如果总长度不大于终端宽度，这个列数就是我们所需要的。计算完行数之后还会有一个问题，我们是为了解决在终端中按行打印文件名的问题，打印出来的结果只有最后一列可以空几个文件名，也就是要保证除了最后一列其他列都要填满。所以加上一个判断条件：if ((i - 1) * c &gt;= n) continue;在计算 max_len[j] 一定要注意加上 k &lt; n 这个条件，不然如果在 i * c &gt; n 的情况下数组会越界。还有一种极端情况：终端宽度太小，导致最后算出的 i 值为0, 这种情况就讲i的值设为1，默认输出一列。按列输出由于要以整齐的方式按列输出 需要我们之前计算过的字符串长度，为了方便我们直接在计算完列数之后就输出文件目录：1234567891011121314151617int kneed = c - i * c + n; // 最后一列的行数for (int p = 0; p &lt; c; p++) // c 行数&#123; for (int o = 0; o &lt; i - 1; o++) // i 列数 先输出前 i-1 列 &#123; printf("%s", b[p + o*c]); PrintB(max_len[o] - a[p + o*c]); PrintB(2); // 输出空格以整齐排列 &#125; if (kneed) // 如果最后一列的第p行有内容就输出 &#123; printf("%s", b[p + (i-1) * c]); kneed--; &#125; printf("\n");&#125;break;代码中我用了PrintB(int num)来输出空格， 也可以简单一点使用printf 的 * 修饰符来控制格式printf(&quot;%s%*s&quot;, b[p + o*c], max_len[o] - a[p + o*c] + 2, &quot; &quot;);最开始以为这么弄就应该没问题了，也测试过输出格式，但是emmmm…..如果文件名里面有中文的话，strlen会把中文识别为3个字节，但是一个中文其实差不多只占两个，如果文件名有中文的话会导致很严重的排版错误。。。。具体可以看一下这两篇博客：https://whoisnian.com/2018/01/24/Linux%E4%B8%8Bls%E5%91%BD%E4%BB%A4%E6%8E%92%E7%89%88/http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.htmlUTF-8 的编码规则很简单，只有二条：1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。1234567891011121314151617181920212223// 代码来自 https://whoisnian.com/2018/01/24/Linux%E4%B8%8Bls%E5%91%BD%E4%BB%A4%E6%8E%92%E7%89%88/int Str_UTF(char * str) // 只占两个宽度的中文字符会识别为三个字节&#123; int num = 0, i; while (*str != '\0') &#123; if (*str &gt; 0) // 如果是单字节符号(这里指 英文符号)，正常计算长度 &#123; num++; str++; &#125; else &#123; // n字节的符号（n &gt; 1），第一个字节的前n位都设为1 for (i = 7; i &gt;= 0; i--) if (!((*str &gt;&gt; i) &amp; 1)) // 右移运算，把第 n+1 位上的０恰好移到 这个字节的最后一位，第7 ~ i+1次, 最后一位会是１ break; num += 2; // 中文按两个字节算 str += 7 - i; // 跳过这个中文符号(占用7-i个字节) &#125; &#125; return num;&#125;手写一个strlen之后就可以正常显示了。在这里也吐槽下中文字符排序的问题，以前一直认为中文排序可以用strcmp来解决，这次写ls命令测试发现中文的编码比较乱，而且涉及到多音字的问题，中文的排序比较复杂，不是直接比较编码就能搞定的。写 ls -R 时关于递归的问题最开始在实现 -R 参数的时候用了递归，其中解析文件属性用了 stat() 函数。但是在测试递归主目录的时候发现了一个很严重的问题，平时用 stat 和 lstat 的区别就是在链接文件的识别上，一个识别链接文件指向的文件，另一个是链接文件本身。我的主目录下有一个文件夹：/home/username/.deepinwine/Deepin-TIM/dosdevices查看具体属性后：lrwxrwxrwx 1 username username 1 7月 26 19:28 z: -&gt; /emm… 这个文件是指向系统根目录的，如果递归到这个文件会出现无限死循环。。。。当然递归时候也需要注意跳过. 和 .. 这两个特殊目录。。不然也会出现无限递归死循环的问题。]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>Linux C</tag>
      </tags>
  </entry>
</search>
