<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot之Web开发]]></title>
    <url>%2Fposts%2Fd16715c9%2F</url>
    <content type="text"><![CDATA[使用 SpringBoot：创建 SpringBoot 应用，选中需要的模块SpringBoot 默认将这些场景自动配置好，只需要在配置文件中指定少量配置自己编写业务逻辑代码SpringBoot 对静态资源的映射规则1234// org/springframework/boot/autoconfigure/web/ResourceProperties.java@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties &#123; // 可以设置与静态资源有关的设置，例如缓冲时间等1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration.java@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler("/webjars/**") .addResourceLocations("classpath:/META-INF/resources/webjars/") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125;// 配置首页@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext) &#123; return new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern());&#125;// 配置喜欢的图标@Configuration@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)public static class FaviconConfiguration implements ResourceLoaderAware &#123; private final ResourceProperties resourceProperties; private ResourceLoader resourceLoader; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); // 在静态文件夹中寻找 mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler.setLocations(resolveFaviconLocations()); return requestHandler; &#125; private List&lt;Resource&gt; resolveFaviconLocations() &#123; String[] staticLocations = getResourceLocations(this.resourceProperties.getStaticLocations()); List&lt;Resource&gt; locations = new ArrayList&lt;&gt;(staticLocations.length + 1); Arrays.stream(staticLocations).map(this.resourceLoader::getResource).forEach(locations::add); locations.add(new ClassPathResource("/")); return Collections.unmodifiableList(locations); &#125;所有 /webjars/**，都去 classpath:/META-INF/resources/webjars/ 找资源；webjars：以 jar 包的方式引入静态资源；在 webjars 这个网站上可以使用 maven 导入常用 js 库的 webjar12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;“/**” 访问当前项目的任何资源，对应classpath:/META-INF/resources/classpath:/resources/classpath:/static/classpath:/public//：当前项目根路径12345678910public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; "classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/" &#125;; /** * Locations of static resources. Defaults to classpath:[/META-INF/resources/, * /resources/, /static/, /public/]. */ private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;欢迎页面的映射页面图标映射（可能需要清除浏览器缓存 - Chrome 插件或者 Shift+F5）需要放在映射路径的根目录下才可以。By default, resources are mapped on /**, but you can tune that with the spring.mvc.static-path-pattern property. For instance, relocating all resources to /resources/** can be achieved as follows:1spring.mvc.static-path-pattern=/resources/**You can also customize the static resource locations by using the spring.resources.static-locations property (replacing the default values with a list of directory locations). The root Servlet context path, &quot;/&quot;, is automatically added as a location as well.In addition to the “standard” static resource locations mentioned earlier, a special case is made for Webjars content. Any resources with a path in/webjars/** are served from jar files if they are packaged in the Webjars format.Do not use the src/main/webapp directory if your application is packaged as a jar. Although this directory is a common standard, it works only with war packaging, and it is silently ignored by most build tools if you generate a jar.模板引擎Jsp、Thymeleaf、Velocity、Freemarker …SpringBoot 如果以 jar 的形式打包，而且由于 SpringBoot 使用的是内嵌的 Tomcat ，所以 SpringBoot 推荐使用 Thymeleaf.引入Thymeleafpom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;Thymeleaf 语法自动配置的默认规则：12345678@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html";只要把 html 放在 classpath:/templates/ 后，Thymeleaf 就会自动渲染。使用：导入 thymeleaf 名称空间：1&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt;使用语法123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;SUCCESS&lt;/h1&gt; &lt;!-- 将 div 的内容设置为... --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎数据&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;语法规则th:text 改变当前元素里面的文本内容th: 任意 html 属性，来替换原生属性的值对应的行内写法：th:text =&gt; [[]]th:utext =&gt; [()]表达式Simple expressions:（表达式语法）Variable Expressions: ${...}获取对象的属性，调用方法使用内置的基本对象#ctx : the context object.#vars: the context variables.#locale : the context locale.#request : (only in Web Contexts) the HttpServletRequest object.#response : (only in Web Contexts) the HttpServletResponse object.#session : (only in Web Contexts) the HttpSession object.#servletContext : (only in Web Contexts) the ServletContext object.使用内置的工具对象#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).Selection Variable Expressions:*{...}（选择表达式）和#{} 功能相同，补充使用：配置 th:object 使用，可以直接引用 th:object 的属性Message Expressions: #{...}获取国际化内容Link URL Expressions: @{...}定义 url，里面可以使用变量等值Fragment Expressions: ~{...}片段引用表达式Literals（字面量）Text literals: ‘one text’ , ‘Another one!’ ,…Number literals: 0 , 34 , 3.0 , 12.3 ,…Boolean literals: true , falseNull literal: nullLiteral tokens: one , sometext , main ,…Text operations:（文本操作）String concatenation: +Literal substitutions: |The name is ${name}|Arithmetic operations:（数学运算）Binary operators: + , - , * , / , %Minus sign (unary operator): -Boolean operations:（布尔运算）Binary operators: and , orBoolean negation (unary operator): ! , notComparisons and equality:（比较运算）Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )Equality operators: == , != ( eq , ne )Conditional operators:（条件运算）If-then: (if) ? (then)If-then-else: (if) ? (then) : (else)Default: (value) ?: (defaultvalue)Special tokens:Page 17 of 104No-Operation: _]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之日志]]></title>
    <url>%2Fposts%2F18e9d6ab%2F</url>
    <content type="text"><![CDATA[日志框架日志门面：日志的一个抽象层市面上的日志框架：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…**日志门面日志实现JCL（久不更新）、SLF4j、jboss-logging（不适用于普通人群）Log4j、JUL（Java 自带）、log4j2（框架好但是有些尚未适配）、Logback（与Log4j是同一个作者）左边选一个门面（抽象层），右边选一个实现；SpringBoot ：底层为 Spring框架默认选择 JCL、而 SpringBoot 选择 SLF4j、logbackSLF4j 的使用如何使用在开发时，不应直接调用日志的实现类，而是应该调用日志的抽象层的方法。导入 SLF4j 的 jar 和 logback 的 jar123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125;图示：每一个日志的实现框架都有自己的配置文件，使用 SLF4j后，配置还是做成日志实现框架的自己的配置文件。遗留问题A（SLF4j + logback）：Spring 、Hibernate、MyBatis、….. A 系统的依赖使用了其他的日志框架统一日志记录，即使是别的框架也统一使用 SLF4j 输出如何让系统中所有的日志都统一到slf4j：将系统中其他日志框架先排除出去用中间包来替换原有的日志框架导入 slf4j 其他的实现SpringBoot 与日志的关系SpringBoot 使用日志功能123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;底层依赖关系：总结：SpringBoot 底层也是使用 slf4j + logback 的方式进行日志记录的SpringBoot 把其他的日志都替换为了 slf4jMaven 排除 jar 包的方法：12345678910111213&lt;dependency&gt; &lt;groupId&gt;sample.ProjectB&lt;/groupId&gt; &lt;artifactId&gt;Project-B&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;!-- declare the exclusion here --&gt; &lt;groupId&gt;sample.ProjectC&lt;/groupId&gt; &lt;artifactId&gt;Project-C&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;!-- ... --&gt; &lt;/exclusions&gt; &lt;/dependency&gt;也可以在 idea 的 maven 依赖树里面选中不需要的依赖，右键选择 删除日志使用LogBack入门实践12345678910111213141516171819// 记录器 private Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; // 日志的级别，由低到高 ------------------- // 可以调整输出的日志的级别；日志就只会在这个级别的以后的高级别生效 // 跟踪轨迹 logger.trace("这是 trace 日志..."); // 调试信息 logger.debug("这是 debug 日志..."); // SpringBoot 默认只会输出 info 级别：root 级别 // info logger.info("这是 info 日志..."); // warning logger.warn("这是 warning 日志..."); // error logger.error("这是 error 日志..."); &#125;1234567891011logging.level.com.xuanc=trace# =========== logging.path 与 logging.file 冲突 ===========# 指定目录，创建路径的文件夹，日志输出文件名默认使用 spring.loglogging.path=/tmp/spring/log# 如果不指定路径则在当前项目下生成日志，也可以指定路径#logging.file=springboot.log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中输出的日志的格式#logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n日志输出格式：%d 表示时间日期%thread 表示线程名%-5level级别从左显示5个字符宽度%logger{50} 表示 logger 名字最长为50个字符，否则按照据点分隔%msg 日志消息%n 换行符具体的可以在 SpringBoot 的 logging 下面的文件中查看：也可以自定义日志配置，在类路径下放上每个日志框架自己的配置文件后，SpringBoot 就不使用默认的配置了。以下文件会根据你选择的日志系统进行加载：日志系统定制配置Logbacklogback-spring.xml,logback-spring.groovy,logback.xml或logback.groovyLog4jlog4j.properties或log4j.xmlLog4j2log4j2-spring.xml或log4j2.xmlJDK (Java Util Logging)logging.properties注 如果可能的话，建议你使用-spring变种形式定义日志配置（例如，使用logback-spring.xml（由 SpringBoot 完全控制）而不是logback.xml（日志框架会读取，跳过 SpringBoot））。如果你使用标准的配置路径，Spring可能不能够完全控制日志初始化。使用 -spring 还有一个优点：由 SpringBoot 来解析日志配置，可以使用 SpringBoot 的高级 Profile 功能。123&lt;springProfile name="staging"&gt; &lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;&lt;/springProfile&gt;&lt;springProfile&gt;标签可用于根据激活的Spring profiles，选择性的包含或排除配置片段。Profile片段可以放在&lt;configuration&gt;元素内的任何地方，使用name属性定义哪些profile接受该配置，多个profiles以逗号分隔。123456789101112&gt; &lt;springProfile name="staging"&gt;&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt;&gt; &lt;/springProfile&gt;&gt; &gt; &lt;springProfile name="dev, staging"&gt;&gt; &lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;&gt; &lt;/springProfile&gt;&gt; &gt; &lt;springProfile name="!production"&gt;&gt; &lt;!-- configuration to be enabled when the "production" profile is not active --&gt;&gt; &lt;/springProfile&gt;&gt;切换日志框架按照 SLF4j 的日志适配图，进行响应的转换。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之属性配置]]></title>
    <url>%2Fposts%2Fa29f8391%2F</url>
    <content type="text"><![CDATA[配置文件SpringBoot 使用一个全局的配置文件：application.propertiesapplication.yml配置文件的作用：修改 SpringBoot 自动配置的默认值。以前的配置文件：使用的大多是 xml 文件。yml 是YAML（YAML Ain’t Markup Language）语言的文件，以数据为中心，更适合做配置文件YAML 语法基本语法key: value ==&gt; 表示一对键值对（空格不能省略），且对大小写敏感。以空格的缩进来控制层级关系；只要是左对齐的一列数据都是同一层级的数据1234server: port: 8081 path: /hello# 这是注释..值的写法字面量：普通的值（数字、字符串、布尔）字面量直接写，字符串默认不用加上单引号或者双引号；“”: 不会转义字符串的特殊字符，特殊字符作为本身要表示的意思‘’：会转义特殊字符，特殊字符只是一个普通的字符串数据对象、Map（属性和值）Key: Value 对象还是键值对的形式，在下一行写对象的KV，但需要注意缩进123friends: lastName: zhangsan age: 20行内写法：1friends: &#123;lastName: zhangshan, age: 18&#125;数组（List、Set）用 - 值 表示数组中的一个元素1234pets: - cat - dog - pig行内写法：1pets: [cat, dog, pig]上面三种格式可以互相嵌套。获取配置文件值一、使用 @ConfigurationProperties配置文件12345678910111213person: lastName: zhangsan # 驼峰命名可以转化为横杠：last-name age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1, k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2Java Bean123456789101112@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;还需要导入配置文件处理器，在 pom.xml 中加入：123456&lt;!-- 配置文件处理器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;同样，在 properties文件中也可以配置，但是在里面输入中文会出现乱码（Spring Boot 是以 iso-8859 的编码方式读取 application.properties 配置文件）。解决方法：在 .properties 中加入:12345&gt; spring.http.encoding.force=true&gt; spring.http.encoding.charset=UTF-8&gt; spring.http.encoding.enabled=true&gt; server.tomcat.uri-encoding=UTF-8&gt;将 IDEA 设置中的 File Encodings 的 Transparent native-to-ascii conversion 打钩。属性名匹配规则：person.firstName：使用标准方式person.first-name：大写用 -person.first_name：大写用_PERSON_FIRST_NAME：推荐系统属性使用这种写法二、使用 @Value使用 Spring 底层注解 @Value 来实现，获取配置文件或环境变量的值，或使用 SpEL@ConfigurationProperties 和 @Value 区别Feature@ConfigurationProperties@Value功能批量注入配置文件中的属性一个个指定松散绑定（属性名匹配规则）支持不支持SpEL不支持支持JSR303数据校验支持（注入时校验数据）不支持复杂类型封装支持不支持（只支持基本类型）数据校验：123456@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; @Email private String lastName;这样，如果 lastName 不是一个有效的 email 的话会抛出异常。加载指定的配置文件使用 @PropertySource 和 @ImportResource 可以记载指定的配置文件。使用 @ConfigurationProperties 默认是从全局配置文件中获取值。@PropertySource： 加载指定的配置文件12345@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")// @Validatedpublic class Person &#123;@ImportResource：导入 Spring 的配置文件，让配置文件里面的内容生效SpringBoot 里面没有 Spring 的配置文件，自己编写的配置文件也不能自动识别，想让 Spring 的配置文件生效，加载进来，需要把 @ImportResource 标注在配置类上：123@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)@SpringBootApplicationpublic class SpringBoot02ConfigApplication &#123;SpringBoot 推荐的给容器添加组件的方式：编写配置类使用 @Bean 给容器中添加组件12345678910@Configurationpublic class MyAppConfig &#123; // bean 的 id 与方法名相同 @Bean public HelloService helloService() &#123; return new HelloService(); &#125;&#125;配置文件占位符RandomValuePropertySource：配置文件中可以使用随机数${random.value}、${random.int}、${random.long}、${random.int(10)、${random.int[1024,65536]}属性配置占位符可以在配置文件中引用前面配置过的属性（优先级前面配置过得这里都能用）${app.name: 默认值}来指定找不到属性的默认值123456789#person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/12person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,c,dperson.dog.name=$&#123;person.last-name&#125;_dogperson.dog.age=15如果属性不存在，则会将占位符当做字符串处理ProfileProfile 是 Spring 对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境多 profile 文件形式格式：application-{profile}.properties默认使用 application.properties 配置文件。YAML 文档块模式YAML 中如果使用 --- 可以将文件划分为不同的文档块，多个 profile 可以写在同一个文件中1234567891011121314151617181920212223242526272829303132# Document1server: port: 8081person: lastName: zhangsan age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1, k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2spring: profiles: active: dev # 指定激活哪一个 profile---# Document2server: port: 8011spring: profiles: dev # 指定文档块属于哪个 profile---# Document3server: port: 8022spring: profiles: prod使用其他环境的配置文件的方式：application.properties 或 application.yml 指定YAML 的优先级比 .properties 要低spring.profiles.active={profile}`spring:profiles:active: {profile}` 命令行方式（优先级较高）：idea 的 program arguments 设置 -- spring.profiles.active={profile}maven 打包后，在命令行执行并加上参数虚拟机参数idea 的 VM options: -Dspring.profiles.active={profile}配置文件的加载位置SpringBoot 启动会扫描以下位置的 application.properties或者 application.yml 文件作为 SpringBoot 的默认配置文件：（Idea 中类路径即 classpath:对应 resources 目录）file:/config/file:/classpath:/configclasspath:/以上按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置的内容会覆盖低优先级配置的内容，也可以通过配置 spring.config.location 来改变默认内容。SpringBoot 会加载上述的所有文件，只是如果配置冲突，高优先级的配置文件中的设置会覆盖低优先级配置文件的设置，低优先级的其他配置依然会生效。例如在上述四个配置文件中分别定义不同的端口号，在 /resource/application.properties 文件中定义项目的访问路径，那么运行后低优先级配置的项目访问路径仍然有效：12345server.port=8081# 配置项目的访问路径server.servlet.context-path=/springboot-demo# 新版本的配置改为：server.servlet.context-path，而不是 server.context-path指定配置文件路径项目打包好后，可以使用命令行参数的形式，在启动项目时指定配置文件的新位置，指定的配置文件和默认加载的配置文件会共同启动作用，形成互补配置。直接在上述的四个配置文件中指定 spring.config.location 并不会生效。外部配置的加载顺序官网文档中文手册上提到的外部配置的加载顺序：Spring Boot允许将配置外部化（externalize），这样你就能够在不同的环境下使用相同的代码。你可以使用properties文件，YAML文件，环境变量和命令行参数来外部化配置。使用@Value注解，可以直接将属性值注入到beans中，然后通过Spring的Environment抽象或通过@ConfigurationProperties绑定到结构化对象来访问。Spring Boot设计了一个非常特别的PropertySource顺序，以允许对属性值进行合理的覆盖，属性会以如下的顺序进行设值：（优先级从高到低，高优先级覆盖低优先级，形成互补）home目录下的devtools全局设置属性（~/.spring-boot-devtools.properties，如果devtools激活）。测试用例上的@TestPropertySource注解。测试用例上的@SpringBootTest#properties注解。命令行参数（多个参数可以用空格分隔开）来自SPRING_APPLICATION_JSON的属性（环境变量或系统属性中内嵌的内联JSON）。ServletConfig初始化参数。ServletContext初始化参数。来自于java:comp/env的JNDI属性。Java系统属性（System.getProperties()）。操作系统环境变量。RandomValuePropertySource，只包含random.中的属性。没有打进jar包的Profile-specific应用属性（application-{profile}.properties和YAML变量）。打进jar包中的Profile-specific应用属性（application-{profile}.properties和YAML变量）。没有打进jar包的应用配置（application.properties和YAML变量）。打进jar包中的应用配置（application.properties和YAML变量）。@Configuration类上的@PropertySource注解。默认属性（使用SpringApplication.setDefaultProperties指定）。自动配置的原理配置文件可配置属性的范围：官方文档自动配置原理：SpringBoot 启动时，加载主配置类，开启了自动配置功能 @EnableAutoConfiguration@EnableAutoConfiguration 作用利用 AutoConfigurationImportSelector.class 给容器中导入组件，里面的 public String[] selectImports(AnnotationMetadata annotationMetadata) { ... } 方法中，调用了 protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {...} 方法，这里面有一句代码是这样的：1List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);通过这行代码来获取候选的配置。1234567protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames( this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."); return configurations;&#125;里面的 loadFactoryNames 方法的源码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; try &#123; // 扫描所有jar包类路径下的 META-INF/spring.factories 文件 Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); // 获取 url 后对每个 url 进行遍历 while (urls.hasMoreElements()) &#123; // 把扫描到的文件内容包装为 properties 对象 URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; // 从 properties 对象中获取全类名 String factoryClassName = ((String) entry.getKey()).trim(); for (String factoryName : StringUtils. commaDelimitedListToStringArray((String) entry.getValue())) &#123; // 添加 result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException("Unable to load factories from location [" + FACTORIES_RESOURCE_LOCATION + "]", ex); &#125;&#125;// 返回 EnableAutoConfiguration.class 类protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123; return EnableAutoConfiguration.class;&#125;所以总的来说，是将 META-INF/spring.factories 里面的所有 EnableAutoConfiguration 的值加入到容器中。使用这些类来做自动配置：每一个自动配置类进行自动配置功能以 HttpEncodingAutoConfiguration 为例1234567891011121314151617181920212223242526272829303132333435@Configuration// 表示这是一个配置类@EnableConfigurationProperties(HttpProperties.class)// 启用指定类的 ConfigurationProperties 功能，将配置文件中对应的值与这个properties类绑定在一起，并把 HttpProperties 加入到 Ioc 容器中@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)// Spring 底层注解，根据不同的条件决定配置是否生效；// 判断当前应用是否为 web 应用，如果是则生效@ConditionalOnClass(CharacterEncodingFilter.class)// 判断当前项目有没有这个类(Spring MVC 解决乱码中的过滤器)@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true)// 判断在配置文件中是否启用，如果配置这个属性，也生效public class HttpEncodingAutoConfiguration &#123; // 已近与 SpringBoot 的配置文件映射了 private final HttpProperties.Encoding properties; // 只有一个有参构造器的情况下，参数的值会从容器中获取 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; // 给容器中添加组件，有些值需要从 properties 中获取 @Bean // 容器中没有这个组件时候才会执行 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding( this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding( this.properties.shouldForce(Type.RESPONSE)); return filter; &#125;根据当前不同的条件判断。决定配置类是否生效，一旦配置类生效，这个配置类就会在容器中添加各种组件，这些组件的属性是从对应的 propertie 类中获取的，而这些类的每一个属性又是和配置文件绑定的。所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类123@ConfigurationProperties(prefix = "spring.http")// 从配置文件中获取指定的值和 bean 的属性进行绑定public class HttpProperties &#123;SpingBoot 的精髓：SpringBoot 启动会加载大量的自动配置类我们需要的功能有没有 SpringBoot 默认写好的自动配置类在看这个自动配置类到底配置了哪些组件，如果有，就不需要自动配置了给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性，可以在配置文件中指定属性的值@Conditional 扩展注解@Conditional扩展注解作用（判断是否满足当前指定条件）@ConditionalOnJava系统的java版本是否符合要求@ConditionalOnBean容器中存在指定Bean；@ConditionalOnMissingBean容器中不存在指定Bean；@ConditionalOnExpression满足SpEL表达式指定@ConditionalOnClass系统中有指定的类@ConditionalOnMissingClass系统中没有指定的类@ConditionalOnSingleCandidate容器中只有一个指定的Bean，或者这个Bean是首选Bean@ConditionalOnProperty系统中指定的属性是否有指定的值@ConditionalOnResource类路径下是否存在指定资源文件@ConditionalOnWebApplication当前是web环境@ConditionalOnNotWebApplication当前不是web环境@ConditionalOnJndiJNDI存在指定项自动配置类必须在一定的条件下才能生效；查看哪些配置类自动生效：通过启用 debug 属性来打印自动配置报告：12# 开启 SpringBoot 的 debug 模式debug=true]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之环境配置]]></title>
    <url>%2Fposts%2Fcb2b0fb3%2F</url>
    <content type="text"><![CDATA[将 SpringBoot 项目打包为 Jar 包maven pom.xml 中加入如下代码：123456789&lt;build&gt; &lt;!-- 插件作用：将应用打包为可执行的 jar 包 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;使用 mvn package 就可以将应用打包。在终端里 cd 到 jar 的位置后，java -jar (jar包名称或路径） 就可以运行项目，而且不需要配置 tomcat 环境，因为 SpringBoot 集成了 tomcat。POM 文件解析父项目123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;父项目作用：依赖管理这个父项目还有一个父项目：123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;这个父项目才是真正管理 Spring Boot 应用里面的所有的依赖管理的，其 &lt;properties&gt; 属性规定了常用包的版本号。所以导入以及规定版本的包是不需要写版本号的。导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;spring-boot-starter-web: spring-boot 场景启动器，导入了 web 模块正常运行需要的依赖Sping Boot 将所有的功能场景都抽取出来，做成一个 starters，只需要在项目里面引入这些 starter 相关的场景依赖都会自动导入进来。主程序类1234567891011@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring 应用启动起来 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125;@SpringBootApplication 说明被注解标注的类是 SpringBoot 的主配置类，SpringBoot 应该运行这个类的 main 方法来启动 SpringBoot 应用。注解部分源码：12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;@SpringBootConfiguration : 表示被标注的类是 SpringBoot 的配置类，配置类也是容器中的一个组件@EnableAutoConfiguration：开启自动配置的功能自动配置的原理：注解部分源码：1234&gt; @AutoConfigurationPackage&gt; @Import(&#123;AutoConfigurationImportSelector.class&#125;)&gt; public @interface EnableAutoConfiguration &#123;&gt;@AutoConfigurationPackage : 自动配置包，使用 @Import({Registrar.class}) 这个 Spring 底层注解来实现，给容器中导入一个组件。12&gt; &gt; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;&gt; &gt;将主配置类 （@SpringBootApplication 标注的类）的所在包下面的所有子包里面的所有组件扫描到 Spring 容器@Import({AutoConfigurationImportSelector.class}): 给容器中导入组件将所有需要导入的组件以全类名的方式返回，添加到容器中。会给容器中导入非常多的自动配置类（xxxAutoConfiguration），就是给容器中导入这个场景所需要的所有组件，并配置好这些组件。AutoConfigurationImportSelector 类部分代码：12345678910&gt; &gt; public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;&gt; &gt; if (!this.isEnabled(annotationMetadata)) &#123;&gt; &gt; return NO_IMPORTS;&gt; &gt; &#125; else &#123;&gt; &gt; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);&gt; &gt; AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);&gt; &gt; return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&gt; &gt; &#125;&gt; &gt; &#125;&gt; &gt;方法 getAutoConfigurationEntry 中的 List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations 数组就是容器中需要导入的组件。SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());从类加载器中获取资源，将资源作为 properties 配置文件，从中拿出工程的名字：factoryClass.getName()。从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中。有了自动配置类，就免去了手动编写而配置注入功能组件等的工作。J2EE 的整体解决方案和自动配置都在 spring-boot-autoconfigure-xxx.RELEASE.jar;使用 Spring Initializr 快速创建项目Idea 或者官网的 Spring Initialzr 可以快速创建项目。默认生成的 Spring Boot 项目：主程序、测试文件生成好了resource 文件夹的目录结构static: 保存所有的静态资源：js、css、images；templates: 保存所有的模板页面；（由于使用嵌入式的 Tomcat，默认不支持 JSP）application.properties: Spring Boot 应用的配置文件，可以修改默认设置；]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet请求转发]]></title>
    <url>%2Fposts%2Fe0aa16fa%2F</url>
    <content type="text"><![CDATA[在 Servlet 中请求转发的方法无非两种：使用 RequestDispatcher 来调派请求使用 include() 来将另一个 Servlet 的操作流程包括至目前的操作流程中使用 forward() 方法将请求处理转发给其他的 Servlet使用 HttpServletResponse 的 sendRedirect() 方法要求浏览器重新请求另一个 URL如果要调用 forward() 和 sendRedirect() 方法，那么目前的 Servlet 不能有任何响应确认，否则会抛出异常。调用 forward() 方法时需要传入请求与响应对象，由于传递的是同一个 request，所以在转发过程中可以使用请求范围属性来传递一些属性。但 forward() 转发的这个动作是在 Web 容器中进行的，浏览器不知道请求被转发，地址栏也不会发生变化，转发也限制只能转发到服务器的另一个资源。而在整个转发过程中，都还是在同一个请求周期中。当浏览器请求 Servlet1 后，Servlet1 将请求转发给了 Servlet2，之后 Servlet2 对浏览器进行响应，全程浏览器都不知道发送的请求已被转发。这样会存在的一个问题：当我刷新页面后，不过不加以处理会导致数据被重复提交。比如现在有如下代码：123456789101112131415161718&lt;%@page pageEncoding="UTF-8" contentType="text/html; UTF-8" %&gt;&lt;!doctype html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="testServlet" method="post"&gt; 用户名&lt;input type="text" name="username"&gt;&lt;br/&gt; 消息&amp;emsp;&lt;input type="text" name="message"&gt;&lt;br/&gt; &lt;input type="submit" value="上传"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;1234567891011121314151617181920212223242526272829303132333435363738package xuac;import java.io.*;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.*;/** * ClassName ServletTest-ServletOne * Description forward() * @author xuanc * @version 1.0 * @date 19-3-17 下午2:04 */@WebServlet("/testServlet")public class ServletOne extends HttpServlet&#123; private void processRequest(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; System.out.println("forward() 测试 ----------------------"); String username = request.getParameter("username"); String message = request.getParameter("message"); System.out.println("Username: " + username + "\n" + "Message: " + message); request.getRequestDispatcher("index.jsp").forward(request, response); System.out.println("after forward()......................"); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; processRequest(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; processRequest(request, response); &#125;&#125;提交表单后在输出了表单内容。而当刷新一次后：浏览器会提醒重复提交表单当确认后发现内容被重复提交：sendRedirect() 方法顾名思义，是重定向而非转发。可以让浏览器重新请求另一个 URL，请求的资源也可以是其他服务端的资源。与 forward() 不同，重定向实际上是两次请求，浏览器请求 Servlet1 时，Servlet1 将浏览器重定向到 Servlet2，然后浏览器向 Servlet2 发出请求，之后则由 Servlet2 做出响应或者其他的操作。这样的重定向浏览器是可以知道的，地址栏也会发生变化。上面的例子中，解决刷新重复提交表单的方法之一就是使用重定向而不是转发（forward()）。另一种方法是使用 token，通过它来判断是否是重复提交，进而进行处理。由于在重定向的过程中，并没有使用同一个 HttpRequest 对象，所以想要传递属性只能通过 Session 来处理。而且因为是两次请求，需要额外的往返行为，所以相比 forward() 来说重定向会慢一些。在上面的例子中我们也可以看到，调用 forward 或 sendRedirect 不会停止执行方法中的其余代码。所以如果转发和重定向之后还有可能会执行其他语句的话应该加上 return。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记－疯狂Java讲义[4]]]></title>
    <url>%2Fposts%2F603dd0d7%2F</url>
    <content type="text"><![CDATA[第四章 流程控制与数组1.流程控制switch&emsp;&emsp;switch 语句后面控制表达式的数据类型只能是byte、short、char、int、枚举类型和java.lang.String类型。switch中其他类型会隐式向上转换为int，long比int范围大，转换可能会损失精度，Java通过string的hash()值把string也转换为int。控制循环结构&emsp;&emsp;Java没有提供goto语句，与C类似，也有continue、break语句。不同的是，break和continue后可以紧跟标签来使得可以结束或直接跳到外层循环。&emsp;&emsp;标签是一个紧跟英文冒号的标识符，Java中的标签只有放在循环语句前才有用。代码清单12345678910111213public class HelloWorld&#123; public static void main(String []args)&#123; outer: for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; System.out.println("Hello ~"); if (j == 1) &#123; break outer; &#125; &#125; &#125; &#125;&#125;2.数组&emsp;&emsp;数组也是一种数据类型，属于引用类型。数组用来存储一组具有相同数据类型的元素。Java中类与类可以继承，会造成一个数组中有多个类型的假象，但归根到底元素都属于同一种类型。数组一旦初始化完成后，其长度将固定不变。&emsp;&emsp;数组是一种引用类型，定义一个数组后相当于只定义了一个指针，这个指针还没指向任何有效内存。所以定义数组的时候不能指定数组的长度。数组的定义12type[] arrayName; type arrayName[];&emsp;&emsp;为了更好的可读性，推荐使用第一种定义方式。数组的初始化&emsp;&emsp;初始化，即为数组的数组元素分配内存空间，并给每个数组元素赋值，数组的定义和初始化可以同时完成。初始化的两种方式：静态初始化初始化时显式指定数组元素的初值，长度由系统决定（指定长度会报错）。语法格式：123arrayName = new type[] &#123;element1, element2, ..., elementn&#125;;// 数组的定义和静态初始化同时完成可以省略 new type[]// type[] arrayName = &#123;element1, element2, ...&#125;;初始化时type类型以及元素的类型要与定义数组时指定的类型一致（相同或为定义时指定类型的子类），元素以逗号分隔开。动态初始化初始化时只指定数组的长度，系统为数组元素分配初值。语法格式：1arrayName = new type[length];type类型要求同上。length可以是已初始化的变量。系统默认分配的初值为：整数类型：0浮点类型：0.0字符类型：’\u0000’布尔类型：false引用类型：null数组的使用数组可以通过索引的方式去除数组元素或对其进行赋值如果索引超出数组大小范围在运行时会抛出异常：java.lang.ArrayIndexOutOfBoundsException: N，N的值即为非法的数组索引。数组的长度可以通过其length属性获得Java5之后，Java提供了更简单的循环：foreach循环，可以自动遍历数组和集合的每个元素。123for(type variableName : array | collection) &#123; // variableName 自动访问每个元素&#125;foreach循环中的循环变量variableName是一个临时变量，改变他并不能改变数或集合中元素的值数组的实质&emsp;&emsp;数组引用变量只是一个引用，数组元素和数组变量在内存里分开存储。而引用变量是访问真实对象的根本方式，只能通过数组的引用变量才能访问数组对象本身。&emsp;&emsp;实际的数组对象存储在堆中，如果引用数组对象的数组引用变量是局部变量，它被存储在栈中，如果堆中的对象不在有任何变量指向它，会被JVM的垃圾回收机制回收。&emsp;&emsp;通过对数组的重新赋值，产生数组长度可变的错觉，但实际堆中实际的数组对象并不可变。程序清单123456789101112131415public class ArrayInRam &#123; public static void main(String[] args) &#123; int[] a = &#123;5, 7, 20&#125;; int[] b = new int[4]; System.out.println("b 数组的长度" + b.length); for (int temp : a) &#123; System.out.println(temp); &#125; for (int temp : b) &#123; System.out.println(temp); &#125; b = a; System.out.println("b 数组的长度" + b.length); &#125;&#125;多维数组&emsp;&emsp;Java支持多维数组，但从本质上来说并没有多维数组。多维数组实质上其元素也是引用变量。代码清单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TwoDimensionTest &#123; public static void main(String[] args) &#123; // 定义一个二维数组 int[][] a; // 初始化数组，数组a有四个元素，每一个元素都是int[]类型 a = new int[4][]; // Error! // a = new int[][4]; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; System.out.println("-----------"); a[0] = new int[2]; a[0][1] = 6; for (int i = 0; i &lt; a[0].length; i++) &#123; System.out.println(a[0][i]); &#125; System.out.println("==========="); // 初始化的多种方式 // One // int[][] b = new int[][] &#123; // new int[]&#123;1&#125;, // new int[]&#123;1, 2&#125;, // new int[]&#123;1, 2, 3&#125; // &#125;; // Two int[][] b = &#123; &#123;1&#125;, new int[2], new int[]&#123;1, 2, 3&#125; &#125;; // foreach() for (int[] tempArray : b) &#123; for (int tempValue : tempArray) &#123; System.out.println(tempValue); &#125; &#125; System.out.println("==========="); // Error! // int[][] c = new int[2][] &#123; // 1, 2, 3, 4, 5, 6 // &#125;; int[][] c = new int[2][4]; &#125;&#125;使用Arrays类&emsp;&emsp;Java中Arrays类中的一些static方法可以直接操作数组，使用这些方法需要导入java.util.Arrays类(import java.util.Arrays)，static方法可以直接通过类名调用。int binarySearch(type[] a, type key)使用二分法在数组a中查询值为key的元素，返回其索引，查找失败返回负数。要求数组为升序排列。int binarySearch(type[] a, int fromIndex, int toIndex, type key)与上一个类似，只是限定查找索引范围为fromIndex到toIndex。type[] copyOf(type[] original, int length)将original复制为一个新的数组，新数组长为length，如果length大于原数组的长度，后面元素补充为0、false或null。type[] copyOfRange(type[] original, int from, int to)只复制数组的from索引到to索引的元素boolean equals(type[] a, type[] a2)判断两个数组是否相等（长度+数组对应元素）void fill(type[] a, type val)将数组的所有元素设为valvoid fill(type[] a, int fromIndex, int toIndex, type val)与上一个相同，只是限制了赋值的索引范围void sort(type[] a)对数组元素排序（自定义排序方法涉及到重载）void sort(type[] a, int fromIndex, int toIndex)作用同上，只限制了排序的范围String toString(type[] a)将一个数组转换为字符串代码清单12345678910111213141516171819import java.util.Arrays;public class TwoDimensionTest &#123; public static void main(String[] args) &#123; String names[] = new String[]&#123; "人生苦短", "来杯Java" &#125;; String namesCopy[] = Arrays.copyOf(names, names.length); System.out.println(Arrays.toString(namesCopy)); names[0] = "HelloWorld"; System.out.println(Arrays.toString(names)); System.out.println(Arrays.toString(namesCopy)); &#125;&#125;// output------------------------------------------------------// [人生苦短, 来杯Java]// [HelloWorld, 来杯Java]// [人生苦短, 来杯Java]]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter7-使用JSTL]]></title>
    <url>%2Fposts%2F2f1b8bf3%2F</url>
    <content type="text"><![CDATA[JSTL 简介JSTL 提供了与页面呈现相关的逻辑判断标签，也提供了对应 JSP 标注标签的扩展标签和更多的功能标签，可以分为五类：核心标签库：提供条件判断、属性访问、URL 处理及错误处理等I18N 兼容格式标签库：提供数字、日期等的格式化和区域、编码处理等功能SQL 标签库XML 标签库：提供 XML 解析、流程控制、转换等功能函数标签库：提供常用字串处理的已定义 EL 标签库idea 使用 JSTL 标签库：在 JSTL 中下载最新的 zip 文件，解压。idea 中打开设置，搜索 Schemas and DTDs，点右边的 +，URL中输入 http://java.sun.com/jsp/jstl/core，浏览文件选择刚才解压后文件夹中的 tld 目录下的 c.tld 文件。将 zip 文件夹中的 lib 里的文件复制到项目中的 WEB-INF 的 lib 目录下，或者在 Project Setting -&gt; Libraries 中点＋，选择 lib 文件夹里面的文件。核心标签库流程处理标签1234&lt;c:if test="$&#123;param.name == 'momor'&amp;&amp; param.password == '1234'&#125;"&gt; &lt;h1&gt;$&#123;param.name&#125; 登录成功 &lt;/h1&gt;&lt;/c:if&gt;&lt;%-- JSTL中可以使用EL表达式--%&gt;如果 test 属性为 true，才会输出 &lt;c:if&gt; 标签中的语句。123456789101112&lt;c:choose&gt; &lt;c:when test="$&#123;user.valid&#125;"&gt; &lt;jsp:getProperty name="user" property="name"/&gt; 登录成功 &lt;%-- * 属性的名称就是get/set方法去除get/set后 ,再把首字母小写 * boolean的方法可以是is开头 --%&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h1&gt; 登录失败 &lt;/h1&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt;当 &lt;c:when&gt; test 为 true 时，只会输出这个标签中的 Body 内容。否则继续判断下一个 &lt;c:when&gt; 标签中的 test，如果所有的 &lt;c:when&gt; 都不满足，就输出 &lt;c:otherwise&gt; 的内容（如果有这个标签）。123456&lt;c:forEach var="message" items="$&#123;messageService.messages&#125;"&gt; &lt;tr&gt; &lt;td&gt;$&#123;message.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;message.text&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt;类似 Java 中的 forEach 循环，items 属性可以是数组、Collection、Iterator、Enumeration、Map 与字符串。每次会从 items 中取出元素，指定给 var 属性设置的变量。items 属性是 Map :&emsp;&emsp;设置给 var 的对象是 Map.Entry ，有 getKey() getValue() 方法取得键与值。items 属性是字符串：&emsp;&emsp;以逗号来切割字符串，如果要自定义切割依据可以使用&lt;c:forTokens&gt;123&lt;c:forTokens var="token" delims=";" items="a;b;c;d;e"&gt; &lt;%-- ... --%&gt;&lt;/c:forTokens&gt;错误处理标签错误发生时，在当前网页捕捉异常并显示相关信息。使用 &lt;c:catch&gt; 标签。1234567&lt;c:catch var="error"&gt; $&#123;param.a&#125; + $&#123;param.b&#125; = $&#123;param.a + param.b&#125;&lt;/c:catch&gt;&lt;c:if test="$&#123;error != null&#125;"&gt; &lt;br&gt;&lt;span style="color: red;"&gt;$&#123;error.message&#125;&lt;/span&gt; &lt;br&gt;$&#123;error&#125;&lt;/c:if&gt;用 &lt;c:catch&gt; 标签将可能产生异常的部分包起来，如果有异常会给 var 设值。所有的异常都是 Throwable 的子类，都有 getMessage() 方法。网页导入、重定向、URL处理标签包含其他 JSP 网页到当前网页的几种方式：&lt;%@include file=&quot;/....&quot; %&gt;使用 &lt;jsp:include&gt; 标签，动态包含，还可传递参数JSTL 中有一个 &lt;c:import&gt; 标签，也可以在运行时动态导入到另一个网页。1234567&lt;c:import url="add.jsp"&gt; &lt;c:param name="a" value="1" /&gt; &lt;%-- 用 &lt;c:param&gt; 标签传递参数--%&gt;&lt;/c:import&gt;&lt;c:import url="https://...." charEncoding="BIG5" /&gt;&lt;%--导入外部网页，如果编码不同需指定具体编码--%&gt;&lt;%--没有使用参数--%&gt;&lt;c:redirect&gt; 标签，可以重定向网页，类似 Servlet 中的 HttpServletResponse.sendRedirect() 方法，可以使用 &lt;c:param&gt; 标签在重定向时指定参数。之前利用 response.encodeURL() 方法来作 URL 重写，以在关闭 Cookie 后正常维持 Session 进行会话管理，现在可以用 &lt;c:url&gt; 标签达到同样的目的。属性处理与输出标签可以用 JSTL 设置属性：12345&lt;c:set var="p1q1" value="$&#123;param.p1q1&#125;" scope="session" /&gt;&lt;%--属性值太长可以用 Body 形式--%&gt;&lt;c:set var="p1q2" scope="session"&gt; some....&lt;/c:set&gt;var 用来设置属性名，value 设置属性值（可以用 EL 表达式），如果不设置 scope ，会从 page 、request 、session、application 的范围中查找属性名称，如果找到就在该范围设置，找不到就在page 范围新建。移除属性：&lt;c:remove var=&quot;login&quot; scope=&quot;session&quot;/&gt;&lt;c:set&gt; 可以设置 JavaBean 的属性或 Map 对象的键/值，需要使用 target 属性进行设置。&lt;c:set target=&quot;${pageContext.request}&quot; property=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;如果 target 属性是 JavaBean，就用 JavaBean 的 setXXX 方法为 property 设值。如果是 Map 对象，则会以 property 为键，以 value 为值。&lt;c：out&gt; 标签可以输出内容，并用合适的字符替换 &lt;、&gt;、”等字符。eg.&lt;c:out value=&quot;some&quot;&gt;如果不想取代字符，可以设置属性 escapeXml 为 false （默认为 true），如果输出内容的 EL 表达式结果为 null 时，不会显示任何内容，也可以加上 default 属性设置为null时的默认值。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter6-使用jsp]]></title>
    <url>%2Fposts%2F2bd95d05%2F</url>
    <content type="text"><![CDATA[指示元素JSP指示元素主要是为了表示容器将 JSP 转译为 Servlet 源代码时所必须遵守的信息。 语法为：&lt;%@ 指示类型 [属性=&quot;值&quot;]* %&gt;，指示元素可以有多对的属性/值 JSP 常用的三种指示类型为：page 、include、taglib page： 告知容器如何转译当前的JSP网页 include： 告知容器将别的JSP页面包括进来进行转译 taglib： 告知容器如何转译这个页面的标签库 12&lt;%@page import="java.util.Date" %&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8"%&gt; 1：告知容器转译时要包括import属性中的值的包，即 Servlet 要有import java.uutil.Date;，如果有多个包要包含，可以用逗号分割开：... import=&quot;java.util.Date, java.util.io*, ...&quot; 2：contenType属性对应转译后的response.setContentType(&quot;...&quot;)，pageEncoding告诉容器这个网页的编码 include类型的范例： 12345&lt;!-- includeDemo.jsp --&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@include file="/WEB-INF/jspf/header.jspf"%&gt; &lt;h1&gt;这是本尊&lt;/h1&gt;&lt;%@include file="/WEB-INF/jspf/foot.jspf"%&gt; 12345678910&lt;!--header.jspf--&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8" %&gt;&lt;!doctype html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;示范开头&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是开头&lt;/h1&gt; 12345&lt;!--foot,jspf--&gt;&lt;%@page pageEncoding="UTF-8" %&gt; &lt;h1&gt;这是结尾&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; includeDemo.jsp 第一次执行时会将上面两个文件的内容包括起来，然后进行转译，所以最终会生成一个Servlet，这是一种静态的包括方式。&lt;jsp:include&gt;标签是运行时动态包括别的网页执行流程进行响应的方式，会各自生成独立的 Servlet。 同时也可以看到，包含的两个文件的后缀名是 .jspf，.jspf 文件通常是通过include伪指令包含在.jsp文件中的文件。’f’代表’fragment’，因为这些文件本身可能并不是完整的JSP，而是JSP的片段。类似这样的后缀名还有一个 .jspx。 同样，关于一些JSP的设置也可以在 web.xml 中更改，例如网页编码、内容类型等等 1234567891011&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;page-encoding&gt;UTF-8&lt;/page-encoding&gt; &lt;default-content-type&gt;text/html&lt;/default-content-type&gt; ... &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; 也可以声明指定的JSP文件的开头和结尾所要包括的网页 123456789... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;include-perlude&gt;some...&lt;/include-perlude&gt; &lt;include-coda&gt;some...&lt;/include-coda&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;... 在编写JSP网页时，换行字符不会忽略，所以最后产生的换行字符也会输出，如果要忽略，可以在 web.xml 中的&lt;jsp-property-group&gt;标签中加上 &lt;trim-directive-whitespaces&gt;true&lt;/...&gt; 声明、Scriptlet 与表达式元素JSP 中可以使用 声明、Scriptlet 元素和表达式来指定转译后 Servlet 类中包括的类成员、方法声明和语句。 声明元素的语法：&lt;@! 类成员声明或方法声明 %&gt; Scriptlet 的语法：&lt;% Java 语句 %&gt; 在 JSP 中的编写的 HTML，都会变成 out 语句所输出的内容，而 Scriptlet 出现的顺序在转译为 Servlet 后，会按顺序出现在 _jsoService() 中。 表达式元素的语法：&lt;%= Java表达式 %&gt; 表达式的运算结果将直接输出为网页的一部分，但表达式语句不能加上分号，因为在转译后，表达式语句的表达式会转译为 out 对象输出时的指定内容。 由于&lt;%和%&gt;在 JSP 中用来作为一些元素的开头和结尾，所以如果要在 JSP 网页中输出这两个符号要换成其他字符：&lt;% –&gt; &amp;lt;%，%&gt; –&gt; %&amp;gt;或%\&gt; （HTML输出&amp;用&amp;amp）。 一个网页通过适当的规划、切割业务逻辑与呈现逻辑，JSP 网页可以通过标准标签、EL 或 JSTL 自定义标签等消除网页上的 Scriptlet。 注释元素使用 &lt;%-- JSP注释 --%&gt;，写出网页注释会输出到网页上。 隐式对象JSP 隐式对象| 隐式对象 | 说明 || :———- | ———————————————————— || out | 转译后对应 JspWriter 对象，其内部关联一个 PrintWriter 对象 || request | 转译后对应 HttpServletRequest 对象 || response | 转译后对应 HttpServletResponse 对象 || config | 转译后对应 ServletConfig 对象 || applicaton | 转译后对应 ServletContext 对象 || session | 转译后对应 HttpSession 对象 || pageContext | 转译后对应 pageContext 对象，提供了 JSP 页面资源的封装，可设置页面范围属性 || exception | 转译后对应 Throwable 对象 ，代表其他 JSP 页面抛出的异常对象，只会出现于 JSP 错误页面 || page | 转译后对应 this | 隐式对象只能在&lt;%和%&gt;或&lt;%=和%&gt;之间使用。隐式对象转译后是_jspService()中的局部变量。 JspWriter 主要模拟了 BufferedWriter 与 PrintWriter 的功能，内部也是用 PrntWriter 来输出，但 JspWriter 具有缓冲区功能，使用 print() 和 println() 响应输出时，如果 JSP 页面没有缓冲或清楚缓冲时，才会直接创建 printWriter() 对象进行输出。 page 指示元素的 buffer 属性来设置缓冲区的大小，默认是8kb，autoFlush 属性决定缓冲区已满后的行为，默认值是 true ，表示慢了就清除，如果设置为 false，要自行调用 JspWriter 的 flush() 方法来清除，否则调用 println() 会抛出 IOException 异常。 所有的隐式对象都可以通过 pageContext 的 getXXX() 方法来取得，pageContext 也可以设置页面范围属性，类似 Servlet 中的几个对象，可以使用 setAttribute()、getAttribute()、removeAttribute() 来设置。页面范围属性的作用范围仅仅局限于同一页面中。 pageContext 提供了单一的 API 来设置四种范围属性： 123getAttribute(String name, int scope);setAttribute(String name, Object value, int scope);removeAttribute(String name, int scope); scope 的取值所代表的范围： pageContext.PAGE_SCOPE: 页面 pageContext.REQUEST_SCOPE : 请求 pageContext.SESSION_SCOPE: 会话 pageContext.APPLICATION_SCOPE : 应用程序范围 如果不知道属性范围的名称，可以用 pageContext 的 findAttribute() 方法依序从页面、请求、会话、应用程序范围中寻找，先找到就返回。 错误处理JSP 发生错误按时段分为三种： JSP 转换为 Servlet 源代码 Servlet 源代码编译时 Servlet 载入容器进行服务但发生运行时错误时 可以自定义运行时异常发生时的处理页面，需要用 page 指示元素，设置 errorPage 属性来指定错误处理的页面。 12&lt;%--add.jsp--%&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8" errorPage="error.jsp" %&gt; 12&lt;%--error.jsp--%&gt;&lt;%@page contentType="text/html; UTF-8" pageEncoding="UTF-8" isErrorPage="true" %&gt; exception 对象是 JSP 的隐式对象，只有 isErrorPage 设置为 true 的页面才可以使用这个对象。如果没有处理，会由容器默认处理，直接显示异常信息和堆栈跟踪信息。 123456789101112&lt;web-app ...&gt; &lt;!--容器收到某个类型的异常对象时进行转发--&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.NullPointerException&lt;/exception-type&gt; &lt;location&gt;/report.view&lt;/location&gt; &lt;/error-page&gt; &lt;!--基于HTTP错误状态码转发至处理页面--&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.jsp&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt; 标准标签JSP 规范中提供了一些标准标签，所有容器都支持，可协助编写 JSP 是减少 Scriptlet 的使用，所有的标签都以 jsp: 为前缀。 &lt;jsp:include>、&lt;jsp:forward>标签&lt;jsp:include&gt; 和 &lt;jsp:forward&gt;标签在转译后，底层是取得 RequestDispatcher 对象，并执行对应的 forward() 方法和 include() 方法。 123&lt;jsp:include page="add.jsp"&gt; &lt;jsp:param name="a" value="1"/&gt;&lt;/jsp:include&gt; &lt;jsp:param&gt; 指定了动态包括 add.jsp 时需要给页面的请求参数。 &lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt;JavaBean 元件具有的条件： 必须实现 java.io.Serializable 接口 没有公开的类变量 具有无参数的构造器 具有公开的设值(setXXX)和取值(getXXX)方法 &lt;jsp:userBean>、&lt;jsp:setProperty>与&lt;jsp:getProperty&gt; 这三个标准标签就是搭配 JavaBean 元件的。 12&lt;jsp:useBean id="user" class="User"/&gt;&lt;jsp:setProperty name="user" property="*"/&gt; 1.用来取得或创建 JavaBean id 指定 JavaBean 的实例名，之后可使用这个指定的名称设值和取值。 class 属性指定要实例化哪个类。 还有一个属性 scope （默认为 page 范围）指定先查找设定的属性范围是否有名为id 指定值的 JavaBean 的属性存在，如果找到就直接使用，没有找到就会新建新的对象。 type 属性，指定声明 JavaBean 的类型，可以是一个抽象类、也可以是一个接口。但如果只设置了 type 而没有 class , 如果指定范围内找不到对象会抛出异常。 2.设置 JavaBean 的属性值 name 指定要使用哪个名称来使用 JavaBean 实例，property 表示要设置的 JavaBean 属性，这两个属性在这个标签中必需的。 value 和 param 两个属性可选，找到 JavaBean 后，如果指定了 value 元素，会将value的值转换为合适的基本类型赋值给指定的 JavaBean 属性。有 param 属性的话会将指定的参数的值转化会合适的基本类型赋给 JavaBean 属性。 如果value 和 param 都省略，可以用 JSP 的自省机制判断是否有 property 值相同的请求参数，有的话就赋给 JavaBean。 最有弹性的写法是示例代码第二行所示，标签中只有必要元素，property 值设为 *，代表将请求参数名称和 JavaBean 属性名交给自省机制自动匹配。自省机制可以自动转换基本类型。 有两种很容易混淆的写法： 12&lt;jsp:useBean id="user" class="User"/&gt;&lt;jsp:setProperty name="user" property="*"/&gt; 这种写法无论如何都会使用设值。 123&lt;jsp:useBean id="user" class="User"&gt; &lt;jsp:setProperty name="user" property="*"/&gt;&lt;/jsp:useBean&gt; 这种只有找不到 JavaBean 对象的时候，才会新建对象并设置值。 &lt;jsp:getProperty&gt; 只有一种使用方法：&lt;jsp:getProperty name=&quot;JavaBean 对象实例名&quot;, property=&quot;JavaBean 对象属性名&quot;&gt; ，然后用 pageContext 的 findAttribute()依次查找。 表达式语言（EL）JSP 中一些简单的属性、请求参数、标头和 Cookie 等信息可以用 EL 来处理，更加简便。 EL 是使用 ${ 与 } 来包括要处理的表达式。EL 处理了null值的情况，对 null 值直接以空字符串显示，运算时不会因此发生错误而抛出异常。 由于某些时候网页使用了模板等有类似EL表达式的语法存在，可以设置 JSP 网页是否使用 EL. web.xml 中修改 123456789&lt;web-app ...&gt; ... &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; page 指示元素的属性 isELIgnored (default: false) 如果在 page 中设置了属性，以 page 中的设置为主。 隐式对象EL 中，可以用 EL 隐式对象指定范围来存取属性。如果不指定属性的范围，以 page、request、session、application 的顺序依次查找。 EL 中有11个隐式对象，只有 pageContext 隐式对象对应 PageContext ，其他都对应 Map 类型 pageContext PageContext 本身是 JavaBean 对象，所以只要是 getXXX() 方法，就可以使用 ${pageContext.xxx} 来取得。也可以使用点运算符连续存取对象。 属性范围相关隐式对象 表示作用范围，pageScope, requestScope, sessionScope, applicationScope 分别可以取得使用对应 JSP 隐式对象的 setAttribute() 方法所设置的属性对象。 请求参数相关隐式对象：param 和 paramValues ${param.user} 想当于 &lt;%= request.getParameter(&quot;user&quot;)%&gt; paramValues 相当于 request.getParameterValues() ，因为返回的可能是多个值，可以用 [] 运算符指定取得的是那个元素。 标头相关隐式对象：header 和 headersValues， ${header[&quot;User-Agent&quot;]} reqest.getHeader(&quot;User-Agent&quot;) Cookie 隐式对象：cookie 用来取得用户 Cookie 设置值。 初始参数隐式对象：initParam 可以取得 web.xml 中设置的 ServletContext 初始参数 取得元素的方式可以用 . 和 [] 来取得属性中的元素： . 运算符：左边可以是 JavaBean 或 Map 对象（Map 建议用 [] 运算符） [] 运算符：左边可以是 JavaBean 属性，Map，数组或 List 对象 [] 在指定索引是使用双引号，就是作为键名或索引来使用，不加双引号会先尝试运算。 运算符 算数运算符：+, -, *(mod), /(div), %(mod), ? : 逻辑运算符：and, or, not 关系运算符：&lt;(lt), &gt;(gt), &lt;=(le), &gt;=(ge), ==(eq), !=(ne) 自定义函数第一步：编写类，公开类，且调用的方法是公开且为静态方法 第二步：编写 TLD（标签程序描述）文件（xml文件，以 .tld 为后缀），告诉容器如何将类中的方法作为 EL 函数 第三步：将文件放在 WEB-INF 文件夹下或 JAR 文件中]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter5 Servlet 进阶API,过滤器与监听器]]></title>
    <url>%2Fposts%2Ffd419a6b%2F</url>
    <content type="text"><![CDATA[使用 ServletContext你可以把它想象成一个公用的空间，可以被所有的客户访问，也就是说A客户端可以访问D，B客户端可以访问D，C客户端也可以访问D。WEB容器在启动时，它会为每个Web应用程序都创建一个对应的ServletContext，它代表当前Web应用。并且它被所有客户端共享。ServletContext对象可以通过ServletConfig.getServletContext()方法获得对ServletContext对象的引用，也可以通过this.getServletContext()方法获得其对象的引用。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。公共聊天室就会用到它。当web应用关闭、Tomcat关闭或者Web应用reload的时候，ServletContext对象会被销毁作者：KLeonard来源：CSDN原文：https://blog.csdn.net/gavin_john/article/details/51399425版权声明：本文为博主原创文章，转载请附上博文链接！当整个Web应用程序加载Web容器后，容器会生成一个ServletContext对象作为整个应用程序的代表，可以通过ServletConfig的getServletContext()方法就可以取得ServletContext对象．ServletContext接口定义了运行Servlet的应用环境的一些行为，可以使用该接口的实现对象来取得所请求资源的URL，设置和存储属性，应用程序初始参数等．getRequestDispatcher()用来取得RequestDispatcher()实例，路径必须是绝对路径，即以＂/＂开头（代表应用程序根目录）．HttpServletRequest.getRequestDispatcher(String)既可以使用相对路径也可以使用绝对路径，但是实际上在实现时，如果是环境相对路径则直接委托给ServletContext的getServletContext()，如果是请求相对路径则转换为环境相对路径后，再委托．]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter4 会话管理基本原理]]></title>
    <url>%2Fposts%2Fb2e1ccaf%2F</url>
    <content type="text"><![CDATA[会话管理的基本原理Web应用程序中有些功能需要多次请求才能完成，所以需要某些方式来记得此次请求与之后请求之间的关系，这类方式称之为会话管理．会话管理的基本方式有：隐藏域（Hidden Field），Cookie，URL重写等使用隐藏域在HTTP协议中，服务器并没有记忆功能，那么可以让浏览器在每次请求时＂主动告知＂服务器多次请求间的必要信息，服务器只需单纯处理请求中的信息就好．隐藏域就是主动告知服务器多次请求间必要信息的方式之一．使用隐藏域的缺点：&emsp;&emsp;关掉网页后会丢失之前的信息，仅适合简单的状态管理，查看网页源码可以看到隐藏的信息，不适合用于隐秘性较高的数据．隐藏域不是Servlet/JSP实际管理会话时的机制，实现Web应用程序会话的基本原理是由浏览器主动告知必要的信息．使用 CookieCookie 是在浏览器存储信息的一种方式，服务器可以响应浏览器 set-cookie 标头，浏览器收到标头与数值后会以文件的形式存储在计算机上，即 Cookie.Cookie 可以设置存活期限．Servlet可以通过Cookie类的getMaxAge()方法获取Cookie的有效期；Servlet可以通过设置Cookie类的setMaxAge( int expiry );//expiry默认值为 -1；1.如果expiry大于0，则保存有效期为expire时间长度，单位毫秒；2.如果expiry等于0，则指示浏览器删除当前cookie；3.如果expiry小于0，则指示浏览器不保存该cookie到硬盘，就保存在内存中，浏览器关闭就消失；创建Cookie:12345Cookie cookie = new Cookie("user", "caterpillar");cookie.setMaxAge(7 * 24 * 60 * 60); // 以秒为单位// 创建cookie及其存活期限response.addCookie(cookie);// 将cookie加入响应之中获取Cookie12345678910111213Cookie[] cookies = request.getCookies();// 取得 Cookieif(cookies != null) &#123; for (Cookie cookie : cookies) &#123; String name = cookie.getName(); // 获取Cookie名称 String value = cookie.getValue(); // 获取Cookie数值 if ("user".equals(name) &amp;&amp; "caterpillar".equals(value)) &#123; request.setAttribute(name, value); request.getRequestDispatcher("/user.view").forward(request, response); return; &#125; &#125;&#125;Servlet 3.0 中，Cookie增加了setHttpOnly()方法，将Cookie标示为仅用于HTTP，如果浏览器支持，这个Cookie不会被客户端脚本读取，可以用isHttpOnly()方法判断是否被标示使用 URL 重写URL重写就是GET请求参数的应用，当服务器响应浏览器的上一次请求时，将某些相关信息以超链接的方式响应给浏览器，超链接包括请求参数信息．由于URL重写是在超链接之后附加信息，所以必须以GET方式发送请求．通常URL重写是用在一些简单的客户端信息保留，或者辅助会话管理．HttpSession 会话管理Servlet/JSP中会话管理的机制：HttpSession使用 HttpSession获得HttpSession实例：12345HttpSession session = request.getSession();// getSession()有两个版本// 另一个可以传入布尔值作为参数, // 默认为true，表示尚未存在HttpSession对象时, 直接创建一个新的对象// 如果是false，如不存在实例返回null默认在浏览器关闭前，HttpSession都是相同的实例，如果想要让目前的HttpSession失效可以调用HttpSession的invalidate()方法，执行这个方法后，容器会销毁回收HttpSession对象，再调用getSession()取得的对象是另一个新对象.设置与获得属性：setAttribute()：设置属性getAttribute()：获得属性HttpSession不是线程安全，需要注意属性设定的共享存取问题HttpSession 会话管理原理尝试运行HttpSession的getSession()方法时，Web容器会创建HttpSession对象，每个对象都有一个特殊的ID: Session ID，可以用HttpSession的getId()来取得Session ID，ID默认使用Cookie存储在浏览器中．HttpSession中存放的属性也存放在服务端的Web容器里，当浏览器请求应用程序时，会将Cookie中的Session ID 一同发送给应用程序里，Web容器会根据得到的ID找到对应的Session对象，这样就可以取得各浏览器的各自的会话数据．Web容器存储Session ID的Cookie默认设置当浏览器被关闭就失效，浏览器重新启动后由于ID失效，尝试getSession()后，容器会产生新的HttpSession对象，如果不使用invalidate()使对象立即失效，对象会等到设定的失效期间过后才会被销毁回收．设置HttpSession对象失效时间的方法：调用该对象的setMaxInactiveInterval()方法，设定浏览器多久没请求应用程序的话就自动失效，单位为秒；也可以在web.xml中修改，设定的单位是分钟123456&lt;web-app...&gt; ... &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt;HttpSession的属性中尽量不要存储耗资源的对象，必要时将属性移除（public void removeAttribute(String name)），或者让其失效．Servlet 3.0 中新增了SessonCookieConfig接口，可以通过ServleContext的getSessionCookieConfig()取得该接口的对象，通过这个接口的实现对象可以设定存储Session ID的Cookie相关的信息，设定必须在ServletContext初始化之前在web.xml中设定实现ServletContextListenerHttpSession 与 URL 重写因为HttpSession默认使用Cookie来存储ID，如果浏览器禁用Cookie，还想使用HttpSession来进行会话管理的话，可以搭配URL重写，向浏览器响应一段超链接，超链接URL附加上Session ID，单击超链接后将Session ID以GET请求发送给Web应用程序．如果要使用URL重写的方式发送Session ID，可以使用HttpServletResponse的encodeURL()协助产生需要的URL，如果Cookie可用，将URL本身输出，如果不可以会自动产生带有Session ID的URL重写．]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter3 请求与响应]]></title>
    <url>%2Fposts%2F2b70cf0d%2F</url>
    <content type="text"><![CDATA[从容器到 HttpServletweb 容器做了什么当浏览器请求来到HTTP服务器, HTTP服务器转交给容器, 容器会创建一个代表本次请求的HttpServlet对象, 并传给请求的相关信息, 同时会创建一个HttpServletResponse对象, 作为稍后要对客户端进行响应的Java对象.然后, 容器会根据@WebServlet标注或web.xml的设置, 找到处理该请求的Servlet, 调用它的service()方法, 传入容器在之前所创建的两个对象, 在service()方法中会根据HTTP请求的方式来调用对应的doXXX()方法.最后容器将HttpServletRequest对象和HttpServletResponse对象销毁回收, 结束本次响应.doXXX() 方法Servlet接口的service()方法中, 实际接受的参数是ServletRequest, ServletResponse, 在定义Servlet时, 期待Servlet不止用于HTTP, 与HTTP相关的行为由两者的子接口HttpServletRequest, HttpServletResponse 定义.关于 HttpServletRequest处理请求参数与标头HttpServletRequest中定义了取得通用请求信息的方法getParameter(): 指定请求参数名称来取得对应的值1String username = request.getParameter("name");返回String对象, 如果请求中没有指定的参数名称, 返回nullgetParameterValues(): 若同一个请求参数名称有多个值, 可以使用这个方法1String[] values = request.getParameterValues("param");返回一个存储了参数的值的String数组getParameterNames(): 获取请求中所有的请求参数名称, 返回Enumeration对象12345Enumeration&lt;String&gt; e = req.getParameterNames();while (e.hasMoreElements()) &#123; String name = e.nextElement(); // ...&#125;getParameterMap(): 将请求参数以Map对象返回, 键为请求参数名(String), 值为请求参数值(String[])获取HTTP标头信息getHeader(): 与getParameter()类似, 指定标头名称返回标头信息getHeaders(): 与getParameterValues()类似, 指定标头名称返回Enumeration对象, 元素为字符串getHeaderName(): 与getParameterNames()类似, 取得所有标头名称, 返回Enumeration请求参数编码处理POST如果客户端没有在 Content-Type 标头中设置字符编码, 使用HttpSerletRequest的getCharacterEncoding()返回值是null可以使用HttpServletRequest的setCharacterEncoding()方法指定取得POST请求参数时使用的编码, 只有在取得参数前执行才有用.GET如果是GET, 上述的方法设置编码无用.另一种处理编码的方式: 通过String 的 getBytes()指定编码来取得字符串的字节数组, 然后再重新构造为正确编码的字符串.1234String name = req.getParameter("name");// 假设浏览器使用UTF-8, web容器使用ISO-8859-1name = new String(name.getBytes("ISO-8859-1"), "UTF-8");// public String(byte[] bytes, String charsetName);Tomcat8URI默认编码为“UTF-8”，而Tomcat7URI默认编码为“ISO-8859-1”原书为繁体, 如果要使结果正常需要使用Tomcat7环境, form-get.html, form-post.html两个网页用繁体(编码为Big5), 或者简体(编码为GBK)参考资料: (转)Java 正确的做字符串编码转换那么，如何利用getBytes 和 new String() 来进行编码转换呢？ 网上流传着一种错误的方法:GBK–&gt; UTF-8: new String( s.getBytes(“GBK”) , “UTF-8); ,这种方式是完全错误的，因为getBytes 的编码与 UTF-8 不一致，肯定是乱码。但是为什么在tomcat 下，使用 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 却可以用呢？ 答案是：tomcat 默认使用iso-8859-1编码， 也就是说，如果原本字符串是GBK的，tomcat传输过程中，将GBK转成iso-8859-1了，默认情况下，使用iso-8859-1读取中文肯定是有问题的，那么我们需要将iso-8859-1 再转成GBK， 而iso-8859-1 是单字节编码的，即他认为一个字节是一个字符， 那么这种转换不会对原来的字节数组做任何改变，因为字节数组本来就是由单个字节组成的，如果之前用GBK编码，那么转成iso-8859-1后编码内容完全没变， 则 s.getBytes(“iso-8859-1”) 实际上还是原来GBK的编码内容则 new String(s.getBytes(“iso-8859-1”) ,”GBK”) 就可以正确解码了。 所以说这是一种巧合。getReader(), getInputStream() 读取 Body 内容HttpServletRequest上有getReader()方法, 可以取得BufferedReader对象, 通过这个对象可以读取请求的 Body 数据.12345678910private String readBody(HttpServletRequest request) throws IOException &#123; BufferedReader reader = request.getReader(); // 取得 BufferedReader 对象, 通过该对象可以读取请求的 Body 数据 String input = null; String requestBody = ""; while ((input = reader.readLine()) != null) &#123; requestBody = requestBody + input + "&lt;br&gt;"; &#125; return requestBody;&#125;输出:1user=%E5%BC%A0%E4%B8%89&amp;passed=1234567&amp;login=%E9%80%81%E5%87%BA如果要上传文件, \&lt;form> 标签需要设置enctype属性为: multipart/form-datagetPart() , getParts() 取得上传文件在Servlet3.0之后, 新增了Part接口, 可以方便的进行文件上传处理, 可以通过HttpServletRequest的getPart()方法并指定名称才能取得Part实现对象.Servlet中要设置@MultipartConfig标注才能取得Part对象, 否则会得到null, 仅仅标注@MultipartConfig表示相关属性使用默认值:fileSizeThreshold: 0整数值, 若上传文件大小超过设置的值, 会先写入缓存文件loaction: 空字符串 “”设置写入文件时的目录maxFileSize: -1L 不限制大小限制上传文件的大小maxRequestSize: -1L 不限制请求个数限制 multipart/form-data请求个数也可以使用getParts()来上传多个文件, 该方法返回一个Collection&lt;Part&gt;123456789// ... for (Part part : req.getParts()) &#123; if(part.getName().startsWith("file")) &#123; // 使用getName()获取名称, startsWith()判断名称是否以file开头 String filename= getFilename(part); part.write(filename); &#125; &#125;// ...在 web.xml 中也可以设置@MultipartConfig属性:123456789...&lt;servlet&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;UploadServlet&lt;/servlet-class&gt; &lt;multipart-config&gt; &lt;location&gt;/tmp/&lt;/location&gt; &lt;/multipart-config&gt;&lt;/servlet&gt;...使用 RequestDispatcher 调派请求在 Web 应用程序中, 经常需要多个 Servlet 来完成请求, 这时可以使用HttpServletRequest的getRequestDispatcher()方法取得RequestDispatcher接口的实例, 调用时只需指定转发或包含相对的URL网址.使用 include() 方法RequestDispatcher 的 include() 方法可以将另一个 Servlet 的操作流程包括至目前 Servlet 操作流程之中.12RequestDispatcher dispatcher = req.getRequestDispatcher("other.view");dispatcher.include(req, resp);在取得RequestDispatcher时也可以包括查询字符串, ...(&quot;other.view?data=123456&quot;);请求范围属性在include()或forward()时如果包括请求参数的做法只适用于传递字符串给另一个Servlet, 在调派请求中, 如果有必须共享的对象, 可以设置请求范围属性HttpServletRequest上与请求范围属性有关的方法:setAttribute(): 指定名称与对象设置属性getAttribute(): 指定名称取得属性getAttributeNames(): 取得所有属性名称remoteAttribute(): 指定名称移除属性以java., javax.开头的名称通常保留, 用于表示一些特定的意义:javax.servlet.include.request_urijavax.servlet.include.context_pathjavax.servlet.include.servlet_pathjavax.servlet.include.path_infojavax.servlet.include.query_string在被包含的 Servlet 中分别表示上一个 Servlet 的 Request URI, Context path, Servlet path, Path info 和取得RequestDispatcher时给定的参数使用 forward() 方法调用时同样也要传入请求和响应对象, 表示要将请求处理转发给别的 Servlet , 对客户端的响应同时转发给另一个 Servlet如果要调用forward()方法, 当前的Servlet中不能有任何响应确认, 如果通过响应对象设置了响应但未确认, 响应设置会全部被忽略, 如果有响应确认了仍调用这个方法, 会抛出IllegalStateException]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chapter2 编写与设置Servlet]]></title>
    <url>%2Fposts%2F92aa08ef%2F</url>
    <content type="text"><![CDATA[在 HelloServlet 之后关于 HttpServletServlet 需要的包：1234567// 与 Servlet 定义相关的类或接口都位于 javax.servlet 包中// 与 HTTP 定义先关的类与接口都位于 javax.servlet.http 包中import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletRequest;当请求到来时，Web容器会调用 Servlet 的 service() 方法．HttpServlet 的 service() 方法的流程：123456789101112protected void servlet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); // 取得请求的方法 if (method.equals(METHOD_GET)) &#123; // ... doGet(req, resp); // ... &#125; else if (method.equals(METHOD_HEAD)) &#123; // ... doHead(req, resp); // ... &#125; else ...&#125;使用@WebServlet在Servlet3.0中，可以使用标注来告诉容器哪些Servlet会提供服务和额外的信息.123@WebServlet("/hello.view")public class HelloServlet extends HttpServlet &#123;// 告诉容器请求的URL如果是＂/hello.view＂，就由 HelloServlet 的实例来提供服务1234567891011@WebServlet( name = "Hello", // 告诉容器这个 Servlet 的名称为 Hello, 默认为 Servlet 类的完整名称 urlPatterns = &#123;"/hello.view"&#125;, // 如果客户端的请求的URL是/hello.view，由这个Servlet的实例来处理 loadOnStartup = 1 // 默认值: -1 // 容器在首次处理某个Servlet服务时才会初始化对应的Servlet实例， // 如果希望应用程序启动时就将Servlet类载入, 实例化并初始化 // 可以用loadOnStartup设置为大于0的值, 数字小的初始化, 相同的值由容器自定义行为)使用Web.xmlServlet3.0 之前, 必须通过web.xml来定义Servlet的相关信息, Servlet3.0中也可以用他来定义相关的信息.web.xml 中的设置会覆盖 Servlet 中定义的值（name 值要相同）.123456789101112131415&lt;!--...--&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!--名字--&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;!--Servlet 是 servlet-class 指定类的实例--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!--设置何时初始化, 值相同按照在web.xml中设置的顺序初始化--&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloUser.view&lt;/url-pattern&gt; &lt;!--如果客户端请求的URL是/helloUser.view, 则由HelloServlet这个Servlet来处理--&gt; &lt;/servlet-mapping&gt;&lt;!--...--&gt;文件组织与部署Web程序应用程序文件组织:123456789├── other│ └── \......└── web ├── index.jsp └── WEB-INF ├── classes │ └── HelloServlet.class ├── lib └── web.xmlWEB-INF: 目录名称固定, 该目录对外界封闭, 客户端无法使用HTTP的任何方式直接访问该目录下的文件及目录web.xml: 放在WEB-INF根目录下, 名称固定, Web应用程序部署描述文件lib: 放置JAR文件的目录, 放在WEB-INF根目录下, 名称固定classes: 放置编译后的.class文件的目录, 位于WEB_INF根目录下, 名称固定, 编译后的类文件, 必须有与包名称相符的目录结构在部署Web应用程序时, 会将Web应用程序封装为WAR文件, 如过服务器使用Tomcat, 可以将war文件放置在tomcat安装目录的webapps目录中, 然后重启Tomcat服务.然后可以用: http://(服务器ip或域名):(端口号)/(war文件名)/ 来访问进阶部署设置…]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JSP&amp;Servlet学习笔记</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程初探]]></title>
    <url>%2Fposts%2F906de7a0%2F</url>
    <content type="text"><![CDATA[[1] 线程线程线程是计算机独立运行(操作系统分配CPU时间的基本单位)的最小单位，运行时占用很少的系统资源单cpu单核：多个线程是交替执行的 多cpu多核：多个线程可以同时运行同一进程内的多个线程共享进程的地址空间线程之间的切换速度比进程的切换快很多进程通信要以专门的通信方式、一个线程的数据可以直接供同一进程的其他线程使用线程节约资源、节约时间、可以提高应用程序的响应速度、可以提高多处理器效率、改善程序的结构线程在进程内部共享的资源：地址空间、打开的文件描述符等待线程的私有数据：线程号寄存器（程序计数器、堆栈指针）栈信号掩码优先级私有的存储空间自己的错误返回码线程有自己的栈但是共享 堆(heap)We talked about the two types of memory available to a process or a thread, the stack and the heap. It is important to distinguish between these two types of process memory because each thread will have its own stack, but all the threads in a process will share the heap.——————————————— What’s the Diff: Programs, Processes, and ThreadsA thread in execution works withthread IDRegisters (program counter and working register set)Stack (for procedure call parameters, local variables etc.)A thread shares with other threads a process’s (to which it belongs to)Code sectionData section (static + heap)PermissionsOther resources (e.g. files)来源2关于线程的具体信息可以看这篇博客 Linux 线程的实质[2] 创建线程在主线程里创建线程后，程序会在创建线程的地方产生分支，变成两个程序来执行，一段代码可以被多个线程执行，线程在地位上是同等的，不存在父线程和子线程的概念创建线程的函数：123#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);参数意义：thread : 指向线程标识符的指针attr : 可指定线程的属性，如过是NULL则为默认属性start_routinez : 是一个函数指针，指向线程创建后要运行的函数，称为线程函数arg : 指向要传递给线程函数的参数返回值：线程创建成功返回0失败则返回出错编号其他的系统调用：12345678#include &lt;pthread.h&gt;pthread_t pthread_self(void); // 获取本线程的线程IDint pthread_equal(pthread_t t1, pthread_t t2); // 比较线程ID// 如果两个线程为同一线程返回非0值，否则返回0int pthread_once(pthread_once_t *once_control,void (*init_routine)(void)); // 保证线程函数只执行一次pthread_once_t once_control = PTHREAD_ONCE_INIT;// 成功完成后，pthread_once（）将返回零; 否则，返回错误编号以指示错误。[实例1]12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;int * thread(void * arg)&#123; pthread_t newthid; newthid = pthread_self(); // 返回新创建线程的ID printf("this is a new thread, thread ID = %u\n", newthid); return NULL;&#125;int main(int argc, char const *argv[])&#123; pthread_t thid; printf("main thread, ID is %u\n", pthread_self()); // 打印主线程ID if (pthread_create(&amp;thid, NULL, (void *)thread, NULL) != 0) // 创建一个线程, 创建成功返回 0 &#123; printf("thread creation failed\n"); exit(1); &#125; sleep(1); return 0;&#125;编译时需要链接 libpthread.a , gcc createthread.c -lpthread在某些情况，只需要执行一次函数，这时就需要用到 pthread_once()函数原型中的控制变量once_control必须初始化为 PTHREAD_ONCE_INIT(0), 否则线程函数不会执行123/* This is similar to a lock implementation, but we distinguish between three states: not yet initialized (0), initialization in progress, and initialization finished; If in the first state, threads will try to run the initialization by moving to the second state; the first thread to do so via a CAS on once_control runs init_routine, other threads block.*/[实例2]12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;pthread_once_t once = PTHREAD_ONCE_INIT;// 使用初值为PTHREAD_ONCE_INIT的once_control变量保证// 函数在本进程执行序列中仅执行一次。void run(void)&#123; printf("Function run is running in thread %u\n", pthread_self());&#125;void * thread1(void * arg)&#123; pthread_t thid = pthread_self(); printf("Current thread's ID is %u\n", thid); pthread_once(&amp;once, run); printf("thread1 ends\n");&#125;void * thread2(void * arg)&#123; pthread_t thid = pthread_self(); printf("Current thread's ID is %u\n", thid); pthread_once(&amp;once, run); printf("thread2 ends\n");&#125;int main()&#123; pthread_t thid1, thid2; pthread_create(&amp;thid1, NULL, thread1, NULL); pthread_create(&amp;thid2, NULL, thread2, NULL); sleep(3); printf("main thread exit!\n"); exit(0);&#125;在多线程编程环境下，如果pthread_once()调用出现在多个线程中，init_routine()函数仅执行一次，但究竟在哪个线程中执行是由内核调度来决定的。两种情况：线程属性线程创建函数的第二个参数的类型为: pthread_attr_t, 结构体定义为:123456789101112typedef struct&#123; int detachstate; // 线程的分离状态 int schedpolicy; // 线程的调度策略 int schedparam; // 线程的调度参数 int inheritsched; // 线程的继承性 int scope; // 线程的作用域 int guardsize; // 线程栈末尾的警戒缓冲区大小 int stackaddr_set; // 堆栈地址集 int stackaddr; // 堆栈的大小 int stacksize; // 堆栈的大小&#125;pthread_attr_t;如果第二个参数为空，线程会采用默认的属性，绝大多数情况下不需要为线程特殊指定其属性。线程的属性只能在线程创建的时候指定，线程创建完成之后其属性不能被更改。默认属性:属性值结果scopePTHREAD_SCOPE_PROCESS新线程与进程中的其他线程发生竞争。detachstatePTHREAD_CREATE_JOINABLE线程退出后，保留完成状态和线程 ID。stackaddrNULL新线程具有系统分配的栈地址。stacksize0新线程具有系统定义的栈大小。priority0新线程的优先级为 0。inheritschedPTHREAD_INHERIT_SCHED新线程继承父线程调度优先级。schedpolicySCHED_OTHER新线程对同步对象争用使用 Solaris 定义的固定优先级。线程将一直运行，直到被抢占或者直到线程阻塞或停止为止。由于线程的属性是不透明的，所以不能直接修改，而需要使用一系列的函数来初始化、配置、销毁。参考资料：[1]Creating a (Default) Thread[2]多线程编程指南 &gt; 第 3 章 线程属性 &gt; 属性对象初始化/销毁线程属性1234567#include &lt;pthread.h&gt;pthread_attr_t tattr;int ret;/* initialize an attribute to the default value */ret = pthread_attr_init(&amp;tattr);int pthread_attr_destroy(pthread_attr_t *attr);// 如果成功会返回0, 失败返回非0的错误代码初始化线程属性的时候系统会给属性对象分配内存，为了避免内存泄漏，当线程属性不再使用后应当调用pthread_attr_destroy()来释放分配的内存，销毁线程属性并不会影响创建时候使用了该线程属性的线程。当线程属性被销毁之后可以重新初始化它，但对已销毁的线程属性对象的任何使用的结果都是未定义的。线程栈大小12int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);默认情况下由系统设定栈的大小，可以用命令来查看系统的默认设置 ulimit -s设置栈的大小不是可移植的线程分离属性1234// set/get detach state attribute in thread attributes objectint pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); // On success, these functions return 0; on error, they return a nonzero error number.pthread_attr_setdetachstate()中detachstate的值有两种：PTHREAD_CREATE_DETACHEDPTHREAD_CREATE_JOINABLE(默认属性)如果是PTHREAD_CREATE_JOINABLE，需要调用 pthread_join 或 pthread_detach来释放资源(线程的描述信息和stack)。调用pthread_detach的过程是不可逆的。可连接和分离的线程 | Joinable and Detached Threads线程栈溢出保护区大小12int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize); int pthread_attr_getguardsize(pthread_attr_t *attr, size_t *guardsize);当我们使用线程栈超过了设定大小之后，系统还会使用部分扩展内存(guardsize大小)来防止栈溢出。如果没有guardsize，当一个线程的栈溢出到其他的区域，该区域又是可写的，会造成不可预料的后果，而且覆盖了那部分内存之后也不会产生任何错误或者是信号。这种情况很难确定应该为栈分配多大的内存。当设置了guardsize之后，如果栈溢出后尝试写入这部分内存，会给进程发送信号并且终止它。What is guard size in Posix?线程竞争CPU的范围12int pthread_attr_getscope(const pthread_attr_t *attr,int *contentionscope); int pthread_attr_setscope(pthread_attr_t *attr, int contentionscope);POSIX 定义了两个值:PTHREAD_SCOPE_SYSTEM: 与系统中的所有线程一起竞争PTHREAD_SCOPE_PROCESS:只与同进程的线程竞争线程调度策略12int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy); int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);进程的调度策略和优先级属于主线程，设置进程的调度策略和优先级只会影响主线程的调度策略和优先级。每一个对等线程能够拥有它自己的独立于主线程的调度策略和优先级。在 Linux 系统中，进程有三种调度策略：SCHED_FIFO(实时、先入先出)、SCHED_RR(实时、轮转) 和 SCHED_OTHER（正常、非实时）（默认属性）。线程继承的调度策略12int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inheritsched); int pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched);在 pthread 库中，提供了一个函数，用来设置被创建的线程的调度属性：是从创建者线程继承调度属性（调度策略和优先级以及竞争范围），还是从属性对象设置调度属性。该函数就是：123456int pthread_attr_setinheritsched (pthread_attr_t * attr, int inherit) 当中，inherit 的值为下列值中的其一：enum&#123; PTHREAD_INHERIT_SCHED, //线程调度属性从创建者线程继承（默认属性） PTHREAD_EXPLICIT_SCHED //线程调度属性设置为 attr 设置的属性&#125;;假设在创建新的线程时，调用该函数将參数设置为 PTHREAD_INHERIT_SCHED 时，那么当改动进程的优先级时。该进程中继承这个优先级而且还没有改变其优先级的所有线程也将会跟着改变优先级。线程调度參数123456int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param); int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param); //sched_param结构体 struct sched_param &#123; int sched_priority; /* Scheduling priority */ &#125;;sched_priority 仅当调度策略为(SCHED_RR 或 SCHED_FIFO)时才有效，默认为0[3] 线程终止有两种终止线程的方式：通过 return 从线程返回调用函数 pthread_exit() 使线程退出pthread_exit()123// pthread_exit - terminate calling thread#include &lt;pthread.h&gt;void c(void *retval);两种特殊情况：如果从 main() 函数返回或调用了 exit 函数退出了主线程，则整个进程将会终止，进程终端所有线程也会终止，故主线程不能过早的从 main 函数返回。如果主线程调用了 pthread_exit 函数，仅仅是主线程消亡，进程不会结束，进程内的其他线程也不会结束直至所有的线程结束线程的取消线程可以创建也可以取消，一个线程可以向另一个线程发送结束请求，实现这种机制用到了一个函数：123// pthread_cancel - send a cancellation request to a thread#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);函数执行成功返回0,失败返回非零的错误码。函数执行成功并不意味着所要请求的线程会被取消，另一个线程接受到取消的请求后，具体行为依赖于线程的类型和状态(tyep and state)。线程的state和type可以通过下面两个函数来设置：123#include &lt;pthread.h&gt;int pthread_setcancelstate(int state, int *oldstate);int pthread_setcanceltype(int type, int *oldtype);stateenabled(默认)[PTHREAD_CANCEL_ENABLE]如果是这种状态，线程会取消，但何时取消依赖于type的值disabled[PTHREAD_CANCEL_DISABLE]线程会继续执行type:deferred(默认)[PTHREAD_CANCEL_DEFERRED]－－同步state如果为enabled，线程会继续执行，当遇到取消点的时候退出POSIX 标准规定了一些函数作为取消点，当线程调用这些函数的时候就会结束，具体函数可以查看 man 7 pthreadsasynchronous[PTHREAD_CANCEL_ASYNCHRONOUS]－异步state为enabled的情况下，type为这个值意味着线程可以在任何时候取消，当线程收到取消请求后，通常会立即退出临界资源的释放虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。 对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。临界资源在一段时间内只能被一个线程所持有，当线程要访问临界资源的时候需要提出请求，如果该资源没有被使用则申请成功，否则等待。临界资源使用完后需要释放以供其他线程使用。当一个线程终止时，如果不释放线程所占有的临界资源，则该资源还会被认为被使用中，如果另一个线程在等待使用这个临界资源，那它可能会无限等待下去，形成了死锁。Linux 系统提供了一对函数：pthread_cleanup_push()、pthread_cleanup_pop() 来自动释放资源，两个函数以宏定义提供，所以两个程序必须成对出现且位于同一代码段才能通过编译。pthread_cleanup_push()/pthread_cleanup_pop()采用先入后出的栈结构管理，void routine(void *arg)函数在调用pthread_cleanup_push()时压入清理函数栈，多次对pthread_cleanup_push()的调用将在清理函数栈中形成一个函数链，在执行该函数链时按照压栈的相反顺序弹出。execute参数表示执行到pthread_cleanup_pop()时是否在弹出清理函数的同时执行该函数，为0表示不执行，非0为执行；这个参数并不影响异常终止时清理函数的执行。如果线程处于PTHREAD_CANCEL_ASYNCHRONOUS状态，上述代码段就有可能出错，因为CANCEL事件有可能在pthread_cleanup_push()和pthread_mutex_lock()之间发生，或者在pthread_mutex_unlock()和pthread_cleanup_pop()之间发生，从而导致清理函数unlock一个并没有加锁的mutex变量，造成错误。因此，在使用清理函数的时候，都应该暂时设置成PTHREAD_CANCEL_DEFERRED模式。Posix线程编程指南(4)等待线程的结束函数pthread_join()用来等待线程的结束，其函数原型为：123// pthread_join - join with a terminated thread#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);pthread_join() 的调用者会被挂起睡眠，等待thread线程的结束，如果retval不为NULL，则这个值即为调用pthread_exit()的参数，如果线程是被取消的，retval的值是PTHREAD_CANCELED。测试了一下如果线程是return返回的话retval的值为0;一个线程只允许一个线程使用pthread_join来等待他的结束，否则第一个接收到的线程成功返回，其他调用这个函数的线程返回错误代码 ESRCH.thread 这个线程的状态必须是可join的。1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void assisthread(void * arg)&#123; printf("I am helping to do some jobs\n"); sleep(3); pthread_exit(0);&#125;int main(void)&#123; pthread_t assistthid; int status; pthread_create(&amp;assistthid, NULL, (void*) assisthread, NULL); pthread_join(assistthid, (void* )&amp;status); printf("assisthread's exit is caused %d\n", status); return 0;&#125;]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>Linux C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[readline库的简单使用]]></title>
    <url>%2Fposts%2F3faf94c3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这周要实现一个简单的 shell, 平时使用bash, zsh这些shell的时候, 如果文件名或命令太长，又或者要频繁执行几条命令的话，最常用的应该就是tab键补全和上下键切换历史命令了。&emsp;&emsp;想要在自己的shell里面实现这两个功能很困难，但有一个Ｃ语言库集成了这些功能，只需要调用几个函数就可以实现这两个功能。&emsp;&emsp;The GNU Readline Library&emsp;&emsp;可以在这里找到有关 readline 库的相关资料和下载地址，软件包里面也提供了很多手册和示例。&emsp;&emsp;实现shell用到的函数不是很多，tab键补全，上下键切换历史命令，添加历史命令等等readline()&emsp;&emsp;在 readline.h 里可以找到关于他的定义：123/* Readline functions. *//* Read a line of input. Prompt with PROMPT. A NULL PROMPT means none. */extern char *readline PARAMS((const char *));&nbsp;&nbsp;&nbsp;&nbsp;readline() 的参数是一个字符串，调用函数的时候会在屏幕上输出，这个函数会读取一行输入，然后返回一个指向输入字符串的指针，readline 会为输入的字符串动态分配内存，所以使用完之后需要free掉。&emsp;&emsp;下面举一个简单的例子1234567891011#include &lt;stdlib.h&gt;#include &lt;readline/readline.h&gt;int main(void)&#123; while (1) &#123; char * str = readline("Myshell $ "); free(str); &#125;&#125;&nbsp;&emsp;&emsp;由于readline是一个动态库，编译的时候需要加上 -lreadline，不然会找不到相关的函数当我们按下tab键之后发现就可以实现bash里面的补全功能了。&emsp;用惯了zsh后发现黑白的提示符好难看，于是也想着给里面的参数加上颜色。C语言中输出有颜色的字符printf就可以实现，模板类似这样printf(&quot;\033[47;31m string \033[0m&quot;);&emsp;&emsp;47是背景色，31是字符的颜色，string 是要输出的字符串，\033[5m 是ANSI控制码，意思是关闭输出的属性，不然以后的输出都会是之前设置的颜色。相关的内容网上有很多可以自行查阅。&emsp;&emsp;为了方便使用，加上了这些宏定义123#define CLOSE "\033[0m" // 关闭所有属性#define BLOD "\033[1m" // 强调、加粗、高亮#define BEGIN(x,y) "\033["#x";"#y"m" // x: 背景，y: 前景&emsp;&emsp;在修改一下readline()这个函数1char * str = readline(BEGIN(49, 34)"Myshell $ "CLOSE);&emsp;&emsp;然后编译运行：&emsp;&emsp;似乎一切完美，但当我们输入很长很长的字符串之后：&emsp;&emsp;&emsp;&emsp;emmmm……………输入太多会导致提示符被输入覆盖，写个shell出现这种状况岂不是贼尴尬&emsp;&emsp;查资料查了很久才找到解决方法：这个bug需要在非打印字符前后加上 \001 和 \002 才能解决&emsp;&emsp;其实头文件就有提到&emsp;&emsp;在之前定义的宏里面加上这两个字符之后终于解决了&emsp;&emsp;最后的代码为：12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;readline/readline.h&gt;#define CLOSE "\001\033[0m\002" // 关闭所有属性#define BLOD "\001\033[1m\002" // 强调、加粗、高亮#define BEGIN(x,y) "\001\033["#x";"#y"m\002" // x: 背景，y: 前景int main(void)&#123; while (1) &#123; char * str = readline(BEGIN(49, 34)"Myshell $ "CLOSE); free(str); &#125;&#125;&emsp;&emsp;readline使用的时候默认了tab补全，但是我们平时用到的shell不但可以补全文件名，还可以补全命令。readline库当然也提供了这个功能，具体如何使用可以看这篇博客。&emsp;&emsp;GNU Readline 库及编程简介&emsp;&emsp;单独的使用readline()并没有上下键切换补全的功能，实现这个需要用到另一个函数 - add_history()history.h&emsp;&emsp;上下键切换需要我们把输入的字符串加入到历史命令中，需要调用123/* Place STRING at the end of the history list. The associated data field (if any) is set to NULL. */extern void add_history PARAMS((const char *));&emsp;&emsp;函数接受一个字符串作为参数存入到历史文件中，函数的定义在history.h中，使用的时候需要包含头文件 &lt;readline/history.h&gt;&emsp;&emsp;我们在代码中加入这个函数的调用就可以使用上下键切换历史命令了123char * str = readline(BEGIN(49, 34)"Myshell $ "CLOSE);add_history(str);free(str);&emsp;&emsp;编译后测试了一下发现功能完美运行。&emsp;&emsp;但是关掉程序在尝试一下发现，诶？我不能切换到上一次运行程序的历史命令，只能记录本次运行中输入的命令。然后开始查看头文件的内容，发现了不少和history有关的函数。&emsp;&emsp;其中有两个正好用的上12345678/* Add the contents of FILENAME to the history list, a line at a time. If FILENAME is NULL, then read from ~/.history. Returns 0 if successful, or errno if not. */extern int read_history PARAMS((const char *));/* Write the current history to FILENAME. If FILENAME is NULL, then write the history list to ~/.history. Values returned are as in read_history (). */extern int write_history PARAMS((const char *));&emsp;&emsp;read_history()和write_history()都接受一个字符串做参数，成功返回０，错误则把相应的错误码赋值给errno。&emsp;&emsp;两个函数接受的参数都是一个文件名，read_history() 从指定的文件中读取历史记录，write_history() 将历史记录存入指定的文件。如果参数为NULL默认的文件是：~/.history&emsp;&emsp;有了这个函数，我们只要在程序最开处加上read_history(NULL), add_history(str)之后加上 write_history() 就可以了。&emsp;&emsp;这样下次运行程序的时候我们就可以找到上次运行的历史命令了。&emsp;&emsp;shell 的内置命令不多，cd 是一个, history也是一个shell内置的命令。&emsp;&emsp;readline既然可以把输入加入历史，读入和写进历史，那么自然可以读取历史文件列表，头文件中我们可以找到这样一个函数：12/* Return a NULL terminated array of HIST_ENTRY which is the current input history. Element 0 of this list is the beginning of time. If there is no history, return NULL. */extern HIST_ENTRY **history_list PARAMS((void));&emsp;&emsp;这个函数可以查看存储的 history 列表，HIST_ENTRY 是一个结构体类型，存储了很多信息：&emsp;&emsp;&emsp;&emsp;我们要的历史内容就存储在 data 元素里面。&emsp;&emsp;这个函数返回一个数组，以空指针为结束标志，我们简单封装一下就可以实现一个自己 shell 内置的 history 函数了。1234567891011void ShowHistory()&#123; int i = 0; HIST_ENTRY ** his; his = history_list(); while(his[i] != NULL) &#123; printf("%s\n", his[i]-&gt;line); i++; &#125;&#125;&emsp;&emsp;history.h 里面提供了很多函数，我们的要实现一个简单的shell用到的函数上面都提到过，更多的函数可以在官方文档里面查看。&emsp;&emsp;realine 这个库很强大，现在只是发现了他的冰山一角，提供的功能远远超过上述所说的。]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>readline</tag>
        <tag>Linux C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现简单ls命令遇到问题的总结]]></title>
    <url>%2Fposts%2Fe262bfcf%2F</url>
    <content type="text"><![CDATA[这周要写一个小项目，利用《linux C 编程实战》第6章的内容实现一个简单的 ls 命令，写的时候出现很多问题，现在将问题总结一下。要实现的ls命令需要实现 -l, -a , -A 等参数。我们在终端测试一下系统的ls命令:可以发现系统的ls可以根据终端的宽度来调整输出列数，而不至于输出的内容由于终端大小的限制显示不全。如果想要实现类似的功能，首先需要获取终端的宽度，然后计算输出文件列表的最大列数，最后按列将文件输出到屏幕上。终端宽度的获取查了很多，发现书上提到的 int ioctl(int fd, int cmd, ...)可以实现这个功能, 先放出代码：1234567// 获取终端宽度int get_ter_size (void)&#123; struct winsize w; ioctl(STDOUT_FILENO, TIOCGWINSZ, &amp;w); return w.ws_col;&#125;ioctl 可以控制特殊设备文件的属性，第一个参数是一个以及打开的文件描述符，STDOUT_FILENO 是标准输出的POSIX 名称，他的文件描述符是1，可以在 unistd.h 找到它的宏定义。使用man 2 ioctl_tty 可以查询到其他两个参数的信息：TIOCGWINSZ 是一个获取终端大小的命令，w是一个struct winsize ，其中的 w.ws_col 就存储了我们想得到的终端宽度。计算输出列表的最大列数没想出来有什么比较好的方法来通过已经给定的一系列字符串和一个限制宽度来求出在这个宽度限制内输出的最大列数。所以最后决定暴力穷举，将列数从大到小一个一个的尝试。12345678910111213141516171819202122232425262728293031323334353637int Cal_Print(char b[][NAME_MAX + 10], int a[], int n) // 暴力运算, 求出打印的列数&#123; // b 是一个二维数组，存储了要计算宽度的文件名 int t = get_ter_size(); // 终端宽度 int i = n &lt; MAX_C ? n : MAX_C; // 设定最大列数初始值 int length; // 计算字符串长度 for (int j = 0; j &lt; n; j++) a[j] = strlen(b[j]); for (; i &gt;= 1; i--) &#123; int c = n % i ? (n / i + 1) : (n / i); if ((i - 1) * c &gt;= n) continue; length = 0; int max_len[MAX_C] = &#123;0&#125;; for (int j = 0; j &lt; i; j++) &#123; int k = j * c; for (int m = 0; m &lt; c &amp;&amp; k &lt; n; m++, k++) if (a[k] &gt; max_len[j]) max_len[j] = a[k]; length += max_len[j]; if (j != i - 1) length += 2; &#125; if (length &lt; t) return i; i--; &#125; if (!i) i = 1; return i;&#125;得到终端宽度后，在代码中我限制了最大宽度为25(MAX_C), 这个数差不多足够了，之后如果文件的总数小于最大宽度，那么就从文件的总数n开始穷举（毕竟最多也就一个文件名放一列）。有了总数n和列i之后，很简单就能计算出行。计算每一列字符串最大的长度后加起来，再算上分割列之间的 （i-1)×2 的空格，如果总长度不大于终端宽度，这个列数就是我们所需要的。计算完行数之后还会有一个问题，我们是为了解决在终端中按行打印文件名的问题，打印出来的结果只有最后一列可以空几个文件名，也就是要保证除了最后一列其他列都要填满。所以加上一个判断条件：if ((i - 1) * c &gt;= n) continue;在计算 max_len[j] 一定要注意加上 k &lt; n 这个条件，不然如果在 i * c &gt; n 的情况下数组会越界。还有一种极端情况：终端宽度太小，导致最后算出的 i 值为0, 这种情况就讲i的值设为1，默认输出一列。按列输出由于要以整齐的方式按列输出 需要我们之前计算过的字符串长度，为了方便我们直接在计算完列数之后就输出文件目录：1234567891011121314151617int kneed = c - i * c + n; // 最后一列的行数for (int p = 0; p &lt; c; p++) // c 行数&#123; for (int o = 0; o &lt; i - 1; o++) // i 列数 先输出前 i-1 列 &#123; printf("%s", b[p + o*c]); PrintB(max_len[o] - a[p + o*c]); PrintB(2); // 输出空格以整齐排列 &#125; if (kneed) // 如果最后一列的第p行有内容就输出 &#123; printf("%s", b[p + (i-1) * c]); kneed--; &#125; printf("\n");&#125;break;代码中我用了PrintB(int num)来输出空格， 也可以简单一点使用printf 的 * 修饰符来控制格式printf(&quot;%s%*s&quot;, b[p + o*c], max_len[o] - a[p + o*c] + 2, &quot; &quot;);最开始以为这么弄就应该没问题了，也测试过输出格式，但是emmmm…..如果文件名里面有中文的话，strlen会把中文识别为3个字节，但是一个中文其实差不多只占两个，如果文件名有中文的话会导致很严重的排版错误。。。。具体可以看一下这两篇博客：https://whoisnian.com/2018/01/24/Linux%E4%B8%8Bls%E5%91%BD%E4%BB%A4%E6%8E%92%E7%89%88/http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.htmlUTF-8 的编码规则很简单，只有二条：1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。1234567891011121314151617181920212223// 代码来自 https://whoisnian.com/2018/01/24/Linux%E4%B8%8Bls%E5%91%BD%E4%BB%A4%E6%8E%92%E7%89%88/int Str_UTF(char * str) // 只占两个宽度的中文字符会识别为三个字节&#123; int num = 0, i; while (*str != '\0') &#123; if (*str &gt; 0) // 如果是单字节符号(这里指 英文符号)，正常计算长度 &#123; num++; str++; &#125; else &#123; // n字节的符号（n &gt; 1），第一个字节的前n位都设为1 for (i = 7; i &gt;= 0; i--) if (!((*str &gt;&gt; i) &amp; 1)) // 右移运算，把第 n+1 位上的０恰好移到 这个字节的最后一位，第7 ~ i+1次, 最后一位会是１ break; num += 2; // 中文按两个字节算 str += 7 - i; // 跳过这个中文符号(占用7-i个字节) &#125; &#125; return num;&#125;手写一个strlen之后就可以正常显示了。在这里也吐槽下中文字符排序的问题，以前一直认为中文排序可以用strcmp来解决，这次写ls命令测试发现中文的编码比较乱，而且涉及到多音字的问题，中文的排序比较复杂，不是直接比较编码就能搞定的。写 ls -R 时关于递归的问题最开始在实现 -R 参数的时候用了递归，其中解析文件属性用了 stat() 函数。但是在测试递归主目录的时候发现了一个很严重的问题，平时用 stat 和 lstat 的区别就是在链接文件的识别上，一个识别链接文件指向的文件，另一个是链接文件本身。我的主目录下有一个文件夹：/home/username/.deepinwine/Deepin-TIM/dosdevices查看具体属性后：lrwxrwxrwx 1 username username 1 7月 26 19:28 z: -&gt; /emm… 这个文件是指向系统根目录的，如果递归到这个文件会出现无限死循环。。。。当然递归时候也需要注意跳过. 和 .. 这两个特殊目录。。不然也会出现无限递归死循环的问题。]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>Linux C</tag>
      </tags>
  </entry>
</search>
